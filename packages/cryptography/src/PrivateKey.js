import nacl from "tweetnacl";
import { PublicKey } from "./PublicKey.js";
import {
    arraysEqual,
    deriveChildKey,
    deriveChildKey2,
    ED25519PRIVATEKEY_PREFIX
} from "./util.js";
import { createKeystore, loadKeystore } from "./Keystore.js";
import { BadKeyError } from "../errors/BadKeyError.js";
import { BadPemFileError } from "../errors/BadPemFileError.js";
import { EncryptedPrivateKeyInfo } from "./pkcs.js";
import { decodeDer } from "./der.js";
import * as base64 from "../encoding/base64.js";
import * as hex from "./hex.js";
import * as hmac from "./hmac.js";
import * as pbkdf2 from "./pbkdf2.js";

const BEGIN_PRIVATEKEY = "-----BEGIN PRIVATE KEY-----\n";
const END_PRIVATEKEY = "-----END PRIVATE KEY-----\n";

const BEGIN_ENCRYPTED_PRIVATEKEY = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n";
const END_ENCRYPTED_PRIVATEKEY = "-----END ENCRYPTED PRIVATE KEY-----\n";

const DER_PREFIX = hex.decode("302e020100300506032b657004220420");

/**
 * @param {Uint8Array} bytes
 * @returns {nacl.SignKeyPair}
 */
function _bytesLengthCases(bytes) {
    // this check is necessary because Jest breaks the prototype chain of Uint8Array
    // noinspection SuspiciousTypeOfGuard
    const bytesArray = bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes);

    switch (bytes.length) {
        case 48:
            // key with prefix
            if (arraysEqual(bytesArray.subarray(0, 16), DER_PREFIX)) {
                return nacl.sign.keyPair.fromSeed(bytesArray.subarray(16));
            }
            break;
        case 32:
            // fromSeed takes the private key bytes and calculates the public key
            return nacl.sign.keyPair.fromSeed(bytesArray);
        case 64:
            // priv + pub key pair
            return nacl.sign.keyPair.fromSecretKey(bytesArray);
        default:
    }
    throw new BadKeyError();
}

export class PrivateKey {
    /**
     * @param {{privateKey: Uint8Array, publicKey: Uint8Array }}
     */
    constructor({ privateKey, publicKey }) {
        if (privateKey.length !== nacl.sign.secretKeyLength) {
            throw new BadKeyError();
        }

        /**
         * @type {Uint8Array}
         */
        this.#keyData = privateKey;

        /**
         * @type {PublicKey}
         */
        this.publicKey = PublicKey.fromBytes(publicKey);

        /**
         * @type {Uint8Array | null}
         */
        this.#chainCode = null;

        /**
         * @type {string | null}
         */
        this.#asStringRaw = null;
    }

    /**
     * Recover a private key from its raw bytes form.
     *
     * This key will _not_ support child key derivation.
     *
     * @param {Uint8Array} bytes
     * @returns {PrivateKey}
     */
    static fromBytes(bytes) {
        const keypair = _bytesLengthCases(bytes);

        const { secretKey: privateKey, publicKey } = keypair;

        return new PrivateKey({ privateKey, publicKey });
    }

    /**
     * Recover a key from a hex-encoded string.
     *
     * This key will _not_ support child key derivation.
     *
     * @param {string} keyStr
     * @returns {PrivateKey}
     */
    static fromString(keyStr) {
        switch (keyStr.length) {
            case 64: // lone private key
            case 128: { // private key + key
                const newKey = PrivateKey.fromBytes(hex.decode(keyStr));
                newKey._asStringRaw = keyStr;
                return newKey;
            }
            case 96:
                if (keyStr.startsWith(ED25519PRIVATEKEY_PREFIX)) {
                    const rawStr = keyStr.slice(32);
                    const newKey = PrivateKey.fromBytes(hex.decode(rawStr));
                    newKey._asStringRaw = rawStr;
                    return newKey;
                }
                break;
            default:
            throw new BadKeyError();
        }
    }

    /**
     * Recover a key from a 24 or 22-word mnemonic.
     *
     * There is no corresponding `toMnemonic()` as the mnemonic cannot be recovered from the key.
     *
     * Instead, you must generate a mnemonic and a corresponding key in that order with
     * `generateMnemonic()`.
     *
     * This accepts mnemonics generated by the Android and iOS mobile wallets.
     *
     * This key *will* support deriving child keys with `.derive()`.
     *
     * If the mnemonic has 22 words, the resulting key will not support deriving child keys.
     *
     * @param {Mnemonic} mnemonic the mnemonic, either as a string separated by spaces or as a 24-element array
     * @param {string} passphrase the passphrase to protect the private key with
     * @returns {Promise<PrivateKey>}
     *
     * @link generateMnemonic
     */
    static async fromMnemonic(mnemonic, passphrase) {
        if (mnemonic._isLegacy) {
            return mnemonic._legacyToPrivateKey();
        }

        const input = mnemonic.toString();
        const salt = `mnemonic${passphrase}`;
        const seed = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha512, input, salt, 2048, 64);

        const digest = await hmac.hash(hmac.HashAlgorithm.Sha512, "ed25519 seed", seed);

        /**
         * @type {Uint8Array}
         */
        let keyBytes = digest.subarray(0, 32);

        /**
         * @type {Uint8Array}
         */
        let chainCode = digest.subarray(32);

        for (const index of [ 44, 3030, 0, 0 ]) {
            ({ keyBytes, chainCode } = deriveChildKey(keyBytes, chainCode, index));
        }

        const key = PrivateKey.fromBytes(keyBytes);
        key.#chainCode = chainCode;
        return key;
    }

    /**
     * Recover a private key from a keystore blob previously created by `.createKeystore()`.
     *
     * This key will _not_ support child key derivation.
     *
     * @param {Uint8Array} keystore the keystore blob
     * @param {string} passphrase the passphrase used to create the keystore
     * @returns {Promise<PrivateKey>}
     * @throws KeyMismatchError if the passphrase is incorrect or the hash fails to validate
     * @link createKeystore
     */
    static async fromKeystore(keystore, passphrase) {
        return new PrivateKey(await loadKeystore(keystore, passphrase));
    }

    /**
     * Generate a new, cryptographically random private key.
     *
     * This key will _not_ support child key derivation.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generate() {
        return this.fromBytes(nacl.randomBytes(32));
    }

    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation`
     *
     * Will eventually replace `PrivateKey.derive()`
     *
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     */
    async derive(index) {
        if (this.#chainCode == null) {
            throw new Error("this  private key does not support key derivation");
        }

        const {
            keyBytes,
            chainCode
        } = await deriveChildKey2(this.#keyData.subarray(0, 32), this.#chainCode, index);

        const key = PrivateKey.fromBytes(keyBytes);
        key.#chainCode = chainCode;

        return key;
    }

    /** Check if this private key supports deriving child keys
     * @returns {boolean}
     */
    get supportsDerivation() {
        return this.#chainCode != null;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        // copy the bytes so they can't be modified accidentally
        // only copy the private key portion since that's what we're expecting on the other end
        return this.#keyData.slice(0, 32);
    }

    /**
     * @param {boolean} raw
     * @returns {string}
     */
    toString(raw = false) {
        if (this._asStringRaw == null) {
            // only encode the private portion of the private key
            this._asStringRaw = hex.encode(this.#keyData.subarray(0, 32), true);
        }

        return (raw ? "" : ED25519PRIVATEKEY_PREFIX) + this._asStringRaw;
    }

    /**
     * Create a keystore blob with a given passphrase.
     *
     * The key can be recovered later with `fromKeystore()`.
     *
     * Note that this will not retain the ancillary data used for deriving child keys,
     * thus `.derive()` on the restored key will throw even if this instance supports derivation.
     *
     * @param {string} passphrase
     * @returns {Promise<Uint8Array>}
     * @link fromKeystore
     */
    toKeystore(passphrase) {
        return createKeystore(this.#keyData, passphrase);
    }

    /**
     * Recover a private key from a pem string; the private key may be encrypted.
     *
     * This method assumes the .pem file has been converted to a string already.
     *
     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
     * section and decodes that as a DER-encoded  private key.
     *
     * @param {string} pem
     * @param {string | undefined} passphrase
     * @returns {Promise<PrivateKey>}
     */
    static async fromPem(pem, passphrase) {
        const beginTag = passphrase ? BEGIN_ENCRYPTED_PRIVATEKEY : BEGIN_PRIVATEKEY;
        const endTag = passphrase ? END_ENCRYPTED_PRIVATEKEY : END_PRIVATEKEY;

        const beginIndex = pem.indexOf(beginTag);
        const endIndex = pem.indexOf(endTag);

        if (beginIndex === -1 || endIndex === -1) {
            throw new BadPemFileError();
        }

        const keyEncoded = pem.slice(beginIndex + beginTag.length, endIndex);

        const key = base64.decode(keyEncoded);

        if (passphrase) {
            let encrypted;

            try {
                encrypted = EncryptedPrivateKeyInfo.parse(key);
            } catch (error) {
                throw new BadKeyError(`failed to parse encrypted private key: ${error.message}`);
            }

            const decrypted = await encrypted.decrypt(passphrase);

            if (decrypted.algId.algIdent !== "1.3.101.112") {
                throw new BadKeyError(`unknown private key algorithm ${decrypted.algId}`);
            }

            const keyData = decodeDer(decrypted.privateKey);

            if ("bytes" in keyData) {
                return PrivateKey.fromBytes(keyData.bytes);
            }

            throw new BadKeyError(`expected ASN bytes, got ${JSON.stringify(keyData)}`);
        }

        return PrivateKey.fromBytes(key);
    }
}
