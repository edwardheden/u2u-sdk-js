// /*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
// import * as $protobuf from "protobufjs/minimal";
// 
// // Common aliases
// const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// 
// // Exported root namespace
// const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
// 
// export const proto = $root.proto = (() => {
// 
//     /**
//      * Namespace proto.
//      * @exports proto
//      * @namespace
//      */
//     const proto = {};
// 
//     proto.ShardID = (function() {
// 
//         /**
//          * Properties of a ShardID.
//          * @memberof proto
//          * @interface IShardID
//          * @property {number|Long|null} [shardNum] ShardID shardNum
//          */
// 
//         /**
//          * Constructs a new ShardID.
//          * @memberof proto
//          * @classdesc Represents a ShardID.
//          * @implements IShardID
//          * @constructor
//          * @param {proto.IShardID=} [properties] Properties to set
//          */
//         function ShardID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ShardID shardNum.
//          * @member {number|Long} shardNum
//          * @memberof proto.ShardID
//          * @instance
//          */
//         ShardID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new ShardID instance using the specified properties.
//          * @function create
//          * @memberof proto.ShardID
//          * @static
//          * @param {proto.IShardID=} [properties] Properties to set
//          * @returns {proto.ShardID} ShardID instance
//          */
//         ShardID.create = function create(properties) {
//             return new ShardID(properties);
//         };
// 
//         /**
//          * Encodes the specified ShardID message. Does not implicitly {@link proto.ShardID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ShardID
//          * @static
//          * @param {proto.IShardID} message ShardID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ShardID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ShardID message, length delimited. Does not implicitly {@link proto.ShardID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ShardID
//          * @static
//          * @param {proto.IShardID} message ShardID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ShardID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ShardID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ShardID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ShardID} ShardID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ShardID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ShardID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.shardNum = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ShardID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ShardID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ShardID} ShardID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ShardID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ShardID message.
//          * @function verify
//          * @memberof proto.ShardID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ShardID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
//                     return "shardNum: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ShardID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ShardID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ShardID} ShardID
//          */
//         ShardID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ShardID)
//                 return object;
//             let message = new $root.proto.ShardID();
//             if (object.shardNum != null)
//                 if ($util.Long)
//                     (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
//                 else if (typeof object.shardNum === "string")
//                     message.shardNum = parseInt(object.shardNum, 10);
//                 else if (typeof object.shardNum === "number")
//                     message.shardNum = object.shardNum;
//                 else if (typeof object.shardNum === "object")
//                     message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ShardID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ShardID
//          * @static
//          * @param {proto.ShardID} message ShardID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ShardID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.shardNum = options.longs === String ? "0" : 0;
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (typeof message.shardNum === "number")
//                     object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
//                 else
//                     object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
//             return object;
//         };
// 
//         /**
//          * Converts this ShardID to JSON.
//          * @function toJSON
//          * @memberof proto.ShardID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ShardID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ShardID;
//     })();
// 
//     proto.RealmID = (function() {
// 
//         /**
//          * Properties of a RealmID.
//          * @memberof proto
//          * @interface IRealmID
//          * @property {number|Long|null} [shardNum] RealmID shardNum
//          * @property {number|Long|null} [realmNum] RealmID realmNum
//          */
// 
//         /**
//          * Constructs a new RealmID.
//          * @memberof proto
//          * @classdesc Represents a RealmID.
//          * @implements IRealmID
//          * @constructor
//          * @param {proto.IRealmID=} [properties] Properties to set
//          */
//         function RealmID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * RealmID shardNum.
//          * @member {number|Long} shardNum
//          * @memberof proto.RealmID
//          * @instance
//          */
//         RealmID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * RealmID realmNum.
//          * @member {number|Long} realmNum
//          * @memberof proto.RealmID
//          * @instance
//          */
//         RealmID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new RealmID instance using the specified properties.
//          * @function create
//          * @memberof proto.RealmID
//          * @static
//          * @param {proto.IRealmID=} [properties] Properties to set
//          * @returns {proto.RealmID} RealmID instance
//          */
//         RealmID.create = function create(properties) {
//             return new RealmID(properties);
//         };
// 
//         /**
//          * Encodes the specified RealmID message. Does not implicitly {@link proto.RealmID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.RealmID
//          * @static
//          * @param {proto.IRealmID} message RealmID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         RealmID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
//             if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified RealmID message, length delimited. Does not implicitly {@link proto.RealmID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.RealmID
//          * @static
//          * @param {proto.IRealmID} message RealmID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         RealmID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a RealmID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.RealmID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.RealmID} RealmID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         RealmID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RealmID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.shardNum = reader.int64();
//                     break;
//                 case 2:
//                     message.realmNum = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a RealmID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.RealmID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.RealmID} RealmID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         RealmID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a RealmID message.
//          * @function verify
//          * @memberof proto.RealmID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         RealmID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
//                     return "shardNum: integer|Long expected";
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
//                     return "realmNum: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a RealmID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.RealmID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.RealmID} RealmID
//          */
//         RealmID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.RealmID)
//                 return object;
//             let message = new $root.proto.RealmID();
//             if (object.shardNum != null)
//                 if ($util.Long)
//                     (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
//                 else if (typeof object.shardNum === "string")
//                     message.shardNum = parseInt(object.shardNum, 10);
//                 else if (typeof object.shardNum === "number")
//                     message.shardNum = object.shardNum;
//                 else if (typeof object.shardNum === "object")
//                     message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
//             if (object.realmNum != null)
//                 if ($util.Long)
//                     (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
//                 else if (typeof object.realmNum === "string")
//                     message.realmNum = parseInt(object.realmNum, 10);
//                 else if (typeof object.realmNum === "number")
//                     message.realmNum = object.realmNum;
//                 else if (typeof object.realmNum === "object")
//                     message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a RealmID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.RealmID
//          * @static
//          * @param {proto.RealmID} message RealmID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         RealmID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.shardNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.realmNum = options.longs === String ? "0" : 0;
//             }
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (typeof message.shardNum === "number")
//                     object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
//                 else
//                     object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (typeof message.realmNum === "number")
//                     object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
//                 else
//                     object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
//             return object;
//         };
// 
//         /**
//          * Converts this RealmID to JSON.
//          * @function toJSON
//          * @memberof proto.RealmID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         RealmID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return RealmID;
//     })();
// 
//     proto.AccountID = (function() {
// 
//         /**
//          * Properties of an AccountID.
//          * @memberof proto
//          * @interface IAccountID
//          * @property {number|Long|null} [shardNum] AccountID shardNum
//          * @property {number|Long|null} [realmNum] AccountID realmNum
//          * @property {number|Long|null} [accountNum] AccountID accountNum
//          */
// 
//         /**
//          * Constructs a new AccountID.
//          * @memberof proto
//          * @classdesc Represents an AccountID.
//          * @implements IAccountID
//          * @constructor
//          * @param {proto.IAccountID=} [properties] Properties to set
//          */
//         function AccountID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * AccountID shardNum.
//          * @member {number|Long} shardNum
//          * @memberof proto.AccountID
//          * @instance
//          */
//         AccountID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * AccountID realmNum.
//          * @member {number|Long} realmNum
//          * @memberof proto.AccountID
//          * @instance
//          */
//         AccountID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * AccountID accountNum.
//          * @member {number|Long} accountNum
//          * @memberof proto.AccountID
//          * @instance
//          */
//         AccountID.prototype.accountNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new AccountID instance using the specified properties.
//          * @function create
//          * @memberof proto.AccountID
//          * @static
//          * @param {proto.IAccountID=} [properties] Properties to set
//          * @returns {proto.AccountID} AccountID instance
//          */
//         AccountID.create = function create(properties) {
//             return new AccountID(properties);
//         };
// 
//         /**
//          * Encodes the specified AccountID message. Does not implicitly {@link proto.AccountID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.AccountID
//          * @static
//          * @param {proto.IAccountID} message AccountID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         AccountID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
//             if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
//             if (message.accountNum != null && Object.hasOwnProperty.call(message, "accountNum"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int64(message.accountNum);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified AccountID message, length delimited. Does not implicitly {@link proto.AccountID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.AccountID
//          * @static
//          * @param {proto.IAccountID} message AccountID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         AccountID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an AccountID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.AccountID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.AccountID} AccountID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         AccountID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AccountID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.shardNum = reader.int64();
//                     break;
//                 case 2:
//                     message.realmNum = reader.int64();
//                     break;
//                 case 3:
//                     message.accountNum = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an AccountID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.AccountID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.AccountID} AccountID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         AccountID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an AccountID message.
//          * @function verify
//          * @memberof proto.AccountID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         AccountID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
//                     return "shardNum: integer|Long expected";
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
//                     return "realmNum: integer|Long expected";
//             if (message.accountNum != null && message.hasOwnProperty("accountNum"))
//                 if (!$util.isInteger(message.accountNum) && !(message.accountNum && $util.isInteger(message.accountNum.low) && $util.isInteger(message.accountNum.high)))
//                     return "accountNum: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates an AccountID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.AccountID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.AccountID} AccountID
//          */
//         AccountID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.AccountID)
//                 return object;
//             let message = new $root.proto.AccountID();
//             if (object.shardNum != null)
//                 if ($util.Long)
//                     (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
//                 else if (typeof object.shardNum === "string")
//                     message.shardNum = parseInt(object.shardNum, 10);
//                 else if (typeof object.shardNum === "number")
//                     message.shardNum = object.shardNum;
//                 else if (typeof object.shardNum === "object")
//                     message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
//             if (object.realmNum != null)
//                 if ($util.Long)
//                     (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
//                 else if (typeof object.realmNum === "string")
//                     message.realmNum = parseInt(object.realmNum, 10);
//                 else if (typeof object.realmNum === "number")
//                     message.realmNum = object.realmNum;
//                 else if (typeof object.realmNum === "object")
//                     message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
//             if (object.accountNum != null)
//                 if ($util.Long)
//                     (message.accountNum = $util.Long.fromValue(object.accountNum)).unsigned = false;
//                 else if (typeof object.accountNum === "string")
//                     message.accountNum = parseInt(object.accountNum, 10);
//                 else if (typeof object.accountNum === "number")
//                     message.accountNum = object.accountNum;
//                 else if (typeof object.accountNum === "object")
//                     message.accountNum = new $util.LongBits(object.accountNum.low >>> 0, object.accountNum.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an AccountID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.AccountID
//          * @static
//          * @param {proto.AccountID} message AccountID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         AccountID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.shardNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.realmNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.accountNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.accountNum = options.longs === String ? "0" : 0;
//             }
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (typeof message.shardNum === "number")
//                     object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
//                 else
//                     object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (typeof message.realmNum === "number")
//                     object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
//                 else
//                     object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
//             if (message.accountNum != null && message.hasOwnProperty("accountNum"))
//                 if (typeof message.accountNum === "number")
//                     object.accountNum = options.longs === String ? String(message.accountNum) : message.accountNum;
//                 else
//                     object.accountNum = options.longs === String ? $util.Long.prototype.toString.call(message.accountNum) : options.longs === Number ? new $util.LongBits(message.accountNum.low >>> 0, message.accountNum.high >>> 0).toNumber() : message.accountNum;
//             return object;
//         };
// 
//         /**
//          * Converts this AccountID to JSON.
//          * @function toJSON
//          * @memberof proto.AccountID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         AccountID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return AccountID;
//     })();
// 
//     proto.FileID = (function() {
// 
//         /**
//          * Properties of a FileID.
//          * @memberof proto
//          * @interface IFileID
//          * @property {number|Long|null} [shardNum] FileID shardNum
//          * @property {number|Long|null} [realmNum] FileID realmNum
//          * @property {number|Long|null} [fileNum] FileID fileNum
//          */
// 
//         /**
//          * Constructs a new FileID.
//          * @memberof proto
//          * @classdesc Represents a FileID.
//          * @implements IFileID
//          * @constructor
//          * @param {proto.IFileID=} [properties] Properties to set
//          */
//         function FileID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileID shardNum.
//          * @member {number|Long} shardNum
//          * @memberof proto.FileID
//          * @instance
//          */
//         FileID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FileID realmNum.
//          * @member {number|Long} realmNum
//          * @memberof proto.FileID
//          * @instance
//          */
//         FileID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FileID fileNum.
//          * @member {number|Long} fileNum
//          * @memberof proto.FileID
//          * @instance
//          */
//         FileID.prototype.fileNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new FileID instance using the specified properties.
//          * @function create
//          * @memberof proto.FileID
//          * @static
//          * @param {proto.IFileID=} [properties] Properties to set
//          * @returns {proto.FileID} FileID instance
//          */
//         FileID.create = function create(properties) {
//             return new FileID(properties);
//         };
// 
//         /**
//          * Encodes the specified FileID message. Does not implicitly {@link proto.FileID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileID
//          * @static
//          * @param {proto.IFileID} message FileID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
//             if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
//             if (message.fileNum != null && Object.hasOwnProperty.call(message, "fileNum"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fileNum);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileID message, length delimited. Does not implicitly {@link proto.FileID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileID
//          * @static
//          * @param {proto.IFileID} message FileID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileID} FileID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.shardNum = reader.int64();
//                     break;
//                 case 2:
//                     message.realmNum = reader.int64();
//                     break;
//                 case 3:
//                     message.fileNum = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileID} FileID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileID message.
//          * @function verify
//          * @memberof proto.FileID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
//                     return "shardNum: integer|Long expected";
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
//                     return "realmNum: integer|Long expected";
//             if (message.fileNum != null && message.hasOwnProperty("fileNum"))
//                 if (!$util.isInteger(message.fileNum) && !(message.fileNum && $util.isInteger(message.fileNum.low) && $util.isInteger(message.fileNum.high)))
//                     return "fileNum: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a FileID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileID} FileID
//          */
//         FileID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileID)
//                 return object;
//             let message = new $root.proto.FileID();
//             if (object.shardNum != null)
//                 if ($util.Long)
//                     (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
//                 else if (typeof object.shardNum === "string")
//                     message.shardNum = parseInt(object.shardNum, 10);
//                 else if (typeof object.shardNum === "number")
//                     message.shardNum = object.shardNum;
//                 else if (typeof object.shardNum === "object")
//                     message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
//             if (object.realmNum != null)
//                 if ($util.Long)
//                     (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
//                 else if (typeof object.realmNum === "string")
//                     message.realmNum = parseInt(object.realmNum, 10);
//                 else if (typeof object.realmNum === "number")
//                     message.realmNum = object.realmNum;
//                 else if (typeof object.realmNum === "object")
//                     message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
//             if (object.fileNum != null)
//                 if ($util.Long)
//                     (message.fileNum = $util.Long.fromValue(object.fileNum)).unsigned = false;
//                 else if (typeof object.fileNum === "string")
//                     message.fileNum = parseInt(object.fileNum, 10);
//                 else if (typeof object.fileNum === "number")
//                     message.fileNum = object.fileNum;
//                 else if (typeof object.fileNum === "object")
//                     message.fileNum = new $util.LongBits(object.fileNum.low >>> 0, object.fileNum.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileID
//          * @static
//          * @param {proto.FileID} message FileID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.shardNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.realmNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.fileNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.fileNum = options.longs === String ? "0" : 0;
//             }
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (typeof message.shardNum === "number")
//                     object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
//                 else
//                     object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (typeof message.realmNum === "number")
//                     object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
//                 else
//                     object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
//             if (message.fileNum != null && message.hasOwnProperty("fileNum"))
//                 if (typeof message.fileNum === "number")
//                     object.fileNum = options.longs === String ? String(message.fileNum) : message.fileNum;
//                 else
//                     object.fileNum = options.longs === String ? $util.Long.prototype.toString.call(message.fileNum) : options.longs === Number ? new $util.LongBits(message.fileNum.low >>> 0, message.fileNum.high >>> 0).toNumber() : message.fileNum;
//             return object;
//         };
// 
//         /**
//          * Converts this FileID to JSON.
//          * @function toJSON
//          * @memberof proto.FileID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FileID;
//     })();
// 
//     proto.ContractID = (function() {
// 
//         /**
//          * Properties of a ContractID.
//          * @memberof proto
//          * @interface IContractID
//          * @property {number|Long|null} [shardNum] ContractID shardNum
//          * @property {number|Long|null} [realmNum] ContractID realmNum
//          * @property {number|Long|null} [contractNum] ContractID contractNum
//          */
// 
//         /**
//          * Constructs a new ContractID.
//          * @memberof proto
//          * @classdesc Represents a ContractID.
//          * @implements IContractID
//          * @constructor
//          * @param {proto.IContractID=} [properties] Properties to set
//          */
//         function ContractID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractID shardNum.
//          * @member {number|Long} shardNum
//          * @memberof proto.ContractID
//          * @instance
//          */
//         ContractID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * ContractID realmNum.
//          * @member {number|Long} realmNum
//          * @memberof proto.ContractID
//          * @instance
//          */
//         ContractID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * ContractID contractNum.
//          * @member {number|Long} contractNum
//          * @memberof proto.ContractID
//          * @instance
//          */
//         ContractID.prototype.contractNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new ContractID instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractID
//          * @static
//          * @param {proto.IContractID=} [properties] Properties to set
//          * @returns {proto.ContractID} ContractID instance
//          */
//         ContractID.create = function create(properties) {
//             return new ContractID(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractID message. Does not implicitly {@link proto.ContractID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractID
//          * @static
//          * @param {proto.IContractID} message ContractID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
//             if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
//             if (message.contractNum != null && Object.hasOwnProperty.call(message, "contractNum"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int64(message.contractNum);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractID message, length delimited. Does not implicitly {@link proto.ContractID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractID
//          * @static
//          * @param {proto.IContractID} message ContractID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractID} ContractID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.shardNum = reader.int64();
//                     break;
//                 case 2:
//                     message.realmNum = reader.int64();
//                     break;
//                 case 3:
//                     message.contractNum = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractID} ContractID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractID message.
//          * @function verify
//          * @memberof proto.ContractID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
//                     return "shardNum: integer|Long expected";
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
//                     return "realmNum: integer|Long expected";
//             if (message.contractNum != null && message.hasOwnProperty("contractNum"))
//                 if (!$util.isInteger(message.contractNum) && !(message.contractNum && $util.isInteger(message.contractNum.low) && $util.isInteger(message.contractNum.high)))
//                     return "contractNum: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ContractID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractID} ContractID
//          */
//         ContractID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractID)
//                 return object;
//             let message = new $root.proto.ContractID();
//             if (object.shardNum != null)
//                 if ($util.Long)
//                     (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
//                 else if (typeof object.shardNum === "string")
//                     message.shardNum = parseInt(object.shardNum, 10);
//                 else if (typeof object.shardNum === "number")
//                     message.shardNum = object.shardNum;
//                 else if (typeof object.shardNum === "object")
//                     message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
//             if (object.realmNum != null)
//                 if ($util.Long)
//                     (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
//                 else if (typeof object.realmNum === "string")
//                     message.realmNum = parseInt(object.realmNum, 10);
//                 else if (typeof object.realmNum === "number")
//                     message.realmNum = object.realmNum;
//                 else if (typeof object.realmNum === "object")
//                     message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
//             if (object.contractNum != null)
//                 if ($util.Long)
//                     (message.contractNum = $util.Long.fromValue(object.contractNum)).unsigned = false;
//                 else if (typeof object.contractNum === "string")
//                     message.contractNum = parseInt(object.contractNum, 10);
//                 else if (typeof object.contractNum === "number")
//                     message.contractNum = object.contractNum;
//                 else if (typeof object.contractNum === "object")
//                     message.contractNum = new $util.LongBits(object.contractNum.low >>> 0, object.contractNum.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractID
//          * @static
//          * @param {proto.ContractID} message ContractID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.shardNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.realmNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.contractNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.contractNum = options.longs === String ? "0" : 0;
//             }
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (typeof message.shardNum === "number")
//                     object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
//                 else
//                     object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (typeof message.realmNum === "number")
//                     object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
//                 else
//                     object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
//             if (message.contractNum != null && message.hasOwnProperty("contractNum"))
//                 if (typeof message.contractNum === "number")
//                     object.contractNum = options.longs === String ? String(message.contractNum) : message.contractNum;
//                 else
//                     object.contractNum = options.longs === String ? $util.Long.prototype.toString.call(message.contractNum) : options.longs === Number ? new $util.LongBits(message.contractNum.low >>> 0, message.contractNum.high >>> 0).toNumber() : message.contractNum;
//             return object;
//         };
// 
//         /**
//          * Converts this ContractID to JSON.
//          * @function toJSON
//          * @memberof proto.ContractID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractID;
//     })();
// 
//     proto.TransactionID = (function() {
// 
//         /**
//          * Properties of a TransactionID.
//          * @memberof proto
//          * @interface ITransactionID
//          * @property {proto.ITimestamp|null} [transactionValidStart] TransactionID transactionValidStart
//          * @property {proto.IAccountID|null} [accountID] TransactionID accountID
//          */
// 
//         /**
//          * Constructs a new TransactionID.
//          * @memberof proto
//          * @classdesc Represents a TransactionID.
//          * @implements ITransactionID
//          * @constructor
//          * @param {proto.ITransactionID=} [properties] Properties to set
//          */
//         function TransactionID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionID transactionValidStart.
//          * @member {proto.ITimestamp|null|undefined} transactionValidStart
//          * @memberof proto.TransactionID
//          * @instance
//          */
//         TransactionID.prototype.transactionValidStart = null;
// 
//         /**
//          * TransactionID accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.TransactionID
//          * @instance
//          */
//         TransactionID.prototype.accountID = null;
// 
//         /**
//          * Creates a new TransactionID instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionID
//          * @static
//          * @param {proto.ITransactionID=} [properties] Properties to set
//          * @returns {proto.TransactionID} TransactionID instance
//          */
//         TransactionID.create = function create(properties) {
//             return new TransactionID(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionID message. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionID
//          * @static
//          * @param {proto.ITransactionID} message TransactionID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.transactionValidStart != null && Object.hasOwnProperty.call(message, "transactionValidStart"))
//                 $root.proto.Timestamp.encode(message.transactionValidStart, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionID message, length delimited. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionID
//          * @static
//          * @param {proto.ITransactionID} message TransactionID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionID} TransactionID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.transactionValidStart = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionID} TransactionID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionID message.
//          * @function verify
//          * @memberof proto.TransactionID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.transactionValidStart != null && message.hasOwnProperty("transactionValidStart")) {
//                 let error = $root.proto.Timestamp.verify(message.transactionValidStart);
//                 if (error)
//                     return "transactionValidStart." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionID} TransactionID
//          */
//         TransactionID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionID)
//                 return object;
//             let message = new $root.proto.TransactionID();
//             if (object.transactionValidStart != null) {
//                 if (typeof object.transactionValidStart !== "object")
//                     throw TypeError(".proto.TransactionID.transactionValidStart: object expected");
//                 message.transactionValidStart = $root.proto.Timestamp.fromObject(object.transactionValidStart);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.TransactionID.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionID
//          * @static
//          * @param {proto.TransactionID} message TransactionID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.transactionValidStart = null;
//                 object.accountID = null;
//             }
//             if (message.transactionValidStart != null && message.hasOwnProperty("transactionValidStart"))
//                 object.transactionValidStart = $root.proto.Timestamp.toObject(message.transactionValidStart, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionID to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionID;
//     })();
// 
//     proto.TopicID = (function() {
// 
//         /**
//          * Properties of a TopicID.
//          * @memberof proto
//          * @interface ITopicID
//          * @property {number|Long|null} [shardNum] TopicID shardNum
//          * @property {number|Long|null} [realmNum] TopicID realmNum
//          * @property {number|Long|null} [topicNum] TopicID topicNum
//          */
// 
//         /**
//          * Constructs a new TopicID.
//          * @memberof proto
//          * @classdesc Represents a TopicID.
//          * @implements ITopicID
//          * @constructor
//          * @param {proto.ITopicID=} [properties] Properties to set
//          */
//         function TopicID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TopicID shardNum.
//          * @member {number|Long} shardNum
//          * @memberof proto.TopicID
//          * @instance
//          */
//         TopicID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * TopicID realmNum.
//          * @member {number|Long} realmNum
//          * @memberof proto.TopicID
//          * @instance
//          */
//         TopicID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * TopicID topicNum.
//          * @member {number|Long} topicNum
//          * @memberof proto.TopicID
//          * @instance
//          */
//         TopicID.prototype.topicNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new TopicID instance using the specified properties.
//          * @function create
//          * @memberof proto.TopicID
//          * @static
//          * @param {proto.ITopicID=} [properties] Properties to set
//          * @returns {proto.TopicID} TopicID instance
//          */
//         TopicID.create = function create(properties) {
//             return new TopicID(properties);
//         };
// 
//         /**
//          * Encodes the specified TopicID message. Does not implicitly {@link proto.TopicID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TopicID
//          * @static
//          * @param {proto.ITopicID} message TopicID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TopicID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
//             if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
//             if (message.topicNum != null && Object.hasOwnProperty.call(message, "topicNum"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int64(message.topicNum);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TopicID message, length delimited. Does not implicitly {@link proto.TopicID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TopicID
//          * @static
//          * @param {proto.ITopicID} message TopicID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TopicID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TopicID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TopicID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TopicID} TopicID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TopicID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TopicID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.shardNum = reader.int64();
//                     break;
//                 case 2:
//                     message.realmNum = reader.int64();
//                     break;
//                 case 3:
//                     message.topicNum = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TopicID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TopicID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TopicID} TopicID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TopicID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TopicID message.
//          * @function verify
//          * @memberof proto.TopicID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TopicID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
//                     return "shardNum: integer|Long expected";
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
//                     return "realmNum: integer|Long expected";
//             if (message.topicNum != null && message.hasOwnProperty("topicNum"))
//                 if (!$util.isInteger(message.topicNum) && !(message.topicNum && $util.isInteger(message.topicNum.low) && $util.isInteger(message.topicNum.high)))
//                     return "topicNum: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a TopicID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TopicID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TopicID} TopicID
//          */
//         TopicID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TopicID)
//                 return object;
//             let message = new $root.proto.TopicID();
//             if (object.shardNum != null)
//                 if ($util.Long)
//                     (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
//                 else if (typeof object.shardNum === "string")
//                     message.shardNum = parseInt(object.shardNum, 10);
//                 else if (typeof object.shardNum === "number")
//                     message.shardNum = object.shardNum;
//                 else if (typeof object.shardNum === "object")
//                     message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
//             if (object.realmNum != null)
//                 if ($util.Long)
//                     (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
//                 else if (typeof object.realmNum === "string")
//                     message.realmNum = parseInt(object.realmNum, 10);
//                 else if (typeof object.realmNum === "number")
//                     message.realmNum = object.realmNum;
//                 else if (typeof object.realmNum === "object")
//                     message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
//             if (object.topicNum != null)
//                 if ($util.Long)
//                     (message.topicNum = $util.Long.fromValue(object.topicNum)).unsigned = false;
//                 else if (typeof object.topicNum === "string")
//                     message.topicNum = parseInt(object.topicNum, 10);
//                 else if (typeof object.topicNum === "number")
//                     message.topicNum = object.topicNum;
//                 else if (typeof object.topicNum === "object")
//                     message.topicNum = new $util.LongBits(object.topicNum.low >>> 0, object.topicNum.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TopicID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TopicID
//          * @static
//          * @param {proto.TopicID} message TopicID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TopicID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.shardNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.realmNum = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.topicNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.topicNum = options.longs === String ? "0" : 0;
//             }
//             if (message.shardNum != null && message.hasOwnProperty("shardNum"))
//                 if (typeof message.shardNum === "number")
//                     object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
//                 else
//                     object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
//             if (message.realmNum != null && message.hasOwnProperty("realmNum"))
//                 if (typeof message.realmNum === "number")
//                     object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
//                 else
//                     object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
//             if (message.topicNum != null && message.hasOwnProperty("topicNum"))
//                 if (typeof message.topicNum === "number")
//                     object.topicNum = options.longs === String ? String(message.topicNum) : message.topicNum;
//                 else
//                     object.topicNum = options.longs === String ? $util.Long.prototype.toString.call(message.topicNum) : options.longs === Number ? new $util.LongBits(message.topicNum.low >>> 0, message.topicNum.high >>> 0).toNumber() : message.topicNum;
//             return object;
//         };
// 
//         /**
//          * Converts this TopicID to JSON.
//          * @function toJSON
//          * @memberof proto.TopicID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TopicID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TopicID;
//     })();
// 
//     proto.Key = (function() {
// 
//         /**
//          * Properties of a Key.
//          * @memberof proto
//          * @interface IKey
//          * @property {proto.IContractID|null} [contractID] Key contractID
//          * @property {Uint8Array|null} [ed25519] Key ed25519
//          * @property {Uint8Array|null} [RSA_3072] Key RSA_3072
//          * @property {Uint8Array|null} [ECDSA_384] Key ECDSA_384
//          * @property {proto.IThresholdKey|null} [thresholdKey] Key thresholdKey
//          * @property {proto.IKeyList|null} [keyList] Key keyList
//          */
// 
//         /**
//          * Constructs a new Key.
//          * @memberof proto
//          * @classdesc Represents a Key.
//          * @implements IKey
//          * @constructor
//          * @param {proto.IKey=} [properties] Properties to set
//          */
//         function Key(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Key contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.Key
//          * @instance
//          */
//         Key.prototype.contractID = null;
// 
//         /**
//          * Key ed25519.
//          * @member {Uint8Array} ed25519
//          * @memberof proto.Key
//          * @instance
//          */
//         Key.prototype.ed25519 = $util.newBuffer([]);
// 
//         /**
//          * Key RSA_3072.
//          * @member {Uint8Array} RSA_3072
//          * @memberof proto.Key
//          * @instance
//          */
//         Key.prototype.RSA_3072 = $util.newBuffer([]);
// 
//         /**
//          * Key ECDSA_384.
//          * @member {Uint8Array} ECDSA_384
//          * @memberof proto.Key
//          * @instance
//          */
//         Key.prototype.ECDSA_384 = $util.newBuffer([]);
// 
//         /**
//          * Key thresholdKey.
//          * @member {proto.IThresholdKey|null|undefined} thresholdKey
//          * @memberof proto.Key
//          * @instance
//          */
//         Key.prototype.thresholdKey = null;
// 
//         /**
//          * Key keyList.
//          * @member {proto.IKeyList|null|undefined} keyList
//          * @memberof proto.Key
//          * @instance
//          */
//         Key.prototype.keyList = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * Key key.
//          * @member {"contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList"|undefined} key
//          * @memberof proto.Key
//          * @instance
//          */
//         Object.defineProperty(Key.prototype, "key", {
//             get: $util.oneOfGetter($oneOfFields = ["contractID", "ed25519", "RSA_3072", "ECDSA_384", "thresholdKey", "keyList"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new Key instance using the specified properties.
//          * @function create
//          * @memberof proto.Key
//          * @static
//          * @param {proto.IKey=} [properties] Properties to set
//          * @returns {proto.Key} Key instance
//          */
//         Key.create = function create(properties) {
//             return new Key(properties);
//         };
// 
//         /**
//          * Encodes the specified Key message. Does not implicitly {@link proto.Key.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Key
//          * @static
//          * @param {proto.IKey} message Key message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Key.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.ed25519 != null && Object.hasOwnProperty.call(message, "ed25519"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ed25519);
//             if (message.RSA_3072 != null && Object.hasOwnProperty.call(message, "RSA_3072"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.RSA_3072);
//             if (message.ECDSA_384 != null && Object.hasOwnProperty.call(message, "ECDSA_384"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ECDSA_384);
//             if (message.thresholdKey != null && Object.hasOwnProperty.call(message, "thresholdKey"))
//                 $root.proto.ThresholdKey.encode(message.thresholdKey, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             if (message.keyList != null && Object.hasOwnProperty.call(message, "keyList"))
//                 $root.proto.KeyList.encode(message.keyList, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Key message, length delimited. Does not implicitly {@link proto.Key.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Key
//          * @static
//          * @param {proto.IKey} message Key message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Key.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Key message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Key
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Key} Key
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Key.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Key();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.ed25519 = reader.bytes();
//                     break;
//                 case 3:
//                     message.RSA_3072 = reader.bytes();
//                     break;
//                 case 4:
//                     message.ECDSA_384 = reader.bytes();
//                     break;
//                 case 5:
//                     message.thresholdKey = $root.proto.ThresholdKey.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.keyList = $root.proto.KeyList.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Key message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Key
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Key} Key
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Key.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Key message.
//          * @function verify
//          * @memberof proto.Key
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Key.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 properties.key = 1;
//                 {
//                     let error = $root.proto.ContractID.verify(message.contractID);
//                     if (error)
//                         return "contractID." + error;
//                 }
//             }
//             if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
//                 if (properties.key === 1)
//                     return "key: multiple values";
//                 properties.key = 1;
//                 if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
//                     return "ed25519: buffer expected";
//             }
//             if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
//                 if (properties.key === 1)
//                     return "key: multiple values";
//                 properties.key = 1;
//                 if (!(message.RSA_3072 && typeof message.RSA_3072.length === "number" || $util.isString(message.RSA_3072)))
//                     return "RSA_3072: buffer expected";
//             }
//             if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
//                 if (properties.key === 1)
//                     return "key: multiple values";
//                 properties.key = 1;
//                 if (!(message.ECDSA_384 && typeof message.ECDSA_384.length === "number" || $util.isString(message.ECDSA_384)))
//                     return "ECDSA_384: buffer expected";
//             }
//             if (message.thresholdKey != null && message.hasOwnProperty("thresholdKey")) {
//                 if (properties.key === 1)
//                     return "key: multiple values";
//                 properties.key = 1;
//                 {
//                     let error = $root.proto.ThresholdKey.verify(message.thresholdKey);
//                     if (error)
//                         return "thresholdKey." + error;
//                 }
//             }
//             if (message.keyList != null && message.hasOwnProperty("keyList")) {
//                 if (properties.key === 1)
//                     return "key: multiple values";
//                 properties.key = 1;
//                 {
//                     let error = $root.proto.KeyList.verify(message.keyList);
//                     if (error)
//                         return "keyList." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a Key message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Key
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Key} Key
//          */
//         Key.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Key)
//                 return object;
//             let message = new $root.proto.Key();
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.Key.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.ed25519 != null)
//                 if (typeof object.ed25519 === "string")
//                     $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
//                 else if (object.ed25519.length)
//                     message.ed25519 = object.ed25519;
//             if (object.RSA_3072 != null)
//                 if (typeof object.RSA_3072 === "string")
//                     $util.base64.decode(object.RSA_3072, message.RSA_3072 = $util.newBuffer($util.base64.length(object.RSA_3072)), 0);
//                 else if (object.RSA_3072.length)
//                     message.RSA_3072 = object.RSA_3072;
//             if (object.ECDSA_384 != null)
//                 if (typeof object.ECDSA_384 === "string")
//                     $util.base64.decode(object.ECDSA_384, message.ECDSA_384 = $util.newBuffer($util.base64.length(object.ECDSA_384)), 0);
//                 else if (object.ECDSA_384.length)
//                     message.ECDSA_384 = object.ECDSA_384;
//             if (object.thresholdKey != null) {
//                 if (typeof object.thresholdKey !== "object")
//                     throw TypeError(".proto.Key.thresholdKey: object expected");
//                 message.thresholdKey = $root.proto.ThresholdKey.fromObject(object.thresholdKey);
//             }
//             if (object.keyList != null) {
//                 if (typeof object.keyList !== "object")
//                     throw TypeError(".proto.Key.keyList: object expected");
//                 message.keyList = $root.proto.KeyList.fromObject(object.keyList);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Key message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Key
//          * @static
//          * @param {proto.Key} message Key
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Key.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//                 if (options.oneofs)
//                     object.key = "contractID";
//             }
//             if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
//                 object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
//                 if (options.oneofs)
//                     object.key = "ed25519";
//             }
//             if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
//                 object.RSA_3072 = options.bytes === String ? $util.base64.encode(message.RSA_3072, 0, message.RSA_3072.length) : options.bytes === Array ? Array.prototype.slice.call(message.RSA_3072) : message.RSA_3072;
//                 if (options.oneofs)
//                     object.key = "RSA_3072";
//             }
//             if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
//                 object.ECDSA_384 = options.bytes === String ? $util.base64.encode(message.ECDSA_384, 0, message.ECDSA_384.length) : options.bytes === Array ? Array.prototype.slice.call(message.ECDSA_384) : message.ECDSA_384;
//                 if (options.oneofs)
//                     object.key = "ECDSA_384";
//             }
//             if (message.thresholdKey != null && message.hasOwnProperty("thresholdKey")) {
//                 object.thresholdKey = $root.proto.ThresholdKey.toObject(message.thresholdKey, options);
//                 if (options.oneofs)
//                     object.key = "thresholdKey";
//             }
//             if (message.keyList != null && message.hasOwnProperty("keyList")) {
//                 object.keyList = $root.proto.KeyList.toObject(message.keyList, options);
//                 if (options.oneofs)
//                     object.key = "keyList";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this Key to JSON.
//          * @function toJSON
//          * @memberof proto.Key
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Key.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Key;
//     })();
// 
//     proto.ThresholdKey = (function() {
// 
//         /**
//          * Properties of a ThresholdKey.
//          * @memberof proto
//          * @interface IThresholdKey
//          * @property {number|null} [threshold] ThresholdKey threshold
//          * @property {proto.IKeyList|null} [keys] ThresholdKey keys
//          */
// 
//         /**
//          * Constructs a new ThresholdKey.
//          * @memberof proto
//          * @classdesc Represents a ThresholdKey.
//          * @implements IThresholdKey
//          * @constructor
//          * @param {proto.IThresholdKey=} [properties] Properties to set
//          */
//         function ThresholdKey(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ThresholdKey threshold.
//          * @member {number} threshold
//          * @memberof proto.ThresholdKey
//          * @instance
//          */
//         ThresholdKey.prototype.threshold = 0;
// 
//         /**
//          * ThresholdKey keys.
//          * @member {proto.IKeyList|null|undefined} keys
//          * @memberof proto.ThresholdKey
//          * @instance
//          */
//         ThresholdKey.prototype.keys = null;
// 
//         /**
//          * Creates a new ThresholdKey instance using the specified properties.
//          * @function create
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {proto.IThresholdKey=} [properties] Properties to set
//          * @returns {proto.ThresholdKey} ThresholdKey instance
//          */
//         ThresholdKey.create = function create(properties) {
//             return new ThresholdKey(properties);
//         };
// 
//         /**
//          * Encodes the specified ThresholdKey message. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {proto.IThresholdKey} message ThresholdKey message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ThresholdKey.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.threshold);
//             if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
//                 $root.proto.KeyList.encode(message.keys, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ThresholdKey message, length delimited. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {proto.IThresholdKey} message ThresholdKey message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ThresholdKey.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ThresholdKey message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ThresholdKey} ThresholdKey
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ThresholdKey.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ThresholdKey();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.threshold = reader.uint32();
//                     break;
//                 case 2:
//                     message.keys = $root.proto.KeyList.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ThresholdKey message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ThresholdKey} ThresholdKey
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ThresholdKey.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ThresholdKey message.
//          * @function verify
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ThresholdKey.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.threshold != null && message.hasOwnProperty("threshold"))
//                 if (!$util.isInteger(message.threshold))
//                     return "threshold: integer expected";
//             if (message.keys != null && message.hasOwnProperty("keys")) {
//                 let error = $root.proto.KeyList.verify(message.keys);
//                 if (error)
//                     return "keys." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ThresholdKey message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ThresholdKey} ThresholdKey
//          */
//         ThresholdKey.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ThresholdKey)
//                 return object;
//             let message = new $root.proto.ThresholdKey();
//             if (object.threshold != null)
//                 message.threshold = object.threshold >>> 0;
//             if (object.keys != null) {
//                 if (typeof object.keys !== "object")
//                     throw TypeError(".proto.ThresholdKey.keys: object expected");
//                 message.keys = $root.proto.KeyList.fromObject(object.keys);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ThresholdKey message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ThresholdKey
//          * @static
//          * @param {proto.ThresholdKey} message ThresholdKey
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ThresholdKey.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.threshold = 0;
//                 object.keys = null;
//             }
//             if (message.threshold != null && message.hasOwnProperty("threshold"))
//                 object.threshold = message.threshold;
//             if (message.keys != null && message.hasOwnProperty("keys"))
//                 object.keys = $root.proto.KeyList.toObject(message.keys, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ThresholdKey to JSON.
//          * @function toJSON
//          * @memberof proto.ThresholdKey
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ThresholdKey.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ThresholdKey;
//     })();
// 
//     proto.KeyList = (function() {
// 
//         /**
//          * Properties of a KeyList.
//          * @memberof proto
//          * @interface IKeyList
//          * @property {Array.<proto.IKey>|null} [keys] KeyList keys
//          */
// 
//         /**
//          * Constructs a new KeyList.
//          * @memberof proto
//          * @classdesc Represents a KeyList.
//          * @implements IKeyList
//          * @constructor
//          * @param {proto.IKeyList=} [properties] Properties to set
//          */
//         function KeyList(properties) {
//             this.keys = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * KeyList keys.
//          * @member {Array.<proto.IKey>} keys
//          * @memberof proto.KeyList
//          * @instance
//          */
//         KeyList.prototype.keys = $util.emptyArray;
// 
//         /**
//          * Creates a new KeyList instance using the specified properties.
//          * @function create
//          * @memberof proto.KeyList
//          * @static
//          * @param {proto.IKeyList=} [properties] Properties to set
//          * @returns {proto.KeyList} KeyList instance
//          */
//         KeyList.create = function create(properties) {
//             return new KeyList(properties);
//         };
// 
//         /**
//          * Encodes the specified KeyList message. Does not implicitly {@link proto.KeyList.verify|verify} messages.
//          * @function encode
//          * @memberof proto.KeyList
//          * @static
//          * @param {proto.IKeyList} message KeyList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         KeyList.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.keys != null && message.keys.length)
//                 for (let i = 0; i < message.keys.length; ++i)
//                     $root.proto.Key.encode(message.keys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified KeyList message, length delimited. Does not implicitly {@link proto.KeyList.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.KeyList
//          * @static
//          * @param {proto.IKeyList} message KeyList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         KeyList.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a KeyList message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.KeyList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.KeyList} KeyList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         KeyList.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.KeyList();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     if (!(message.keys && message.keys.length))
//                         message.keys = [];
//                     message.keys.push($root.proto.Key.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a KeyList message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.KeyList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.KeyList} KeyList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         KeyList.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a KeyList message.
//          * @function verify
//          * @memberof proto.KeyList
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         KeyList.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.keys != null && message.hasOwnProperty("keys")) {
//                 if (!Array.isArray(message.keys))
//                     return "keys: array expected";
//                 for (let i = 0; i < message.keys.length; ++i) {
//                     let error = $root.proto.Key.verify(message.keys[i]);
//                     if (error)
//                         return "keys." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a KeyList message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.KeyList
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.KeyList} KeyList
//          */
//         KeyList.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.KeyList)
//                 return object;
//             let message = new $root.proto.KeyList();
//             if (object.keys) {
//                 if (!Array.isArray(object.keys))
//                     throw TypeError(".proto.KeyList.keys: array expected");
//                 message.keys = [];
//                 for (let i = 0; i < object.keys.length; ++i) {
//                     if (typeof object.keys[i] !== "object")
//                         throw TypeError(".proto.KeyList.keys: object expected");
//                     message.keys[i] = $root.proto.Key.fromObject(object.keys[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a KeyList message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.KeyList
//          * @static
//          * @param {proto.KeyList} message KeyList
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         KeyList.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.keys = [];
//             if (message.keys && message.keys.length) {
//                 object.keys = [];
//                 for (let j = 0; j < message.keys.length; ++j)
//                     object.keys[j] = $root.proto.Key.toObject(message.keys[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this KeyList to JSON.
//          * @function toJSON
//          * @memberof proto.KeyList
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         KeyList.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return KeyList;
//     })();
// 
//     proto.Signature = (function() {
// 
//         /**
//          * Properties of a Signature.
//          * @memberof proto
//          * @interface ISignature
//          * @property {Uint8Array|null} [contract] Signature contract
//          * @property {Uint8Array|null} [ed25519] Signature ed25519
//          * @property {Uint8Array|null} [RSA_3072] Signature RSA_3072
//          * @property {Uint8Array|null} [ECDSA_384] Signature ECDSA_384
//          * @property {proto.IThresholdSignature|null} [thresholdSignature] Signature thresholdSignature
//          * @property {proto.ISignatureList|null} [signatureList] Signature signatureList
//          */
// 
//         /**
//          * Constructs a new Signature.
//          * @memberof proto
//          * @classdesc Represents a Signature.
//          * @implements ISignature
//          * @constructor
//          * @param {proto.ISignature=} [properties] Properties to set
//          */
//         function Signature(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Signature contract.
//          * @member {Uint8Array} contract
//          * @memberof proto.Signature
//          * @instance
//          */
//         Signature.prototype.contract = $util.newBuffer([]);
// 
//         /**
//          * Signature ed25519.
//          * @member {Uint8Array} ed25519
//          * @memberof proto.Signature
//          * @instance
//          */
//         Signature.prototype.ed25519 = $util.newBuffer([]);
// 
//         /**
//          * Signature RSA_3072.
//          * @member {Uint8Array} RSA_3072
//          * @memberof proto.Signature
//          * @instance
//          */
//         Signature.prototype.RSA_3072 = $util.newBuffer([]);
// 
//         /**
//          * Signature ECDSA_384.
//          * @member {Uint8Array} ECDSA_384
//          * @memberof proto.Signature
//          * @instance
//          */
//         Signature.prototype.ECDSA_384 = $util.newBuffer([]);
// 
//         /**
//          * Signature thresholdSignature.
//          * @member {proto.IThresholdSignature|null|undefined} thresholdSignature
//          * @memberof proto.Signature
//          * @instance
//          */
//         Signature.prototype.thresholdSignature = null;
// 
//         /**
//          * Signature signatureList.
//          * @member {proto.ISignatureList|null|undefined} signatureList
//          * @memberof proto.Signature
//          * @instance
//          */
//         Signature.prototype.signatureList = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * Signature signature.
//          * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList"|undefined} signature
//          * @memberof proto.Signature
//          * @instance
//          */
//         Object.defineProperty(Signature.prototype, "signature", {
//             get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new Signature instance using the specified properties.
//          * @function create
//          * @memberof proto.Signature
//          * @static
//          * @param {proto.ISignature=} [properties] Properties to set
//          * @returns {proto.Signature} Signature instance
//          */
//         Signature.create = function create(properties) {
//             return new Signature(properties);
//         };
// 
//         /**
//          * Encodes the specified Signature message. Does not implicitly {@link proto.Signature.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Signature
//          * @static
//          * @param {proto.ISignature} message Signature message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Signature.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract);
//             if (message.ed25519 != null && Object.hasOwnProperty.call(message, "ed25519"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ed25519);
//             if (message.RSA_3072 != null && Object.hasOwnProperty.call(message, "RSA_3072"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.RSA_3072);
//             if (message.ECDSA_384 != null && Object.hasOwnProperty.call(message, "ECDSA_384"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ECDSA_384);
//             if (message.thresholdSignature != null && Object.hasOwnProperty.call(message, "thresholdSignature"))
//                 $root.proto.ThresholdSignature.encode(message.thresholdSignature, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             if (message.signatureList != null && Object.hasOwnProperty.call(message, "signatureList"))
//                 $root.proto.SignatureList.encode(message.signatureList, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Signature message, length delimited. Does not implicitly {@link proto.Signature.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Signature
//          * @static
//          * @param {proto.ISignature} message Signature message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Signature.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Signature message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Signature
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Signature} Signature
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Signature.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Signature();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.contract = reader.bytes();
//                     break;
//                 case 2:
//                     message.ed25519 = reader.bytes();
//                     break;
//                 case 3:
//                     message.RSA_3072 = reader.bytes();
//                     break;
//                 case 4:
//                     message.ECDSA_384 = reader.bytes();
//                     break;
//                 case 5:
//                     message.thresholdSignature = $root.proto.ThresholdSignature.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.signatureList = $root.proto.SignatureList.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Signature message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Signature
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Signature} Signature
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Signature.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Signature message.
//          * @function verify
//          * @memberof proto.Signature
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Signature.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.contract != null && message.hasOwnProperty("contract")) {
//                 properties.signature = 1;
//                 if (!(message.contract && typeof message.contract.length === "number" || $util.isString(message.contract)))
//                     return "contract: buffer expected";
//             }
//             if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
//                     return "ed25519: buffer expected";
//             }
//             if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 if (!(message.RSA_3072 && typeof message.RSA_3072.length === "number" || $util.isString(message.RSA_3072)))
//                     return "RSA_3072: buffer expected";
//             }
//             if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 if (!(message.ECDSA_384 && typeof message.ECDSA_384.length === "number" || $util.isString(message.ECDSA_384)))
//                     return "ECDSA_384: buffer expected";
//             }
//             if (message.thresholdSignature != null && message.hasOwnProperty("thresholdSignature")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 {
//                     let error = $root.proto.ThresholdSignature.verify(message.thresholdSignature);
//                     if (error)
//                         return "thresholdSignature." + error;
//                 }
//             }
//             if (message.signatureList != null && message.hasOwnProperty("signatureList")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 {
//                     let error = $root.proto.SignatureList.verify(message.signatureList);
//                     if (error)
//                         return "signatureList." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a Signature message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Signature
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Signature} Signature
//          */
//         Signature.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Signature)
//                 return object;
//             let message = new $root.proto.Signature();
//             if (object.contract != null)
//                 if (typeof object.contract === "string")
//                     $util.base64.decode(object.contract, message.contract = $util.newBuffer($util.base64.length(object.contract)), 0);
//                 else if (object.contract.length)
//                     message.contract = object.contract;
//             if (object.ed25519 != null)
//                 if (typeof object.ed25519 === "string")
//                     $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
//                 else if (object.ed25519.length)
//                     message.ed25519 = object.ed25519;
//             if (object.RSA_3072 != null)
//                 if (typeof object.RSA_3072 === "string")
//                     $util.base64.decode(object.RSA_3072, message.RSA_3072 = $util.newBuffer($util.base64.length(object.RSA_3072)), 0);
//                 else if (object.RSA_3072.length)
//                     message.RSA_3072 = object.RSA_3072;
//             if (object.ECDSA_384 != null)
//                 if (typeof object.ECDSA_384 === "string")
//                     $util.base64.decode(object.ECDSA_384, message.ECDSA_384 = $util.newBuffer($util.base64.length(object.ECDSA_384)), 0);
//                 else if (object.ECDSA_384.length)
//                     message.ECDSA_384 = object.ECDSA_384;
//             if (object.thresholdSignature != null) {
//                 if (typeof object.thresholdSignature !== "object")
//                     throw TypeError(".proto.Signature.thresholdSignature: object expected");
//                 message.thresholdSignature = $root.proto.ThresholdSignature.fromObject(object.thresholdSignature);
//             }
//             if (object.signatureList != null) {
//                 if (typeof object.signatureList !== "object")
//                     throw TypeError(".proto.Signature.signatureList: object expected");
//                 message.signatureList = $root.proto.SignatureList.fromObject(object.signatureList);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Signature message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Signature
//          * @static
//          * @param {proto.Signature} message Signature
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Signature.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (message.contract != null && message.hasOwnProperty("contract")) {
//                 object.contract = options.bytes === String ? $util.base64.encode(message.contract, 0, message.contract.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract) : message.contract;
//                 if (options.oneofs)
//                     object.signature = "contract";
//             }
//             if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
//                 object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
//                 if (options.oneofs)
//                     object.signature = "ed25519";
//             }
//             if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
//                 object.RSA_3072 = options.bytes === String ? $util.base64.encode(message.RSA_3072, 0, message.RSA_3072.length) : options.bytes === Array ? Array.prototype.slice.call(message.RSA_3072) : message.RSA_3072;
//                 if (options.oneofs)
//                     object.signature = "RSA_3072";
//             }
//             if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
//                 object.ECDSA_384 = options.bytes === String ? $util.base64.encode(message.ECDSA_384, 0, message.ECDSA_384.length) : options.bytes === Array ? Array.prototype.slice.call(message.ECDSA_384) : message.ECDSA_384;
//                 if (options.oneofs)
//                     object.signature = "ECDSA_384";
//             }
//             if (message.thresholdSignature != null && message.hasOwnProperty("thresholdSignature")) {
//                 object.thresholdSignature = $root.proto.ThresholdSignature.toObject(message.thresholdSignature, options);
//                 if (options.oneofs)
//                     object.signature = "thresholdSignature";
//             }
//             if (message.signatureList != null && message.hasOwnProperty("signatureList")) {
//                 object.signatureList = $root.proto.SignatureList.toObject(message.signatureList, options);
//                 if (options.oneofs)
//                     object.signature = "signatureList";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this Signature to JSON.
//          * @function toJSON
//          * @memberof proto.Signature
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Signature.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Signature;
//     })();
// 
//     proto.ThresholdSignature = (function() {
// 
//         /**
//          * Properties of a ThresholdSignature.
//          * @memberof proto
//          * @interface IThresholdSignature
//          * @property {proto.ISignatureList|null} [sigs] ThresholdSignature sigs
//          */
// 
//         /**
//          * Constructs a new ThresholdSignature.
//          * @memberof proto
//          * @classdesc Represents a ThresholdSignature.
//          * @implements IThresholdSignature
//          * @constructor
//          * @param {proto.IThresholdSignature=} [properties] Properties to set
//          */
//         function ThresholdSignature(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ThresholdSignature sigs.
//          * @member {proto.ISignatureList|null|undefined} sigs
//          * @memberof proto.ThresholdSignature
//          * @instance
//          */
//         ThresholdSignature.prototype.sigs = null;
// 
//         /**
//          * Creates a new ThresholdSignature instance using the specified properties.
//          * @function create
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {proto.IThresholdSignature=} [properties] Properties to set
//          * @returns {proto.ThresholdSignature} ThresholdSignature instance
//          */
//         ThresholdSignature.create = function create(properties) {
//             return new ThresholdSignature(properties);
//         };
// 
//         /**
//          * Encodes the specified ThresholdSignature message. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {proto.IThresholdSignature} message ThresholdSignature message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ThresholdSignature.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.sigs != null && Object.hasOwnProperty.call(message, "sigs"))
//                 $root.proto.SignatureList.encode(message.sigs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ThresholdSignature message, length delimited. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {proto.IThresholdSignature} message ThresholdSignature message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ThresholdSignature.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ThresholdSignature message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ThresholdSignature} ThresholdSignature
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ThresholdSignature.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ThresholdSignature();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 2:
//                     message.sigs = $root.proto.SignatureList.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ThresholdSignature message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ThresholdSignature} ThresholdSignature
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ThresholdSignature.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ThresholdSignature message.
//          * @function verify
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ThresholdSignature.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.sigs != null && message.hasOwnProperty("sigs")) {
//                 let error = $root.proto.SignatureList.verify(message.sigs);
//                 if (error)
//                     return "sigs." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ThresholdSignature message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ThresholdSignature} ThresholdSignature
//          */
//         ThresholdSignature.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ThresholdSignature)
//                 return object;
//             let message = new $root.proto.ThresholdSignature();
//             if (object.sigs != null) {
//                 if (typeof object.sigs !== "object")
//                     throw TypeError(".proto.ThresholdSignature.sigs: object expected");
//                 message.sigs = $root.proto.SignatureList.fromObject(object.sigs);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ThresholdSignature message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ThresholdSignature
//          * @static
//          * @param {proto.ThresholdSignature} message ThresholdSignature
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ThresholdSignature.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.sigs = null;
//             if (message.sigs != null && message.hasOwnProperty("sigs"))
//                 object.sigs = $root.proto.SignatureList.toObject(message.sigs, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ThresholdSignature to JSON.
//          * @function toJSON
//          * @memberof proto.ThresholdSignature
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ThresholdSignature.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ThresholdSignature;
//     })();
// 
//     proto.SignatureList = (function() {
// 
//         /**
//          * Properties of a SignatureList.
//          * @memberof proto
//          * @interface ISignatureList
//          * @property {Array.<proto.ISignature>|null} [sigs] SignatureList sigs
//          */
// 
//         /**
//          * Constructs a new SignatureList.
//          * @memberof proto
//          * @classdesc Represents a SignatureList.
//          * @implements ISignatureList
//          * @constructor
//          * @param {proto.ISignatureList=} [properties] Properties to set
//          */
//         function SignatureList(properties) {
//             this.sigs = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * SignatureList sigs.
//          * @member {Array.<proto.ISignature>} sigs
//          * @memberof proto.SignatureList
//          * @instance
//          */
//         SignatureList.prototype.sigs = $util.emptyArray;
// 
//         /**
//          * Creates a new SignatureList instance using the specified properties.
//          * @function create
//          * @memberof proto.SignatureList
//          * @static
//          * @param {proto.ISignatureList=} [properties] Properties to set
//          * @returns {proto.SignatureList} SignatureList instance
//          */
//         SignatureList.create = function create(properties) {
//             return new SignatureList(properties);
//         };
// 
//         /**
//          * Encodes the specified SignatureList message. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
//          * @function encode
//          * @memberof proto.SignatureList
//          * @static
//          * @param {proto.ISignatureList} message SignatureList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SignatureList.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.sigs != null && message.sigs.length)
//                 for (let i = 0; i < message.sigs.length; ++i)
//                     $root.proto.Signature.encode(message.sigs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified SignatureList message, length delimited. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.SignatureList
//          * @static
//          * @param {proto.ISignatureList} message SignatureList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SignatureList.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a SignatureList message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.SignatureList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.SignatureList} SignatureList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SignatureList.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignatureList();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 2:
//                     if (!(message.sigs && message.sigs.length))
//                         message.sigs = [];
//                     message.sigs.push($root.proto.Signature.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a SignatureList message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.SignatureList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.SignatureList} SignatureList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SignatureList.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a SignatureList message.
//          * @function verify
//          * @memberof proto.SignatureList
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         SignatureList.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.sigs != null && message.hasOwnProperty("sigs")) {
//                 if (!Array.isArray(message.sigs))
//                     return "sigs: array expected";
//                 for (let i = 0; i < message.sigs.length; ++i) {
//                     let error = $root.proto.Signature.verify(message.sigs[i]);
//                     if (error)
//                         return "sigs." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a SignatureList message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.SignatureList
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.SignatureList} SignatureList
//          */
//         SignatureList.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.SignatureList)
//                 return object;
//             let message = new $root.proto.SignatureList();
//             if (object.sigs) {
//                 if (!Array.isArray(object.sigs))
//                     throw TypeError(".proto.SignatureList.sigs: array expected");
//                 message.sigs = [];
//                 for (let i = 0; i < object.sigs.length; ++i) {
//                     if (typeof object.sigs[i] !== "object")
//                         throw TypeError(".proto.SignatureList.sigs: object expected");
//                     message.sigs[i] = $root.proto.Signature.fromObject(object.sigs[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a SignatureList message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.SignatureList
//          * @static
//          * @param {proto.SignatureList} message SignatureList
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         SignatureList.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.sigs = [];
//             if (message.sigs && message.sigs.length) {
//                 object.sigs = [];
//                 for (let j = 0; j < message.sigs.length; ++j)
//                     object.sigs[j] = $root.proto.Signature.toObject(message.sigs[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this SignatureList to JSON.
//          * @function toJSON
//          * @memberof proto.SignatureList
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         SignatureList.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return SignatureList;
//     })();
// 
//     proto.SignaturePair = (function() {
// 
//         /**
//          * Properties of a SignaturePair.
//          * @memberof proto
//          * @interface ISignaturePair
//          * @property {Uint8Array|null} [pubKeyPrefix] SignaturePair pubKeyPrefix
//          * @property {Uint8Array|null} [contract] SignaturePair contract
//          * @property {Uint8Array|null} [ed25519] SignaturePair ed25519
//          * @property {Uint8Array|null} [RSA_3072] SignaturePair RSA_3072
//          * @property {Uint8Array|null} [ECDSA_384] SignaturePair ECDSA_384
//          */
// 
//         /**
//          * Constructs a new SignaturePair.
//          * @memberof proto
//          * @classdesc Represents a SignaturePair.
//          * @implements ISignaturePair
//          * @constructor
//          * @param {proto.ISignaturePair=} [properties] Properties to set
//          */
//         function SignaturePair(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * SignaturePair pubKeyPrefix.
//          * @member {Uint8Array} pubKeyPrefix
//          * @memberof proto.SignaturePair
//          * @instance
//          */
//         SignaturePair.prototype.pubKeyPrefix = $util.newBuffer([]);
// 
//         /**
//          * SignaturePair contract.
//          * @member {Uint8Array} contract
//          * @memberof proto.SignaturePair
//          * @instance
//          */
//         SignaturePair.prototype.contract = $util.newBuffer([]);
// 
//         /**
//          * SignaturePair ed25519.
//          * @member {Uint8Array} ed25519
//          * @memberof proto.SignaturePair
//          * @instance
//          */
//         SignaturePair.prototype.ed25519 = $util.newBuffer([]);
// 
//         /**
//          * SignaturePair RSA_3072.
//          * @member {Uint8Array} RSA_3072
//          * @memberof proto.SignaturePair
//          * @instance
//          */
//         SignaturePair.prototype.RSA_3072 = $util.newBuffer([]);
// 
//         /**
//          * SignaturePair ECDSA_384.
//          * @member {Uint8Array} ECDSA_384
//          * @memberof proto.SignaturePair
//          * @instance
//          */
//         SignaturePair.prototype.ECDSA_384 = $util.newBuffer([]);
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * SignaturePair signature.
//          * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|undefined} signature
//          * @memberof proto.SignaturePair
//          * @instance
//          */
//         Object.defineProperty(SignaturePair.prototype, "signature", {
//             get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new SignaturePair instance using the specified properties.
//          * @function create
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {proto.ISignaturePair=} [properties] Properties to set
//          * @returns {proto.SignaturePair} SignaturePair instance
//          */
//         SignaturePair.create = function create(properties) {
//             return new SignaturePair(properties);
//         };
// 
//         /**
//          * Encodes the specified SignaturePair message. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
//          * @function encode
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {proto.ISignaturePair} message SignaturePair message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SignaturePair.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.pubKeyPrefix != null && Object.hasOwnProperty.call(message, "pubKeyPrefix"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pubKeyPrefix);
//             if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contract);
//             if (message.ed25519 != null && Object.hasOwnProperty.call(message, "ed25519"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ed25519);
//             if (message.RSA_3072 != null && Object.hasOwnProperty.call(message, "RSA_3072"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.RSA_3072);
//             if (message.ECDSA_384 != null && Object.hasOwnProperty.call(message, "ECDSA_384"))
//                 writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.ECDSA_384);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified SignaturePair message, length delimited. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {proto.ISignaturePair} message SignaturePair message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SignaturePair.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a SignaturePair message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.SignaturePair} SignaturePair
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SignaturePair.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignaturePair();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.pubKeyPrefix = reader.bytes();
//                     break;
//                 case 2:
//                     message.contract = reader.bytes();
//                     break;
//                 case 3:
//                     message.ed25519 = reader.bytes();
//                     break;
//                 case 4:
//                     message.RSA_3072 = reader.bytes();
//                     break;
//                 case 5:
//                     message.ECDSA_384 = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a SignaturePair message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.SignaturePair} SignaturePair
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SignaturePair.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a SignaturePair message.
//          * @function verify
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         SignaturePair.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.pubKeyPrefix != null && message.hasOwnProperty("pubKeyPrefix"))
//                 if (!(message.pubKeyPrefix && typeof message.pubKeyPrefix.length === "number" || $util.isString(message.pubKeyPrefix)))
//                     return "pubKeyPrefix: buffer expected";
//             if (message.contract != null && message.hasOwnProperty("contract")) {
//                 properties.signature = 1;
//                 if (!(message.contract && typeof message.contract.length === "number" || $util.isString(message.contract)))
//                     return "contract: buffer expected";
//             }
//             if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
//                     return "ed25519: buffer expected";
//             }
//             if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 if (!(message.RSA_3072 && typeof message.RSA_3072.length === "number" || $util.isString(message.RSA_3072)))
//                     return "RSA_3072: buffer expected";
//             }
//             if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
//                 if (properties.signature === 1)
//                     return "signature: multiple values";
//                 properties.signature = 1;
//                 if (!(message.ECDSA_384 && typeof message.ECDSA_384.length === "number" || $util.isString(message.ECDSA_384)))
//                     return "ECDSA_384: buffer expected";
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a SignaturePair message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.SignaturePair} SignaturePair
//          */
//         SignaturePair.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.SignaturePair)
//                 return object;
//             let message = new $root.proto.SignaturePair();
//             if (object.pubKeyPrefix != null)
//                 if (typeof object.pubKeyPrefix === "string")
//                     $util.base64.decode(object.pubKeyPrefix, message.pubKeyPrefix = $util.newBuffer($util.base64.length(object.pubKeyPrefix)), 0);
//                 else if (object.pubKeyPrefix.length)
//                     message.pubKeyPrefix = object.pubKeyPrefix;
//             if (object.contract != null)
//                 if (typeof object.contract === "string")
//                     $util.base64.decode(object.contract, message.contract = $util.newBuffer($util.base64.length(object.contract)), 0);
//                 else if (object.contract.length)
//                     message.contract = object.contract;
//             if (object.ed25519 != null)
//                 if (typeof object.ed25519 === "string")
//                     $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
//                 else if (object.ed25519.length)
//                     message.ed25519 = object.ed25519;
//             if (object.RSA_3072 != null)
//                 if (typeof object.RSA_3072 === "string")
//                     $util.base64.decode(object.RSA_3072, message.RSA_3072 = $util.newBuffer($util.base64.length(object.RSA_3072)), 0);
//                 else if (object.RSA_3072.length)
//                     message.RSA_3072 = object.RSA_3072;
//             if (object.ECDSA_384 != null)
//                 if (typeof object.ECDSA_384 === "string")
//                     $util.base64.decode(object.ECDSA_384, message.ECDSA_384 = $util.newBuffer($util.base64.length(object.ECDSA_384)), 0);
//                 else if (object.ECDSA_384.length)
//                     message.ECDSA_384 = object.ECDSA_384;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a SignaturePair message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.SignaturePair
//          * @static
//          * @param {proto.SignaturePair} message SignaturePair
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         SignaturePair.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 if (options.bytes === String)
//                     object.pubKeyPrefix = "";
//                 else {
//                     object.pubKeyPrefix = [];
//                     if (options.bytes !== Array)
//                         object.pubKeyPrefix = $util.newBuffer(object.pubKeyPrefix);
//                 }
//             if (message.pubKeyPrefix != null && message.hasOwnProperty("pubKeyPrefix"))
//                 object.pubKeyPrefix = options.bytes === String ? $util.base64.encode(message.pubKeyPrefix, 0, message.pubKeyPrefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKeyPrefix) : message.pubKeyPrefix;
//             if (message.contract != null && message.hasOwnProperty("contract")) {
//                 object.contract = options.bytes === String ? $util.base64.encode(message.contract, 0, message.contract.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract) : message.contract;
//                 if (options.oneofs)
//                     object.signature = "contract";
//             }
//             if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
//                 object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
//                 if (options.oneofs)
//                     object.signature = "ed25519";
//             }
//             if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
//                 object.RSA_3072 = options.bytes === String ? $util.base64.encode(message.RSA_3072, 0, message.RSA_3072.length) : options.bytes === Array ? Array.prototype.slice.call(message.RSA_3072) : message.RSA_3072;
//                 if (options.oneofs)
//                     object.signature = "RSA_3072";
//             }
//             if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
//                 object.ECDSA_384 = options.bytes === String ? $util.base64.encode(message.ECDSA_384, 0, message.ECDSA_384.length) : options.bytes === Array ? Array.prototype.slice.call(message.ECDSA_384) : message.ECDSA_384;
//                 if (options.oneofs)
//                     object.signature = "ECDSA_384";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this SignaturePair to JSON.
//          * @function toJSON
//          * @memberof proto.SignaturePair
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         SignaturePair.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return SignaturePair;
//     })();
// 
//     proto.SignatureMap = (function() {
// 
//         /**
//          * Properties of a SignatureMap.
//          * @memberof proto
//          * @interface ISignatureMap
//          * @property {Array.<proto.ISignaturePair>|null} [sigPair] SignatureMap sigPair
//          */
// 
//         /**
//          * Constructs a new SignatureMap.
//          * @memberof proto
//          * @classdesc Represents a SignatureMap.
//          * @implements ISignatureMap
//          * @constructor
//          * @param {proto.ISignatureMap=} [properties] Properties to set
//          */
//         function SignatureMap(properties) {
//             this.sigPair = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * SignatureMap sigPair.
//          * @member {Array.<proto.ISignaturePair>} sigPair
//          * @memberof proto.SignatureMap
//          * @instance
//          */
//         SignatureMap.prototype.sigPair = $util.emptyArray;
// 
//         /**
//          * Creates a new SignatureMap instance using the specified properties.
//          * @function create
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {proto.ISignatureMap=} [properties] Properties to set
//          * @returns {proto.SignatureMap} SignatureMap instance
//          */
//         SignatureMap.create = function create(properties) {
//             return new SignatureMap(properties);
//         };
// 
//         /**
//          * Encodes the specified SignatureMap message. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
//          * @function encode
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {proto.ISignatureMap} message SignatureMap message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SignatureMap.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.sigPair != null && message.sigPair.length)
//                 for (let i = 0; i < message.sigPair.length; ++i)
//                     $root.proto.SignaturePair.encode(message.sigPair[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified SignatureMap message, length delimited. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {proto.ISignatureMap} message SignatureMap message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SignatureMap.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a SignatureMap message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.SignatureMap} SignatureMap
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SignatureMap.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignatureMap();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     if (!(message.sigPair && message.sigPair.length))
//                         message.sigPair = [];
//                     message.sigPair.push($root.proto.SignaturePair.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a SignatureMap message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.SignatureMap} SignatureMap
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SignatureMap.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a SignatureMap message.
//          * @function verify
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         SignatureMap.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.sigPair != null && message.hasOwnProperty("sigPair")) {
//                 if (!Array.isArray(message.sigPair))
//                     return "sigPair: array expected";
//                 for (let i = 0; i < message.sigPair.length; ++i) {
//                     let error = $root.proto.SignaturePair.verify(message.sigPair[i]);
//                     if (error)
//                         return "sigPair." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a SignatureMap message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.SignatureMap} SignatureMap
//          */
//         SignatureMap.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.SignatureMap)
//                 return object;
//             let message = new $root.proto.SignatureMap();
//             if (object.sigPair) {
//                 if (!Array.isArray(object.sigPair))
//                     throw TypeError(".proto.SignatureMap.sigPair: array expected");
//                 message.sigPair = [];
//                 for (let i = 0; i < object.sigPair.length; ++i) {
//                     if (typeof object.sigPair[i] !== "object")
//                         throw TypeError(".proto.SignatureMap.sigPair: object expected");
//                     message.sigPair[i] = $root.proto.SignaturePair.fromObject(object.sigPair[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a SignatureMap message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.SignatureMap
//          * @static
//          * @param {proto.SignatureMap} message SignatureMap
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         SignatureMap.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.sigPair = [];
//             if (message.sigPair && message.sigPair.length) {
//                 object.sigPair = [];
//                 for (let j = 0; j < message.sigPair.length; ++j)
//                     object.sigPair[j] = $root.proto.SignaturePair.toObject(message.sigPair[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this SignatureMap to JSON.
//          * @function toJSON
//          * @memberof proto.SignatureMap
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         SignatureMap.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return SignatureMap;
//     })();
// 
//     /**
//      * HederaFunctionality enum.
//      * @name proto.HederaFunctionality
//      * @enum {number}
//      * @property {number} NONE=0 NONE value
//      * @property {number} CryptoTransfer=1 CryptoTransfer value
//      * @property {number} CryptoUpdate=2 CryptoUpdate value
//      * @property {number} CryptoDelete=3 CryptoDelete value
//      * @property {number} CryptoAddLiveHash=4 CryptoAddLiveHash value
//      * @property {number} CryptoDeleteLiveHash=5 CryptoDeleteLiveHash value
//      * @property {number} ContractCall=6 ContractCall value
//      * @property {number} ContractCreate=7 ContractCreate value
//      * @property {number} ContractUpdate=8 ContractUpdate value
//      * @property {number} FileCreate=9 FileCreate value
//      * @property {number} FileAppend=10 FileAppend value
//      * @property {number} FileUpdate=11 FileUpdate value
//      * @property {number} FileDelete=12 FileDelete value
//      * @property {number} CryptoGetAccountBalance=13 CryptoGetAccountBalance value
//      * @property {number} CryptoGetAccountRecords=14 CryptoGetAccountRecords value
//      * @property {number} CryptoGetInfo=15 CryptoGetInfo value
//      * @property {number} ContractCallLocal=16 ContractCallLocal value
//      * @property {number} ContractGetInfo=17 ContractGetInfo value
//      * @property {number} ContractGetBytecode=18 ContractGetBytecode value
//      * @property {number} GetBySolidityID=19 GetBySolidityID value
//      * @property {number} GetByKey=20 GetByKey value
//      * @property {number} CryptoGetLiveHash=21 CryptoGetLiveHash value
//      * @property {number} CryptoGetStakers=22 CryptoGetStakers value
//      * @property {number} FileGetContents=23 FileGetContents value
//      * @property {number} FileGetInfo=24 FileGetInfo value
//      * @property {number} TransactionGetRecord=25 TransactionGetRecord value
//      * @property {number} ContractGetRecords=26 ContractGetRecords value
//      * @property {number} CryptoCreate=27 CryptoCreate value
//      * @property {number} SystemDelete=28 SystemDelete value
//      * @property {number} SystemUndelete=29 SystemUndelete value
//      * @property {number} ContractDelete=30 ContractDelete value
//      * @property {number} Freeze=31 Freeze value
//      * @property {number} CreateTransactionRecord=32 CreateTransactionRecord value
//      * @property {number} CryptoAccountAutoRenew=33 CryptoAccountAutoRenew value
//      * @property {number} ContractAutoRenew=34 ContractAutoRenew value
//      * @property {number} GetVersionInfo=35 GetVersionInfo value
//      * @property {number} TransactionGetReceipt=36 TransactionGetReceipt value
//      * @property {number} ConsensusCreateTopic=50 ConsensusCreateTopic value
//      * @property {number} ConsensusUpdateTopic=51 ConsensusUpdateTopic value
//      * @property {number} ConsensusDeleteTopic=52 ConsensusDeleteTopic value
//      * @property {number} ConsensusGetTopicInfo=53 ConsensusGetTopicInfo value
//      * @property {number} ConsensusSubmitMessage=54 ConsensusSubmitMessage value
//      */
//     proto.HederaFunctionality = (function() {
//         const valuesById = {}, values = Object.create(valuesById);
//         values[valuesById[0] = "NONE"] = 0;
//         values[valuesById[1] = "CryptoTransfer"] = 1;
//         values[valuesById[2] = "CryptoUpdate"] = 2;
//         values[valuesById[3] = "CryptoDelete"] = 3;
//         values[valuesById[4] = "CryptoAddLiveHash"] = 4;
//         values[valuesById[5] = "CryptoDeleteLiveHash"] = 5;
//         values[valuesById[6] = "ContractCall"] = 6;
//         values[valuesById[7] = "ContractCreate"] = 7;
//         values[valuesById[8] = "ContractUpdate"] = 8;
//         values[valuesById[9] = "FileCreate"] = 9;
//         values[valuesById[10] = "FileAppend"] = 10;
//         values[valuesById[11] = "FileUpdate"] = 11;
//         values[valuesById[12] = "FileDelete"] = 12;
//         values[valuesById[13] = "CryptoGetAccountBalance"] = 13;
//         values[valuesById[14] = "CryptoGetAccountRecords"] = 14;
//         values[valuesById[15] = "CryptoGetInfo"] = 15;
//         values[valuesById[16] = "ContractCallLocal"] = 16;
//         values[valuesById[17] = "ContractGetInfo"] = 17;
//         values[valuesById[18] = "ContractGetBytecode"] = 18;
//         values[valuesById[19] = "GetBySolidityID"] = 19;
//         values[valuesById[20] = "GetByKey"] = 20;
//         values[valuesById[21] = "CryptoGetLiveHash"] = 21;
//         values[valuesById[22] = "CryptoGetStakers"] = 22;
//         values[valuesById[23] = "FileGetContents"] = 23;
//         values[valuesById[24] = "FileGetInfo"] = 24;
//         values[valuesById[25] = "TransactionGetRecord"] = 25;
//         values[valuesById[26] = "ContractGetRecords"] = 26;
//         values[valuesById[27] = "CryptoCreate"] = 27;
//         values[valuesById[28] = "SystemDelete"] = 28;
//         values[valuesById[29] = "SystemUndelete"] = 29;
//         values[valuesById[30] = "ContractDelete"] = 30;
//         values[valuesById[31] = "Freeze"] = 31;
//         values[valuesById[32] = "CreateTransactionRecord"] = 32;
//         values[valuesById[33] = "CryptoAccountAutoRenew"] = 33;
//         values[valuesById[34] = "ContractAutoRenew"] = 34;
//         values[valuesById[35] = "GetVersionInfo"] = 35;
//         values[valuesById[36] = "TransactionGetReceipt"] = 36;
//         values[valuesById[50] = "ConsensusCreateTopic"] = 50;
//         values[valuesById[51] = "ConsensusUpdateTopic"] = 51;
//         values[valuesById[52] = "ConsensusDeleteTopic"] = 52;
//         values[valuesById[53] = "ConsensusGetTopicInfo"] = 53;
//         values[valuesById[54] = "ConsensusSubmitMessage"] = 54;
//         return values;
//     })();
// 
//     proto.FeeComponents = (function() {
// 
//         /**
//          * Properties of a FeeComponents.
//          * @memberof proto
//          * @interface IFeeComponents
//          * @property {number|Long|null} [min] FeeComponents min
//          * @property {number|Long|null} [max] FeeComponents max
//          * @property {number|Long|null} [constant] FeeComponents constant
//          * @property {number|Long|null} [bpt] FeeComponents bpt
//          * @property {number|Long|null} [vpt] FeeComponents vpt
//          * @property {number|Long|null} [rbh] FeeComponents rbh
//          * @property {number|Long|null} [sbh] FeeComponents sbh
//          * @property {number|Long|null} [gas] FeeComponents gas
//          * @property {number|Long|null} [tv] FeeComponents tv
//          * @property {number|Long|null} [bpr] FeeComponents bpr
//          * @property {number|Long|null} [sbpr] FeeComponents sbpr
//          */
// 
//         /**
//          * Constructs a new FeeComponents.
//          * @memberof proto
//          * @classdesc Represents a FeeComponents.
//          * @implements IFeeComponents
//          * @constructor
//          * @param {proto.IFeeComponents=} [properties] Properties to set
//          */
//         function FeeComponents(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FeeComponents min.
//          * @member {number|Long} min
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.min = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents max.
//          * @member {number|Long} max
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.max = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents constant.
//          * @member {number|Long} constant
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.constant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents bpt.
//          * @member {number|Long} bpt
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.bpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents vpt.
//          * @member {number|Long} vpt
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.vpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents rbh.
//          * @member {number|Long} rbh
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.rbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents sbh.
//          * @member {number|Long} sbh
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.sbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents gas.
//          * @member {number|Long} gas
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents tv.
//          * @member {number|Long} tv
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.tv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents bpr.
//          * @member {number|Long} bpr
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.bpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * FeeComponents sbpr.
//          * @member {number|Long} sbpr
//          * @memberof proto.FeeComponents
//          * @instance
//          */
//         FeeComponents.prototype.sbpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new FeeComponents instance using the specified properties.
//          * @function create
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {proto.IFeeComponents=} [properties] Properties to set
//          * @returns {proto.FeeComponents} FeeComponents instance
//          */
//         FeeComponents.create = function create(properties) {
//             return new FeeComponents(properties);
//         };
// 
//         /**
//          * Encodes the specified FeeComponents message. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {proto.IFeeComponents} message FeeComponents message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FeeComponents.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.min != null && Object.hasOwnProperty.call(message, "min"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.min);
//             if (message.max != null && Object.hasOwnProperty.call(message, "max"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.max);
//             if (message.constant != null && Object.hasOwnProperty.call(message, "constant"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int64(message.constant);
//             if (message.bpt != null && Object.hasOwnProperty.call(message, "bpt"))
//                 writer.uint32(/* id 4, wireType 0 =*/32).int64(message.bpt);
//             if (message.vpt != null && Object.hasOwnProperty.call(message, "vpt"))
//                 writer.uint32(/* id 5, wireType 0 =*/40).int64(message.vpt);
//             if (message.rbh != null && Object.hasOwnProperty.call(message, "rbh"))
//                 writer.uint32(/* id 6, wireType 0 =*/48).int64(message.rbh);
//             if (message.sbh != null && Object.hasOwnProperty.call(message, "sbh"))
//                 writer.uint32(/* id 7, wireType 0 =*/56).int64(message.sbh);
//             if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
//                 writer.uint32(/* id 8, wireType 0 =*/64).int64(message.gas);
//             if (message.tv != null && Object.hasOwnProperty.call(message, "tv"))
//                 writer.uint32(/* id 9, wireType 0 =*/72).int64(message.tv);
//             if (message.bpr != null && Object.hasOwnProperty.call(message, "bpr"))
//                 writer.uint32(/* id 10, wireType 0 =*/80).int64(message.bpr);
//             if (message.sbpr != null && Object.hasOwnProperty.call(message, "sbpr"))
//                 writer.uint32(/* id 11, wireType 0 =*/88).int64(message.sbpr);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FeeComponents message, length delimited. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {proto.IFeeComponents} message FeeComponents message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FeeComponents.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FeeComponents message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FeeComponents} FeeComponents
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FeeComponents.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FeeComponents();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.min = reader.int64();
//                     break;
//                 case 2:
//                     message.max = reader.int64();
//                     break;
//                 case 3:
//                     message.constant = reader.int64();
//                     break;
//                 case 4:
//                     message.bpt = reader.int64();
//                     break;
//                 case 5:
//                     message.vpt = reader.int64();
//                     break;
//                 case 6:
//                     message.rbh = reader.int64();
//                     break;
//                 case 7:
//                     message.sbh = reader.int64();
//                     break;
//                 case 8:
//                     message.gas = reader.int64();
//                     break;
//                 case 9:
//                     message.tv = reader.int64();
//                     break;
//                 case 10:
//                     message.bpr = reader.int64();
//                     break;
//                 case 11:
//                     message.sbpr = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FeeComponents message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FeeComponents} FeeComponents
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FeeComponents.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FeeComponents message.
//          * @function verify
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FeeComponents.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.min != null && message.hasOwnProperty("min"))
//                 if (!$util.isInteger(message.min) && !(message.min && $util.isInteger(message.min.low) && $util.isInteger(message.min.high)))
//                     return "min: integer|Long expected";
//             if (message.max != null && message.hasOwnProperty("max"))
//                 if (!$util.isInteger(message.max) && !(message.max && $util.isInteger(message.max.low) && $util.isInteger(message.max.high)))
//                     return "max: integer|Long expected";
//             if (message.constant != null && message.hasOwnProperty("constant"))
//                 if (!$util.isInteger(message.constant) && !(message.constant && $util.isInteger(message.constant.low) && $util.isInteger(message.constant.high)))
//                     return "constant: integer|Long expected";
//             if (message.bpt != null && message.hasOwnProperty("bpt"))
//                 if (!$util.isInteger(message.bpt) && !(message.bpt && $util.isInteger(message.bpt.low) && $util.isInteger(message.bpt.high)))
//                     return "bpt: integer|Long expected";
//             if (message.vpt != null && message.hasOwnProperty("vpt"))
//                 if (!$util.isInteger(message.vpt) && !(message.vpt && $util.isInteger(message.vpt.low) && $util.isInteger(message.vpt.high)))
//                     return "vpt: integer|Long expected";
//             if (message.rbh != null && message.hasOwnProperty("rbh"))
//                 if (!$util.isInteger(message.rbh) && !(message.rbh && $util.isInteger(message.rbh.low) && $util.isInteger(message.rbh.high)))
//                     return "rbh: integer|Long expected";
//             if (message.sbh != null && message.hasOwnProperty("sbh"))
//                 if (!$util.isInteger(message.sbh) && !(message.sbh && $util.isInteger(message.sbh.low) && $util.isInteger(message.sbh.high)))
//                     return "sbh: integer|Long expected";
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
//                     return "gas: integer|Long expected";
//             if (message.tv != null && message.hasOwnProperty("tv"))
//                 if (!$util.isInteger(message.tv) && !(message.tv && $util.isInteger(message.tv.low) && $util.isInteger(message.tv.high)))
//                     return "tv: integer|Long expected";
//             if (message.bpr != null && message.hasOwnProperty("bpr"))
//                 if (!$util.isInteger(message.bpr) && !(message.bpr && $util.isInteger(message.bpr.low) && $util.isInteger(message.bpr.high)))
//                     return "bpr: integer|Long expected";
//             if (message.sbpr != null && message.hasOwnProperty("sbpr"))
//                 if (!$util.isInteger(message.sbpr) && !(message.sbpr && $util.isInteger(message.sbpr.low) && $util.isInteger(message.sbpr.high)))
//                     return "sbpr: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a FeeComponents message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FeeComponents} FeeComponents
//          */
//         FeeComponents.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FeeComponents)
//                 return object;
//             let message = new $root.proto.FeeComponents();
//             if (object.min != null)
//                 if ($util.Long)
//                     (message.min = $util.Long.fromValue(object.min)).unsigned = false;
//                 else if (typeof object.min === "string")
//                     message.min = parseInt(object.min, 10);
//                 else if (typeof object.min === "number")
//                     message.min = object.min;
//                 else if (typeof object.min === "object")
//                     message.min = new $util.LongBits(object.min.low >>> 0, object.min.high >>> 0).toNumber();
//             if (object.max != null)
//                 if ($util.Long)
//                     (message.max = $util.Long.fromValue(object.max)).unsigned = false;
//                 else if (typeof object.max === "string")
//                     message.max = parseInt(object.max, 10);
//                 else if (typeof object.max === "number")
//                     message.max = object.max;
//                 else if (typeof object.max === "object")
//                     message.max = new $util.LongBits(object.max.low >>> 0, object.max.high >>> 0).toNumber();
//             if (object.constant != null)
//                 if ($util.Long)
//                     (message.constant = $util.Long.fromValue(object.constant)).unsigned = false;
//                 else if (typeof object.constant === "string")
//                     message.constant = parseInt(object.constant, 10);
//                 else if (typeof object.constant === "number")
//                     message.constant = object.constant;
//                 else if (typeof object.constant === "object")
//                     message.constant = new $util.LongBits(object.constant.low >>> 0, object.constant.high >>> 0).toNumber();
//             if (object.bpt != null)
//                 if ($util.Long)
//                     (message.bpt = $util.Long.fromValue(object.bpt)).unsigned = false;
//                 else if (typeof object.bpt === "string")
//                     message.bpt = parseInt(object.bpt, 10);
//                 else if (typeof object.bpt === "number")
//                     message.bpt = object.bpt;
//                 else if (typeof object.bpt === "object")
//                     message.bpt = new $util.LongBits(object.bpt.low >>> 0, object.bpt.high >>> 0).toNumber();
//             if (object.vpt != null)
//                 if ($util.Long)
//                     (message.vpt = $util.Long.fromValue(object.vpt)).unsigned = false;
//                 else if (typeof object.vpt === "string")
//                     message.vpt = parseInt(object.vpt, 10);
//                 else if (typeof object.vpt === "number")
//                     message.vpt = object.vpt;
//                 else if (typeof object.vpt === "object")
//                     message.vpt = new $util.LongBits(object.vpt.low >>> 0, object.vpt.high >>> 0).toNumber();
//             if (object.rbh != null)
//                 if ($util.Long)
//                     (message.rbh = $util.Long.fromValue(object.rbh)).unsigned = false;
//                 else if (typeof object.rbh === "string")
//                     message.rbh = parseInt(object.rbh, 10);
//                 else if (typeof object.rbh === "number")
//                     message.rbh = object.rbh;
//                 else if (typeof object.rbh === "object")
//                     message.rbh = new $util.LongBits(object.rbh.low >>> 0, object.rbh.high >>> 0).toNumber();
//             if (object.sbh != null)
//                 if ($util.Long)
//                     (message.sbh = $util.Long.fromValue(object.sbh)).unsigned = false;
//                 else if (typeof object.sbh === "string")
//                     message.sbh = parseInt(object.sbh, 10);
//                 else if (typeof object.sbh === "number")
//                     message.sbh = object.sbh;
//                 else if (typeof object.sbh === "object")
//                     message.sbh = new $util.LongBits(object.sbh.low >>> 0, object.sbh.high >>> 0).toNumber();
//             if (object.gas != null)
//                 if ($util.Long)
//                     (message.gas = $util.Long.fromValue(object.gas)).unsigned = false;
//                 else if (typeof object.gas === "string")
//                     message.gas = parseInt(object.gas, 10);
//                 else if (typeof object.gas === "number")
//                     message.gas = object.gas;
//                 else if (typeof object.gas === "object")
//                     message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber();
//             if (object.tv != null)
//                 if ($util.Long)
//                     (message.tv = $util.Long.fromValue(object.tv)).unsigned = false;
//                 else if (typeof object.tv === "string")
//                     message.tv = parseInt(object.tv, 10);
//                 else if (typeof object.tv === "number")
//                     message.tv = object.tv;
//                 else if (typeof object.tv === "object")
//                     message.tv = new $util.LongBits(object.tv.low >>> 0, object.tv.high >>> 0).toNumber();
//             if (object.bpr != null)
//                 if ($util.Long)
//                     (message.bpr = $util.Long.fromValue(object.bpr)).unsigned = false;
//                 else if (typeof object.bpr === "string")
//                     message.bpr = parseInt(object.bpr, 10);
//                 else if (typeof object.bpr === "number")
//                     message.bpr = object.bpr;
//                 else if (typeof object.bpr === "object")
//                     message.bpr = new $util.LongBits(object.bpr.low >>> 0, object.bpr.high >>> 0).toNumber();
//             if (object.sbpr != null)
//                 if ($util.Long)
//                     (message.sbpr = $util.Long.fromValue(object.sbpr)).unsigned = false;
//                 else if (typeof object.sbpr === "string")
//                     message.sbpr = parseInt(object.sbpr, 10);
//                 else if (typeof object.sbpr === "number")
//                     message.sbpr = object.sbpr;
//                 else if (typeof object.sbpr === "object")
//                     message.sbpr = new $util.LongBits(object.sbpr.low >>> 0, object.sbpr.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FeeComponents message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FeeComponents
//          * @static
//          * @param {proto.FeeComponents} message FeeComponents
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FeeComponents.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.min = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.min = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.max = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.max = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.constant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.constant = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.bpt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.bpt = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.vpt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.vpt = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.rbh = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.rbh = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.sbh = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.sbh = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.gas = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.tv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.tv = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.bpr = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.bpr = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.sbpr = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.sbpr = options.longs === String ? "0" : 0;
//             }
//             if (message.min != null && message.hasOwnProperty("min"))
//                 if (typeof message.min === "number")
//                     object.min = options.longs === String ? String(message.min) : message.min;
//                 else
//                     object.min = options.longs === String ? $util.Long.prototype.toString.call(message.min) : options.longs === Number ? new $util.LongBits(message.min.low >>> 0, message.min.high >>> 0).toNumber() : message.min;
//             if (message.max != null && message.hasOwnProperty("max"))
//                 if (typeof message.max === "number")
//                     object.max = options.longs === String ? String(message.max) : message.max;
//                 else
//                     object.max = options.longs === String ? $util.Long.prototype.toString.call(message.max) : options.longs === Number ? new $util.LongBits(message.max.low >>> 0, message.max.high >>> 0).toNumber() : message.max;
//             if (message.constant != null && message.hasOwnProperty("constant"))
//                 if (typeof message.constant === "number")
//                     object.constant = options.longs === String ? String(message.constant) : message.constant;
//                 else
//                     object.constant = options.longs === String ? $util.Long.prototype.toString.call(message.constant) : options.longs === Number ? new $util.LongBits(message.constant.low >>> 0, message.constant.high >>> 0).toNumber() : message.constant;
//             if (message.bpt != null && message.hasOwnProperty("bpt"))
//                 if (typeof message.bpt === "number")
//                     object.bpt = options.longs === String ? String(message.bpt) : message.bpt;
//                 else
//                     object.bpt = options.longs === String ? $util.Long.prototype.toString.call(message.bpt) : options.longs === Number ? new $util.LongBits(message.bpt.low >>> 0, message.bpt.high >>> 0).toNumber() : message.bpt;
//             if (message.vpt != null && message.hasOwnProperty("vpt"))
//                 if (typeof message.vpt === "number")
//                     object.vpt = options.longs === String ? String(message.vpt) : message.vpt;
//                 else
//                     object.vpt = options.longs === String ? $util.Long.prototype.toString.call(message.vpt) : options.longs === Number ? new $util.LongBits(message.vpt.low >>> 0, message.vpt.high >>> 0).toNumber() : message.vpt;
//             if (message.rbh != null && message.hasOwnProperty("rbh"))
//                 if (typeof message.rbh === "number")
//                     object.rbh = options.longs === String ? String(message.rbh) : message.rbh;
//                 else
//                     object.rbh = options.longs === String ? $util.Long.prototype.toString.call(message.rbh) : options.longs === Number ? new $util.LongBits(message.rbh.low >>> 0, message.rbh.high >>> 0).toNumber() : message.rbh;
//             if (message.sbh != null && message.hasOwnProperty("sbh"))
//                 if (typeof message.sbh === "number")
//                     object.sbh = options.longs === String ? String(message.sbh) : message.sbh;
//                 else
//                     object.sbh = options.longs === String ? $util.Long.prototype.toString.call(message.sbh) : options.longs === Number ? new $util.LongBits(message.sbh.low >>> 0, message.sbh.high >>> 0).toNumber() : message.sbh;
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (typeof message.gas === "number")
//                     object.gas = options.longs === String ? String(message.gas) : message.gas;
//                 else
//                     object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber() : message.gas;
//             if (message.tv != null && message.hasOwnProperty("tv"))
//                 if (typeof message.tv === "number")
//                     object.tv = options.longs === String ? String(message.tv) : message.tv;
//                 else
//                     object.tv = options.longs === String ? $util.Long.prototype.toString.call(message.tv) : options.longs === Number ? new $util.LongBits(message.tv.low >>> 0, message.tv.high >>> 0).toNumber() : message.tv;
//             if (message.bpr != null && message.hasOwnProperty("bpr"))
//                 if (typeof message.bpr === "number")
//                     object.bpr = options.longs === String ? String(message.bpr) : message.bpr;
//                 else
//                     object.bpr = options.longs === String ? $util.Long.prototype.toString.call(message.bpr) : options.longs === Number ? new $util.LongBits(message.bpr.low >>> 0, message.bpr.high >>> 0).toNumber() : message.bpr;
//             if (message.sbpr != null && message.hasOwnProperty("sbpr"))
//                 if (typeof message.sbpr === "number")
//                     object.sbpr = options.longs === String ? String(message.sbpr) : message.sbpr;
//                 else
//                     object.sbpr = options.longs === String ? $util.Long.prototype.toString.call(message.sbpr) : options.longs === Number ? new $util.LongBits(message.sbpr.low >>> 0, message.sbpr.high >>> 0).toNumber() : message.sbpr;
//             return object;
//         };
// 
//         /**
//          * Converts this FeeComponents to JSON.
//          * @function toJSON
//          * @memberof proto.FeeComponents
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FeeComponents.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FeeComponents;
//     })();
// 
//     proto.TransactionFeeSchedule = (function() {
// 
//         /**
//          * Properties of a TransactionFeeSchedule.
//          * @memberof proto
//          * @interface ITransactionFeeSchedule
//          * @property {proto.HederaFunctionality|null} [hederaFunctionality] TransactionFeeSchedule hederaFunctionality
//          * @property {proto.IFeeData|null} [feeData] TransactionFeeSchedule feeData
//          */
// 
//         /**
//          * Constructs a new TransactionFeeSchedule.
//          * @memberof proto
//          * @classdesc Represents a TransactionFeeSchedule.
//          * @implements ITransactionFeeSchedule
//          * @constructor
//          * @param {proto.ITransactionFeeSchedule=} [properties] Properties to set
//          */
//         function TransactionFeeSchedule(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionFeeSchedule hederaFunctionality.
//          * @member {proto.HederaFunctionality} hederaFunctionality
//          * @memberof proto.TransactionFeeSchedule
//          * @instance
//          */
//         TransactionFeeSchedule.prototype.hederaFunctionality = 0;
// 
//         /**
//          * TransactionFeeSchedule feeData.
//          * @member {proto.IFeeData|null|undefined} feeData
//          * @memberof proto.TransactionFeeSchedule
//          * @instance
//          */
//         TransactionFeeSchedule.prototype.feeData = null;
// 
//         /**
//          * Creates a new TransactionFeeSchedule instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {proto.ITransactionFeeSchedule=} [properties] Properties to set
//          * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule instance
//          */
//         TransactionFeeSchedule.create = function create(properties) {
//             return new TransactionFeeSchedule(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {proto.ITransactionFeeSchedule} message TransactionFeeSchedule message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionFeeSchedule.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.hederaFunctionality != null && Object.hasOwnProperty.call(message, "hederaFunctionality"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hederaFunctionality);
//             if (message.feeData != null && Object.hasOwnProperty.call(message, "feeData"))
//                 $root.proto.FeeData.encode(message.feeData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionFeeSchedule message, length delimited. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {proto.ITransactionFeeSchedule} message TransactionFeeSchedule message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionFeeSchedule.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionFeeSchedule.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionFeeSchedule();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.hederaFunctionality = reader.int32();
//                     break;
//                 case 2:
//                     message.feeData = $root.proto.FeeData.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionFeeSchedule message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionFeeSchedule.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionFeeSchedule message.
//          * @function verify
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionFeeSchedule.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.hederaFunctionality != null && message.hasOwnProperty("hederaFunctionality"))
//                 switch (message.hederaFunctionality) {
//                 default:
//                     return "hederaFunctionality: enum value expected";
//                 case 0:
//                 case 1:
//                 case 2:
//                 case 3:
//                 case 4:
//                 case 5:
//                 case 6:
//                 case 7:
//                 case 8:
//                 case 9:
//                 case 10:
//                 case 11:
//                 case 12:
//                 case 13:
//                 case 14:
//                 case 15:
//                 case 16:
//                 case 17:
//                 case 18:
//                 case 19:
//                 case 20:
//                 case 21:
//                 case 22:
//                 case 23:
//                 case 24:
//                 case 25:
//                 case 26:
//                 case 27:
//                 case 28:
//                 case 29:
//                 case 30:
//                 case 31:
//                 case 32:
//                 case 33:
//                 case 34:
//                 case 35:
//                 case 36:
//                 case 50:
//                 case 51:
//                 case 52:
//                 case 53:
//                 case 54:
//                     break;
//                 }
//             if (message.feeData != null && message.hasOwnProperty("feeData")) {
//                 let error = $root.proto.FeeData.verify(message.feeData);
//                 if (error)
//                     return "feeData." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionFeeSchedule message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
//          */
//         TransactionFeeSchedule.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionFeeSchedule)
//                 return object;
//             let message = new $root.proto.TransactionFeeSchedule();
//             switch (object.hederaFunctionality) {
//             case "NONE":
//             case 0:
//                 message.hederaFunctionality = 0;
//                 break;
//             case "CryptoTransfer":
//             case 1:
//                 message.hederaFunctionality = 1;
//                 break;
//             case "CryptoUpdate":
//             case 2:
//                 message.hederaFunctionality = 2;
//                 break;
//             case "CryptoDelete":
//             case 3:
//                 message.hederaFunctionality = 3;
//                 break;
//             case "CryptoAddLiveHash":
//             case 4:
//                 message.hederaFunctionality = 4;
//                 break;
//             case "CryptoDeleteLiveHash":
//             case 5:
//                 message.hederaFunctionality = 5;
//                 break;
//             case "ContractCall":
//             case 6:
//                 message.hederaFunctionality = 6;
//                 break;
//             case "ContractCreate":
//             case 7:
//                 message.hederaFunctionality = 7;
//                 break;
//             case "ContractUpdate":
//             case 8:
//                 message.hederaFunctionality = 8;
//                 break;
//             case "FileCreate":
//             case 9:
//                 message.hederaFunctionality = 9;
//                 break;
//             case "FileAppend":
//             case 10:
//                 message.hederaFunctionality = 10;
//                 break;
//             case "FileUpdate":
//             case 11:
//                 message.hederaFunctionality = 11;
//                 break;
//             case "FileDelete":
//             case 12:
//                 message.hederaFunctionality = 12;
//                 break;
//             case "CryptoGetAccountBalance":
//             case 13:
//                 message.hederaFunctionality = 13;
//                 break;
//             case "CryptoGetAccountRecords":
//             case 14:
//                 message.hederaFunctionality = 14;
//                 break;
//             case "CryptoGetInfo":
//             case 15:
//                 message.hederaFunctionality = 15;
//                 break;
//             case "ContractCallLocal":
//             case 16:
//                 message.hederaFunctionality = 16;
//                 break;
//             case "ContractGetInfo":
//             case 17:
//                 message.hederaFunctionality = 17;
//                 break;
//             case "ContractGetBytecode":
//             case 18:
//                 message.hederaFunctionality = 18;
//                 break;
//             case "GetBySolidityID":
//             case 19:
//                 message.hederaFunctionality = 19;
//                 break;
//             case "GetByKey":
//             case 20:
//                 message.hederaFunctionality = 20;
//                 break;
//             case "CryptoGetLiveHash":
//             case 21:
//                 message.hederaFunctionality = 21;
//                 break;
//             case "CryptoGetStakers":
//             case 22:
//                 message.hederaFunctionality = 22;
//                 break;
//             case "FileGetContents":
//             case 23:
//                 message.hederaFunctionality = 23;
//                 break;
//             case "FileGetInfo":
//             case 24:
//                 message.hederaFunctionality = 24;
//                 break;
//             case "TransactionGetRecord":
//             case 25:
//                 message.hederaFunctionality = 25;
//                 break;
//             case "ContractGetRecords":
//             case 26:
//                 message.hederaFunctionality = 26;
//                 break;
//             case "CryptoCreate":
//             case 27:
//                 message.hederaFunctionality = 27;
//                 break;
//             case "SystemDelete":
//             case 28:
//                 message.hederaFunctionality = 28;
//                 break;
//             case "SystemUndelete":
//             case 29:
//                 message.hederaFunctionality = 29;
//                 break;
//             case "ContractDelete":
//             case 30:
//                 message.hederaFunctionality = 30;
//                 break;
//             case "Freeze":
//             case 31:
//                 message.hederaFunctionality = 31;
//                 break;
//             case "CreateTransactionRecord":
//             case 32:
//                 message.hederaFunctionality = 32;
//                 break;
//             case "CryptoAccountAutoRenew":
//             case 33:
//                 message.hederaFunctionality = 33;
//                 break;
//             case "ContractAutoRenew":
//             case 34:
//                 message.hederaFunctionality = 34;
//                 break;
//             case "GetVersionInfo":
//             case 35:
//                 message.hederaFunctionality = 35;
//                 break;
//             case "TransactionGetReceipt":
//             case 36:
//                 message.hederaFunctionality = 36;
//                 break;
//             case "ConsensusCreateTopic":
//             case 50:
//                 message.hederaFunctionality = 50;
//                 break;
//             case "ConsensusUpdateTopic":
//             case 51:
//                 message.hederaFunctionality = 51;
//                 break;
//             case "ConsensusDeleteTopic":
//             case 52:
//                 message.hederaFunctionality = 52;
//                 break;
//             case "ConsensusGetTopicInfo":
//             case 53:
//                 message.hederaFunctionality = 53;
//                 break;
//             case "ConsensusSubmitMessage":
//             case 54:
//                 message.hederaFunctionality = 54;
//                 break;
//             }
//             if (object.feeData != null) {
//                 if (typeof object.feeData !== "object")
//                     throw TypeError(".proto.TransactionFeeSchedule.feeData: object expected");
//                 message.feeData = $root.proto.FeeData.fromObject(object.feeData);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionFeeSchedule message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionFeeSchedule
//          * @static
//          * @param {proto.TransactionFeeSchedule} message TransactionFeeSchedule
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionFeeSchedule.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.hederaFunctionality = options.enums === String ? "NONE" : 0;
//                 object.feeData = null;
//             }
//             if (message.hederaFunctionality != null && message.hasOwnProperty("hederaFunctionality"))
//                 object.hederaFunctionality = options.enums === String ? $root.proto.HederaFunctionality[message.hederaFunctionality] : message.hederaFunctionality;
//             if (message.feeData != null && message.hasOwnProperty("feeData"))
//                 object.feeData = $root.proto.FeeData.toObject(message.feeData, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionFeeSchedule to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionFeeSchedule
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionFeeSchedule.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionFeeSchedule;
//     })();
// 
//     proto.FeeData = (function() {
// 
//         /**
//          * Properties of a FeeData.
//          * @memberof proto
//          * @interface IFeeData
//          * @property {proto.IFeeComponents|null} [nodedata] FeeData nodedata
//          * @property {proto.IFeeComponents|null} [networkdata] FeeData networkdata
//          * @property {proto.IFeeComponents|null} [servicedata] FeeData servicedata
//          */
// 
//         /**
//          * Constructs a new FeeData.
//          * @memberof proto
//          * @classdesc Represents a FeeData.
//          * @implements IFeeData
//          * @constructor
//          * @param {proto.IFeeData=} [properties] Properties to set
//          */
//         function FeeData(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FeeData nodedata.
//          * @member {proto.IFeeComponents|null|undefined} nodedata
//          * @memberof proto.FeeData
//          * @instance
//          */
//         FeeData.prototype.nodedata = null;
// 
//         /**
//          * FeeData networkdata.
//          * @member {proto.IFeeComponents|null|undefined} networkdata
//          * @memberof proto.FeeData
//          * @instance
//          */
//         FeeData.prototype.networkdata = null;
// 
//         /**
//          * FeeData servicedata.
//          * @member {proto.IFeeComponents|null|undefined} servicedata
//          * @memberof proto.FeeData
//          * @instance
//          */
//         FeeData.prototype.servicedata = null;
// 
//         /**
//          * Creates a new FeeData instance using the specified properties.
//          * @function create
//          * @memberof proto.FeeData
//          * @static
//          * @param {proto.IFeeData=} [properties] Properties to set
//          * @returns {proto.FeeData} FeeData instance
//          */
//         FeeData.create = function create(properties) {
//             return new FeeData(properties);
//         };
// 
//         /**
//          * Encodes the specified FeeData message. Does not implicitly {@link proto.FeeData.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FeeData
//          * @static
//          * @param {proto.IFeeData} message FeeData message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FeeData.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.nodedata != null && Object.hasOwnProperty.call(message, "nodedata"))
//                 $root.proto.FeeComponents.encode(message.nodedata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.networkdata != null && Object.hasOwnProperty.call(message, "networkdata"))
//                 $root.proto.FeeComponents.encode(message.networkdata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.servicedata != null && Object.hasOwnProperty.call(message, "servicedata"))
//                 $root.proto.FeeComponents.encode(message.servicedata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FeeData message, length delimited. Does not implicitly {@link proto.FeeData.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FeeData
//          * @static
//          * @param {proto.IFeeData} message FeeData message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FeeData.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FeeData message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FeeData
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FeeData} FeeData
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FeeData.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FeeData();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.nodedata = $root.proto.FeeComponents.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.networkdata = $root.proto.FeeComponents.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.servicedata = $root.proto.FeeComponents.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FeeData message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FeeData
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FeeData} FeeData
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FeeData.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FeeData message.
//          * @function verify
//          * @memberof proto.FeeData
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FeeData.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.nodedata != null && message.hasOwnProperty("nodedata")) {
//                 let error = $root.proto.FeeComponents.verify(message.nodedata);
//                 if (error)
//                     return "nodedata." + error;
//             }
//             if (message.networkdata != null && message.hasOwnProperty("networkdata")) {
//                 let error = $root.proto.FeeComponents.verify(message.networkdata);
//                 if (error)
//                     return "networkdata." + error;
//             }
//             if (message.servicedata != null && message.hasOwnProperty("servicedata")) {
//                 let error = $root.proto.FeeComponents.verify(message.servicedata);
//                 if (error)
//                     return "servicedata." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FeeData message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FeeData
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FeeData} FeeData
//          */
//         FeeData.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FeeData)
//                 return object;
//             let message = new $root.proto.FeeData();
//             if (object.nodedata != null) {
//                 if (typeof object.nodedata !== "object")
//                     throw TypeError(".proto.FeeData.nodedata: object expected");
//                 message.nodedata = $root.proto.FeeComponents.fromObject(object.nodedata);
//             }
//             if (object.networkdata != null) {
//                 if (typeof object.networkdata !== "object")
//                     throw TypeError(".proto.FeeData.networkdata: object expected");
//                 message.networkdata = $root.proto.FeeComponents.fromObject(object.networkdata);
//             }
//             if (object.servicedata != null) {
//                 if (typeof object.servicedata !== "object")
//                     throw TypeError(".proto.FeeData.servicedata: object expected");
//                 message.servicedata = $root.proto.FeeComponents.fromObject(object.servicedata);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FeeData message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FeeData
//          * @static
//          * @param {proto.FeeData} message FeeData
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FeeData.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.nodedata = null;
//                 object.networkdata = null;
//                 object.servicedata = null;
//             }
//             if (message.nodedata != null && message.hasOwnProperty("nodedata"))
//                 object.nodedata = $root.proto.FeeComponents.toObject(message.nodedata, options);
//             if (message.networkdata != null && message.hasOwnProperty("networkdata"))
//                 object.networkdata = $root.proto.FeeComponents.toObject(message.networkdata, options);
//             if (message.servicedata != null && message.hasOwnProperty("servicedata"))
//                 object.servicedata = $root.proto.FeeComponents.toObject(message.servicedata, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FeeData to JSON.
//          * @function toJSON
//          * @memberof proto.FeeData
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FeeData.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FeeData;
//     })();
// 
//     proto.FeeSchedule = (function() {
// 
//         /**
//          * Properties of a FeeSchedule.
//          * @memberof proto
//          * @interface IFeeSchedule
//          * @property {Array.<proto.ITransactionFeeSchedule>|null} [transactionFeeSchedule] FeeSchedule transactionFeeSchedule
//          * @property {proto.ITimestampSeconds|null} [expiryTime] FeeSchedule expiryTime
//          */
// 
//         /**
//          * Constructs a new FeeSchedule.
//          * @memberof proto
//          * @classdesc Represents a FeeSchedule.
//          * @implements IFeeSchedule
//          * @constructor
//          * @param {proto.IFeeSchedule=} [properties] Properties to set
//          */
//         function FeeSchedule(properties) {
//             this.transactionFeeSchedule = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FeeSchedule transactionFeeSchedule.
//          * @member {Array.<proto.ITransactionFeeSchedule>} transactionFeeSchedule
//          * @memberof proto.FeeSchedule
//          * @instance
//          */
//         FeeSchedule.prototype.transactionFeeSchedule = $util.emptyArray;
// 
//         /**
//          * FeeSchedule expiryTime.
//          * @member {proto.ITimestampSeconds|null|undefined} expiryTime
//          * @memberof proto.FeeSchedule
//          * @instance
//          */
//         FeeSchedule.prototype.expiryTime = null;
// 
//         /**
//          * Creates a new FeeSchedule instance using the specified properties.
//          * @function create
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {proto.IFeeSchedule=} [properties] Properties to set
//          * @returns {proto.FeeSchedule} FeeSchedule instance
//          */
//         FeeSchedule.create = function create(properties) {
//             return new FeeSchedule(properties);
//         };
// 
//         /**
//          * Encodes the specified FeeSchedule message. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {proto.IFeeSchedule} message FeeSchedule message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FeeSchedule.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.transactionFeeSchedule != null && message.transactionFeeSchedule.length)
//                 for (let i = 0; i < message.transactionFeeSchedule.length; ++i)
//                     $root.proto.TransactionFeeSchedule.encode(message.transactionFeeSchedule[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.expiryTime != null && Object.hasOwnProperty.call(message, "expiryTime"))
//                 $root.proto.TimestampSeconds.encode(message.expiryTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FeeSchedule message, length delimited. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {proto.IFeeSchedule} message FeeSchedule message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FeeSchedule.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FeeSchedule message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FeeSchedule} FeeSchedule
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FeeSchedule.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FeeSchedule();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     if (!(message.transactionFeeSchedule && message.transactionFeeSchedule.length))
//                         message.transactionFeeSchedule = [];
//                     message.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(reader, reader.uint32()));
//                     break;
//                 case 2:
//                     message.expiryTime = $root.proto.TimestampSeconds.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FeeSchedule message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FeeSchedule} FeeSchedule
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FeeSchedule.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FeeSchedule message.
//          * @function verify
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FeeSchedule.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.transactionFeeSchedule != null && message.hasOwnProperty("transactionFeeSchedule")) {
//                 if (!Array.isArray(message.transactionFeeSchedule))
//                     return "transactionFeeSchedule: array expected";
//                 for (let i = 0; i < message.transactionFeeSchedule.length; ++i) {
//                     let error = $root.proto.TransactionFeeSchedule.verify(message.transactionFeeSchedule[i]);
//                     if (error)
//                         return "transactionFeeSchedule." + error;
//                 }
//             }
//             if (message.expiryTime != null && message.hasOwnProperty("expiryTime")) {
//                 let error = $root.proto.TimestampSeconds.verify(message.expiryTime);
//                 if (error)
//                     return "expiryTime." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FeeSchedule message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FeeSchedule} FeeSchedule
//          */
//         FeeSchedule.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FeeSchedule)
//                 return object;
//             let message = new $root.proto.FeeSchedule();
//             if (object.transactionFeeSchedule) {
//                 if (!Array.isArray(object.transactionFeeSchedule))
//                     throw TypeError(".proto.FeeSchedule.transactionFeeSchedule: array expected");
//                 message.transactionFeeSchedule = [];
//                 for (let i = 0; i < object.transactionFeeSchedule.length; ++i) {
//                     if (typeof object.transactionFeeSchedule[i] !== "object")
//                         throw TypeError(".proto.FeeSchedule.transactionFeeSchedule: object expected");
//                     message.transactionFeeSchedule[i] = $root.proto.TransactionFeeSchedule.fromObject(object.transactionFeeSchedule[i]);
//                 }
//             }
//             if (object.expiryTime != null) {
//                 if (typeof object.expiryTime !== "object")
//                     throw TypeError(".proto.FeeSchedule.expiryTime: object expected");
//                 message.expiryTime = $root.proto.TimestampSeconds.fromObject(object.expiryTime);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FeeSchedule message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FeeSchedule
//          * @static
//          * @param {proto.FeeSchedule} message FeeSchedule
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FeeSchedule.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.transactionFeeSchedule = [];
//             if (options.defaults)
//                 object.expiryTime = null;
//             if (message.transactionFeeSchedule && message.transactionFeeSchedule.length) {
//                 object.transactionFeeSchedule = [];
//                 for (let j = 0; j < message.transactionFeeSchedule.length; ++j)
//                     object.transactionFeeSchedule[j] = $root.proto.TransactionFeeSchedule.toObject(message.transactionFeeSchedule[j], options);
//             }
//             if (message.expiryTime != null && message.hasOwnProperty("expiryTime"))
//                 object.expiryTime = $root.proto.TimestampSeconds.toObject(message.expiryTime, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FeeSchedule to JSON.
//          * @function toJSON
//          * @memberof proto.FeeSchedule
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FeeSchedule.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FeeSchedule;
//     })();
// 
//     proto.CurrentAndNextFeeSchedule = (function() {
// 
//         /**
//          * Properties of a CurrentAndNextFeeSchedule.
//          * @memberof proto
//          * @interface ICurrentAndNextFeeSchedule
//          * @property {proto.IFeeSchedule|null} [currentFeeSchedule] CurrentAndNextFeeSchedule currentFeeSchedule
//          * @property {proto.IFeeSchedule|null} [nextFeeSchedule] CurrentAndNextFeeSchedule nextFeeSchedule
//          */
// 
//         /**
//          * Constructs a new CurrentAndNextFeeSchedule.
//          * @memberof proto
//          * @classdesc Represents a CurrentAndNextFeeSchedule.
//          * @implements ICurrentAndNextFeeSchedule
//          * @constructor
//          * @param {proto.ICurrentAndNextFeeSchedule=} [properties] Properties to set
//          */
//         function CurrentAndNextFeeSchedule(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CurrentAndNextFeeSchedule currentFeeSchedule.
//          * @member {proto.IFeeSchedule|null|undefined} currentFeeSchedule
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @instance
//          */
//         CurrentAndNextFeeSchedule.prototype.currentFeeSchedule = null;
// 
//         /**
//          * CurrentAndNextFeeSchedule nextFeeSchedule.
//          * @member {proto.IFeeSchedule|null|undefined} nextFeeSchedule
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @instance
//          */
//         CurrentAndNextFeeSchedule.prototype.nextFeeSchedule = null;
// 
//         /**
//          * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
//          * @function create
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {proto.ICurrentAndNextFeeSchedule=} [properties] Properties to set
//          * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule instance
//          */
//         CurrentAndNextFeeSchedule.create = function create(properties) {
//             return new CurrentAndNextFeeSchedule(properties);
//         };
// 
//         /**
//          * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {proto.ICurrentAndNextFeeSchedule} message CurrentAndNextFeeSchedule message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CurrentAndNextFeeSchedule.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.currentFeeSchedule != null && Object.hasOwnProperty.call(message, "currentFeeSchedule"))
//                 $root.proto.FeeSchedule.encode(message.currentFeeSchedule, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.nextFeeSchedule != null && Object.hasOwnProperty.call(message, "nextFeeSchedule"))
//                 $root.proto.FeeSchedule.encode(message.nextFeeSchedule, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CurrentAndNextFeeSchedule message, length delimited. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {proto.ICurrentAndNextFeeSchedule} message CurrentAndNextFeeSchedule message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CurrentAndNextFeeSchedule.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CurrentAndNextFeeSchedule.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CurrentAndNextFeeSchedule();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.currentFeeSchedule = $root.proto.FeeSchedule.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.nextFeeSchedule = $root.proto.FeeSchedule.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CurrentAndNextFeeSchedule.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CurrentAndNextFeeSchedule message.
//          * @function verify
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CurrentAndNextFeeSchedule.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.currentFeeSchedule != null && message.hasOwnProperty("currentFeeSchedule")) {
//                 let error = $root.proto.FeeSchedule.verify(message.currentFeeSchedule);
//                 if (error)
//                     return "currentFeeSchedule." + error;
//             }
//             if (message.nextFeeSchedule != null && message.hasOwnProperty("nextFeeSchedule")) {
//                 let error = $root.proto.FeeSchedule.verify(message.nextFeeSchedule);
//                 if (error)
//                     return "nextFeeSchedule." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CurrentAndNextFeeSchedule message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
//          */
//         CurrentAndNextFeeSchedule.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CurrentAndNextFeeSchedule)
//                 return object;
//             let message = new $root.proto.CurrentAndNextFeeSchedule();
//             if (object.currentFeeSchedule != null) {
//                 if (typeof object.currentFeeSchedule !== "object")
//                     throw TypeError(".proto.CurrentAndNextFeeSchedule.currentFeeSchedule: object expected");
//                 message.currentFeeSchedule = $root.proto.FeeSchedule.fromObject(object.currentFeeSchedule);
//             }
//             if (object.nextFeeSchedule != null) {
//                 if (typeof object.nextFeeSchedule !== "object")
//                     throw TypeError(".proto.CurrentAndNextFeeSchedule.nextFeeSchedule: object expected");
//                 message.nextFeeSchedule = $root.proto.FeeSchedule.fromObject(object.nextFeeSchedule);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CurrentAndNextFeeSchedule message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @static
//          * @param {proto.CurrentAndNextFeeSchedule} message CurrentAndNextFeeSchedule
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CurrentAndNextFeeSchedule.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.currentFeeSchedule = null;
//                 object.nextFeeSchedule = null;
//             }
//             if (message.currentFeeSchedule != null && message.hasOwnProperty("currentFeeSchedule"))
//                 object.currentFeeSchedule = $root.proto.FeeSchedule.toObject(message.currentFeeSchedule, options);
//             if (message.nextFeeSchedule != null && message.hasOwnProperty("nextFeeSchedule"))
//                 object.nextFeeSchedule = $root.proto.FeeSchedule.toObject(message.nextFeeSchedule, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CurrentAndNextFeeSchedule to JSON.
//          * @function toJSON
//          * @memberof proto.CurrentAndNextFeeSchedule
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CurrentAndNextFeeSchedule.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CurrentAndNextFeeSchedule;
//     })();
// 
//     proto.NodeAddress = (function() {
// 
//         /**
//          * Properties of a NodeAddress.
//          * @memberof proto
//          * @interface INodeAddress
//          * @property {Uint8Array|null} [ipAddress] NodeAddress ipAddress
//          * @property {number|null} [portno] NodeAddress portno
//          * @property {Uint8Array|null} [memo] NodeAddress memo
//          * @property {string|null} [RSA_PubKey] NodeAddress RSA_PubKey
//          * @property {number|Long|null} [nodeId] NodeAddress nodeId
//          * @property {proto.IAccountID|null} [nodeAccountId] NodeAddress nodeAccountId
//          * @property {Uint8Array|null} [nodeCertHash] NodeAddress nodeCertHash
//          */
// 
//         /**
//          * Constructs a new NodeAddress.
//          * @memberof proto
//          * @classdesc Represents a NodeAddress.
//          * @implements INodeAddress
//          * @constructor
//          * @param {proto.INodeAddress=} [properties] Properties to set
//          */
//         function NodeAddress(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * NodeAddress ipAddress.
//          * @member {Uint8Array} ipAddress
//          * @memberof proto.NodeAddress
//          * @instance
//          */
//         NodeAddress.prototype.ipAddress = $util.newBuffer([]);
// 
//         /**
//          * NodeAddress portno.
//          * @member {number} portno
//          * @memberof proto.NodeAddress
//          * @instance
//          */
//         NodeAddress.prototype.portno = 0;
// 
//         /**
//          * NodeAddress memo.
//          * @member {Uint8Array} memo
//          * @memberof proto.NodeAddress
//          * @instance
//          */
//         NodeAddress.prototype.memo = $util.newBuffer([]);
// 
//         /**
//          * NodeAddress RSA_PubKey.
//          * @member {string} RSA_PubKey
//          * @memberof proto.NodeAddress
//          * @instance
//          */
//         NodeAddress.prototype.RSA_PubKey = "";
// 
//         /**
//          * NodeAddress nodeId.
//          * @member {number|Long} nodeId
//          * @memberof proto.NodeAddress
//          * @instance
//          */
//         NodeAddress.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * NodeAddress nodeAccountId.
//          * @member {proto.IAccountID|null|undefined} nodeAccountId
//          * @memberof proto.NodeAddress
//          * @instance
//          */
//         NodeAddress.prototype.nodeAccountId = null;
// 
//         /**
//          * NodeAddress nodeCertHash.
//          * @member {Uint8Array} nodeCertHash
//          * @memberof proto.NodeAddress
//          * @instance
//          */
//         NodeAddress.prototype.nodeCertHash = $util.newBuffer([]);
// 
//         /**
//          * Creates a new NodeAddress instance using the specified properties.
//          * @function create
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {proto.INodeAddress=} [properties] Properties to set
//          * @returns {proto.NodeAddress} NodeAddress instance
//          */
//         NodeAddress.create = function create(properties) {
//             return new NodeAddress(properties);
//         };
// 
//         /**
//          * Encodes the specified NodeAddress message. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
//          * @function encode
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {proto.INodeAddress} message NodeAddress message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NodeAddress.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.ipAddress != null && Object.hasOwnProperty.call(message, "ipAddress"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ipAddress);
//             if (message.portno != null && Object.hasOwnProperty.call(message, "portno"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.portno);
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.memo);
//             if (message.RSA_PubKey != null && Object.hasOwnProperty.call(message, "RSA_PubKey"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).string(message.RSA_PubKey);
//             if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
//                 writer.uint32(/* id 5, wireType 0 =*/40).int64(message.nodeId);
//             if (message.nodeAccountId != null && Object.hasOwnProperty.call(message, "nodeAccountId"))
//                 $root.proto.AccountID.encode(message.nodeAccountId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.nodeCertHash != null && Object.hasOwnProperty.call(message, "nodeCertHash"))
//                 writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.nodeCertHash);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified NodeAddress message, length delimited. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {proto.INodeAddress} message NodeAddress message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NodeAddress.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a NodeAddress message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.NodeAddress} NodeAddress
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NodeAddress.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NodeAddress();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.ipAddress = reader.bytes();
//                     break;
//                 case 2:
//                     message.portno = reader.int32();
//                     break;
//                 case 3:
//                     message.memo = reader.bytes();
//                     break;
//                 case 4:
//                     message.RSA_PubKey = reader.string();
//                     break;
//                 case 5:
//                     message.nodeId = reader.int64();
//                     break;
//                 case 6:
//                     message.nodeAccountId = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.nodeCertHash = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a NodeAddress message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.NodeAddress} NodeAddress
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NodeAddress.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a NodeAddress message.
//          * @function verify
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         NodeAddress.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
//                 if (!(message.ipAddress && typeof message.ipAddress.length === "number" || $util.isString(message.ipAddress)))
//                     return "ipAddress: buffer expected";
//             if (message.portno != null && message.hasOwnProperty("portno"))
//                 if (!$util.isInteger(message.portno))
//                     return "portno: integer expected";
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 if (!(message.memo && typeof message.memo.length === "number" || $util.isString(message.memo)))
//                     return "memo: buffer expected";
//             if (message.RSA_PubKey != null && message.hasOwnProperty("RSA_PubKey"))
//                 if (!$util.isString(message.RSA_PubKey))
//                     return "RSA_PubKey: string expected";
//             if (message.nodeId != null && message.hasOwnProperty("nodeId"))
//                 if (!$util.isInteger(message.nodeId) && !(message.nodeId && $util.isInteger(message.nodeId.low) && $util.isInteger(message.nodeId.high)))
//                     return "nodeId: integer|Long expected";
//             if (message.nodeAccountId != null && message.hasOwnProperty("nodeAccountId")) {
//                 let error = $root.proto.AccountID.verify(message.nodeAccountId);
//                 if (error)
//                     return "nodeAccountId." + error;
//             }
//             if (message.nodeCertHash != null && message.hasOwnProperty("nodeCertHash"))
//                 if (!(message.nodeCertHash && typeof message.nodeCertHash.length === "number" || $util.isString(message.nodeCertHash)))
//                     return "nodeCertHash: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a NodeAddress message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.NodeAddress} NodeAddress
//          */
//         NodeAddress.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.NodeAddress)
//                 return object;
//             let message = new $root.proto.NodeAddress();
//             if (object.ipAddress != null)
//                 if (typeof object.ipAddress === "string")
//                     $util.base64.decode(object.ipAddress, message.ipAddress = $util.newBuffer($util.base64.length(object.ipAddress)), 0);
//                 else if (object.ipAddress.length)
//                     message.ipAddress = object.ipAddress;
//             if (object.portno != null)
//                 message.portno = object.portno | 0;
//             if (object.memo != null)
//                 if (typeof object.memo === "string")
//                     $util.base64.decode(object.memo, message.memo = $util.newBuffer($util.base64.length(object.memo)), 0);
//                 else if (object.memo.length)
//                     message.memo = object.memo;
//             if (object.RSA_PubKey != null)
//                 message.RSA_PubKey = String(object.RSA_PubKey);
//             if (object.nodeId != null)
//                 if ($util.Long)
//                     (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
//                 else if (typeof object.nodeId === "string")
//                     message.nodeId = parseInt(object.nodeId, 10);
//                 else if (typeof object.nodeId === "number")
//                     message.nodeId = object.nodeId;
//                 else if (typeof object.nodeId === "object")
//                     message.nodeId = new $util.LongBits(object.nodeId.low >>> 0, object.nodeId.high >>> 0).toNumber();
//             if (object.nodeAccountId != null) {
//                 if (typeof object.nodeAccountId !== "object")
//                     throw TypeError(".proto.NodeAddress.nodeAccountId: object expected");
//                 message.nodeAccountId = $root.proto.AccountID.fromObject(object.nodeAccountId);
//             }
//             if (object.nodeCertHash != null)
//                 if (typeof object.nodeCertHash === "string")
//                     $util.base64.decode(object.nodeCertHash, message.nodeCertHash = $util.newBuffer($util.base64.length(object.nodeCertHash)), 0);
//                 else if (object.nodeCertHash.length)
//                     message.nodeCertHash = object.nodeCertHash;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a NodeAddress message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.NodeAddress
//          * @static
//          * @param {proto.NodeAddress} message NodeAddress
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         NodeAddress.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if (options.bytes === String)
//                     object.ipAddress = "";
//                 else {
//                     object.ipAddress = [];
//                     if (options.bytes !== Array)
//                         object.ipAddress = $util.newBuffer(object.ipAddress);
//                 }
//                 object.portno = 0;
//                 if (options.bytes === String)
//                     object.memo = "";
//                 else {
//                     object.memo = [];
//                     if (options.bytes !== Array)
//                         object.memo = $util.newBuffer(object.memo);
//                 }
//                 object.RSA_PubKey = "";
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.nodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.nodeId = options.longs === String ? "0" : 0;
//                 object.nodeAccountId = null;
//                 if (options.bytes === String)
//                     object.nodeCertHash = "";
//                 else {
//                     object.nodeCertHash = [];
//                     if (options.bytes !== Array)
//                         object.nodeCertHash = $util.newBuffer(object.nodeCertHash);
//                 }
//             }
//             if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
//                 object.ipAddress = options.bytes === String ? $util.base64.encode(message.ipAddress, 0, message.ipAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ipAddress) : message.ipAddress;
//             if (message.portno != null && message.hasOwnProperty("portno"))
//                 object.portno = message.portno;
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = options.bytes === String ? $util.base64.encode(message.memo, 0, message.memo.length) : options.bytes === Array ? Array.prototype.slice.call(message.memo) : message.memo;
//             if (message.RSA_PubKey != null && message.hasOwnProperty("RSA_PubKey"))
//                 object.RSA_PubKey = message.RSA_PubKey;
//             if (message.nodeId != null && message.hasOwnProperty("nodeId"))
//                 if (typeof message.nodeId === "number")
//                     object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
//                 else
//                     object.nodeId = options.longs === String ? $util.Long.prototype.toString.call(message.nodeId) : options.longs === Number ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber() : message.nodeId;
//             if (message.nodeAccountId != null && message.hasOwnProperty("nodeAccountId"))
//                 object.nodeAccountId = $root.proto.AccountID.toObject(message.nodeAccountId, options);
//             if (message.nodeCertHash != null && message.hasOwnProperty("nodeCertHash"))
//                 object.nodeCertHash = options.bytes === String ? $util.base64.encode(message.nodeCertHash, 0, message.nodeCertHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodeCertHash) : message.nodeCertHash;
//             return object;
//         };
// 
//         /**
//          * Converts this NodeAddress to JSON.
//          * @function toJSON
//          * @memberof proto.NodeAddress
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         NodeAddress.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return NodeAddress;
//     })();
// 
//     proto.NodeAddressBook = (function() {
// 
//         /**
//          * Properties of a NodeAddressBook.
//          * @memberof proto
//          * @interface INodeAddressBook
//          * @property {Array.<proto.INodeAddress>|null} [nodeAddress] NodeAddressBook nodeAddress
//          */
// 
//         /**
//          * Constructs a new NodeAddressBook.
//          * @memberof proto
//          * @classdesc Represents a NodeAddressBook.
//          * @implements INodeAddressBook
//          * @constructor
//          * @param {proto.INodeAddressBook=} [properties] Properties to set
//          */
//         function NodeAddressBook(properties) {
//             this.nodeAddress = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * NodeAddressBook nodeAddress.
//          * @member {Array.<proto.INodeAddress>} nodeAddress
//          * @memberof proto.NodeAddressBook
//          * @instance
//          */
//         NodeAddressBook.prototype.nodeAddress = $util.emptyArray;
// 
//         /**
//          * Creates a new NodeAddressBook instance using the specified properties.
//          * @function create
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {proto.INodeAddressBook=} [properties] Properties to set
//          * @returns {proto.NodeAddressBook} NodeAddressBook instance
//          */
//         NodeAddressBook.create = function create(properties) {
//             return new NodeAddressBook(properties);
//         };
// 
//         /**
//          * Encodes the specified NodeAddressBook message. Does not implicitly {@link proto.NodeAddressBook.verify|verify} messages.
//          * @function encode
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {proto.INodeAddressBook} message NodeAddressBook message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NodeAddressBook.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.nodeAddress != null && message.nodeAddress.length)
//                 for (let i = 0; i < message.nodeAddress.length; ++i)
//                     $root.proto.NodeAddress.encode(message.nodeAddress[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified NodeAddressBook message, length delimited. Does not implicitly {@link proto.NodeAddressBook.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {proto.INodeAddressBook} message NodeAddressBook message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NodeAddressBook.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a NodeAddressBook message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.NodeAddressBook} NodeAddressBook
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NodeAddressBook.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NodeAddressBook();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     if (!(message.nodeAddress && message.nodeAddress.length))
//                         message.nodeAddress = [];
//                     message.nodeAddress.push($root.proto.NodeAddress.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a NodeAddressBook message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.NodeAddressBook} NodeAddressBook
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NodeAddressBook.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a NodeAddressBook message.
//          * @function verify
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         NodeAddressBook.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.nodeAddress != null && message.hasOwnProperty("nodeAddress")) {
//                 if (!Array.isArray(message.nodeAddress))
//                     return "nodeAddress: array expected";
//                 for (let i = 0; i < message.nodeAddress.length; ++i) {
//                     let error = $root.proto.NodeAddress.verify(message.nodeAddress[i]);
//                     if (error)
//                         return "nodeAddress." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a NodeAddressBook message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.NodeAddressBook} NodeAddressBook
//          */
//         NodeAddressBook.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.NodeAddressBook)
//                 return object;
//             let message = new $root.proto.NodeAddressBook();
//             if (object.nodeAddress) {
//                 if (!Array.isArray(object.nodeAddress))
//                     throw TypeError(".proto.NodeAddressBook.nodeAddress: array expected");
//                 message.nodeAddress = [];
//                 for (let i = 0; i < object.nodeAddress.length; ++i) {
//                     if (typeof object.nodeAddress[i] !== "object")
//                         throw TypeError(".proto.NodeAddressBook.nodeAddress: object expected");
//                     message.nodeAddress[i] = $root.proto.NodeAddress.fromObject(object.nodeAddress[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a NodeAddressBook message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.NodeAddressBook
//          * @static
//          * @param {proto.NodeAddressBook} message NodeAddressBook
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         NodeAddressBook.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.nodeAddress = [];
//             if (message.nodeAddress && message.nodeAddress.length) {
//                 object.nodeAddress = [];
//                 for (let j = 0; j < message.nodeAddress.length; ++j)
//                     object.nodeAddress[j] = $root.proto.NodeAddress.toObject(message.nodeAddress[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this NodeAddressBook to JSON.
//          * @function toJSON
//          * @memberof proto.NodeAddressBook
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         NodeAddressBook.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return NodeAddressBook;
//     })();
// 
//     proto.SemanticVersion = (function() {
// 
//         /**
//          * Properties of a SemanticVersion.
//          * @memberof proto
//          * @interface ISemanticVersion
//          * @property {number|null} [major] SemanticVersion major
//          * @property {number|null} [minor] SemanticVersion minor
//          * @property {number|null} [patch] SemanticVersion patch
//          */
// 
//         /**
//          * Constructs a new SemanticVersion.
//          * @memberof proto
//          * @classdesc Represents a SemanticVersion.
//          * @implements ISemanticVersion
//          * @constructor
//          * @param {proto.ISemanticVersion=} [properties] Properties to set
//          */
//         function SemanticVersion(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * SemanticVersion major.
//          * @member {number} major
//          * @memberof proto.SemanticVersion
//          * @instance
//          */
//         SemanticVersion.prototype.major = 0;
// 
//         /**
//          * SemanticVersion minor.
//          * @member {number} minor
//          * @memberof proto.SemanticVersion
//          * @instance
//          */
//         SemanticVersion.prototype.minor = 0;
// 
//         /**
//          * SemanticVersion patch.
//          * @member {number} patch
//          * @memberof proto.SemanticVersion
//          * @instance
//          */
//         SemanticVersion.prototype.patch = 0;
// 
//         /**
//          * Creates a new SemanticVersion instance using the specified properties.
//          * @function create
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {proto.ISemanticVersion=} [properties] Properties to set
//          * @returns {proto.SemanticVersion} SemanticVersion instance
//          */
//         SemanticVersion.create = function create(properties) {
//             return new SemanticVersion(properties);
//         };
// 
//         /**
//          * Encodes the specified SemanticVersion message. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
//          * @function encode
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {proto.ISemanticVersion} message SemanticVersion message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SemanticVersion.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.major != null && Object.hasOwnProperty.call(message, "major"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.major);
//             if (message.minor != null && Object.hasOwnProperty.call(message, "minor"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minor);
//             if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int32(message.patch);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified SemanticVersion message, length delimited. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {proto.ISemanticVersion} message SemanticVersion message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SemanticVersion.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a SemanticVersion message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.SemanticVersion} SemanticVersion
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SemanticVersion.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SemanticVersion();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.major = reader.int32();
//                     break;
//                 case 2:
//                     message.minor = reader.int32();
//                     break;
//                 case 3:
//                     message.patch = reader.int32();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a SemanticVersion message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.SemanticVersion} SemanticVersion
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SemanticVersion.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a SemanticVersion message.
//          * @function verify
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         SemanticVersion.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.major != null && message.hasOwnProperty("major"))
//                 if (!$util.isInteger(message.major))
//                     return "major: integer expected";
//             if (message.minor != null && message.hasOwnProperty("minor"))
//                 if (!$util.isInteger(message.minor))
//                     return "minor: integer expected";
//             if (message.patch != null && message.hasOwnProperty("patch"))
//                 if (!$util.isInteger(message.patch))
//                     return "patch: integer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a SemanticVersion message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.SemanticVersion} SemanticVersion
//          */
//         SemanticVersion.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.SemanticVersion)
//                 return object;
//             let message = new $root.proto.SemanticVersion();
//             if (object.major != null)
//                 message.major = object.major | 0;
//             if (object.minor != null)
//                 message.minor = object.minor | 0;
//             if (object.patch != null)
//                 message.patch = object.patch | 0;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a SemanticVersion message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.SemanticVersion
//          * @static
//          * @param {proto.SemanticVersion} message SemanticVersion
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         SemanticVersion.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.major = 0;
//                 object.minor = 0;
//                 object.patch = 0;
//             }
//             if (message.major != null && message.hasOwnProperty("major"))
//                 object.major = message.major;
//             if (message.minor != null && message.hasOwnProperty("minor"))
//                 object.minor = message.minor;
//             if (message.patch != null && message.hasOwnProperty("patch"))
//                 object.patch = message.patch;
//             return object;
//         };
// 
//         /**
//          * Converts this SemanticVersion to JSON.
//          * @function toJSON
//          * @memberof proto.SemanticVersion
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         SemanticVersion.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return SemanticVersion;
//     })();
// 
//     proto.Setting = (function() {
// 
//         /**
//          * Properties of a Setting.
//          * @memberof proto
//          * @interface ISetting
//          * @property {string|null} [name] Setting name
//          * @property {string|null} [value] Setting value
//          * @property {Uint8Array|null} [data] Setting data
//          */
// 
//         /**
//          * Constructs a new Setting.
//          * @memberof proto
//          * @classdesc Represents a Setting.
//          * @implements ISetting
//          * @constructor
//          * @param {proto.ISetting=} [properties] Properties to set
//          */
//         function Setting(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Setting name.
//          * @member {string} name
//          * @memberof proto.Setting
//          * @instance
//          */
//         Setting.prototype.name = "";
// 
//         /**
//          * Setting value.
//          * @member {string} value
//          * @memberof proto.Setting
//          * @instance
//          */
//         Setting.prototype.value = "";
// 
//         /**
//          * Setting data.
//          * @member {Uint8Array} data
//          * @memberof proto.Setting
//          * @instance
//          */
//         Setting.prototype.data = $util.newBuffer([]);
// 
//         /**
//          * Creates a new Setting instance using the specified properties.
//          * @function create
//          * @memberof proto.Setting
//          * @static
//          * @param {proto.ISetting=} [properties] Properties to set
//          * @returns {proto.Setting} Setting instance
//          */
//         Setting.create = function create(properties) {
//             return new Setting(properties);
//         };
// 
//         /**
//          * Encodes the specified Setting message. Does not implicitly {@link proto.Setting.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Setting
//          * @static
//          * @param {proto.ISetting} message Setting message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Setting.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.name != null && Object.hasOwnProperty.call(message, "name"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
//             if (message.data != null && Object.hasOwnProperty.call(message, "data"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Setting message, length delimited. Does not implicitly {@link proto.Setting.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Setting
//          * @static
//          * @param {proto.ISetting} message Setting message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Setting.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Setting message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Setting
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Setting} Setting
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Setting.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Setting();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.name = reader.string();
//                     break;
//                 case 2:
//                     message.value = reader.string();
//                     break;
//                 case 3:
//                     message.data = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Setting message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Setting
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Setting} Setting
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Setting.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Setting message.
//          * @function verify
//          * @memberof proto.Setting
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Setting.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.name != null && message.hasOwnProperty("name"))
//                 if (!$util.isString(message.name))
//                     return "name: string expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (!$util.isString(message.value))
//                     return "value: string expected";
//             if (message.data != null && message.hasOwnProperty("data"))
//                 if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
//                     return "data: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a Setting message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Setting
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Setting} Setting
//          */
//         Setting.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Setting)
//                 return object;
//             let message = new $root.proto.Setting();
//             if (object.name != null)
//                 message.name = String(object.name);
//             if (object.value != null)
//                 message.value = String(object.value);
//             if (object.data != null)
//                 if (typeof object.data === "string")
//                     $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
//                 else if (object.data.length)
//                     message.data = object.data;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Setting message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Setting
//          * @static
//          * @param {proto.Setting} message Setting
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Setting.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.name = "";
//                 object.value = "";
//                 if (options.bytes === String)
//                     object.data = "";
//                 else {
//                     object.data = [];
//                     if (options.bytes !== Array)
//                         object.data = $util.newBuffer(object.data);
//                 }
//             }
//             if (message.name != null && message.hasOwnProperty("name"))
//                 object.name = message.name;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = message.value;
//             if (message.data != null && message.hasOwnProperty("data"))
//                 object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
//             return object;
//         };
// 
//         /**
//          * Converts this Setting to JSON.
//          * @function toJSON
//          * @memberof proto.Setting
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Setting.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Setting;
//     })();
// 
//     proto.ServicesConfigurationList = (function() {
// 
//         /**
//          * Properties of a ServicesConfigurationList.
//          * @memberof proto
//          * @interface IServicesConfigurationList
//          * @property {Array.<proto.ISetting>|null} [nameValue] ServicesConfigurationList nameValue
//          */
// 
//         /**
//          * Constructs a new ServicesConfigurationList.
//          * @memberof proto
//          * @classdesc Represents a ServicesConfigurationList.
//          * @implements IServicesConfigurationList
//          * @constructor
//          * @param {proto.IServicesConfigurationList=} [properties] Properties to set
//          */
//         function ServicesConfigurationList(properties) {
//             this.nameValue = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ServicesConfigurationList nameValue.
//          * @member {Array.<proto.ISetting>} nameValue
//          * @memberof proto.ServicesConfigurationList
//          * @instance
//          */
//         ServicesConfigurationList.prototype.nameValue = $util.emptyArray;
// 
//         /**
//          * Creates a new ServicesConfigurationList instance using the specified properties.
//          * @function create
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {proto.IServicesConfigurationList=} [properties] Properties to set
//          * @returns {proto.ServicesConfigurationList} ServicesConfigurationList instance
//          */
//         ServicesConfigurationList.create = function create(properties) {
//             return new ServicesConfigurationList(properties);
//         };
// 
//         /**
//          * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {proto.IServicesConfigurationList} message ServicesConfigurationList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ServicesConfigurationList.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.nameValue != null && message.nameValue.length)
//                 for (let i = 0; i < message.nameValue.length; ++i)
//                     $root.proto.Setting.encode(message.nameValue[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ServicesConfigurationList message, length delimited. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {proto.IServicesConfigurationList} message ServicesConfigurationList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ServicesConfigurationList.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ServicesConfigurationList message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ServicesConfigurationList.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ServicesConfigurationList();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     if (!(message.nameValue && message.nameValue.length))
//                         message.nameValue = [];
//                     message.nameValue.push($root.proto.Setting.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ServicesConfigurationList message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ServicesConfigurationList.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ServicesConfigurationList message.
//          * @function verify
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ServicesConfigurationList.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.nameValue != null && message.hasOwnProperty("nameValue")) {
//                 if (!Array.isArray(message.nameValue))
//                     return "nameValue: array expected";
//                 for (let i = 0; i < message.nameValue.length; ++i) {
//                     let error = $root.proto.Setting.verify(message.nameValue[i]);
//                     if (error)
//                         return "nameValue." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ServicesConfigurationList message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
//          */
//         ServicesConfigurationList.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ServicesConfigurationList)
//                 return object;
//             let message = new $root.proto.ServicesConfigurationList();
//             if (object.nameValue) {
//                 if (!Array.isArray(object.nameValue))
//                     throw TypeError(".proto.ServicesConfigurationList.nameValue: array expected");
//                 message.nameValue = [];
//                 for (let i = 0; i < object.nameValue.length; ++i) {
//                     if (typeof object.nameValue[i] !== "object")
//                         throw TypeError(".proto.ServicesConfigurationList.nameValue: object expected");
//                     message.nameValue[i] = $root.proto.Setting.fromObject(object.nameValue[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ServicesConfigurationList message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ServicesConfigurationList
//          * @static
//          * @param {proto.ServicesConfigurationList} message ServicesConfigurationList
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ServicesConfigurationList.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.nameValue = [];
//             if (message.nameValue && message.nameValue.length) {
//                 object.nameValue = [];
//                 for (let j = 0; j < message.nameValue.length; ++j)
//                     object.nameValue[j] = $root.proto.Setting.toObject(message.nameValue[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this ServicesConfigurationList to JSON.
//          * @function toJSON
//          * @memberof proto.ServicesConfigurationList
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ServicesConfigurationList.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ServicesConfigurationList;
//     })();
// 
//     proto.Timestamp = (function() {
// 
//         /**
//          * Properties of a Timestamp.
//          * @memberof proto
//          * @interface ITimestamp
//          * @property {number|Long|null} [seconds] Timestamp seconds
//          * @property {number|null} [nanos] Timestamp nanos
//          */
// 
//         /**
//          * Constructs a new Timestamp.
//          * @memberof proto
//          * @classdesc Represents a Timestamp.
//          * @implements ITimestamp
//          * @constructor
//          * @param {proto.ITimestamp=} [properties] Properties to set
//          */
//         function Timestamp(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Timestamp seconds.
//          * @member {number|Long} seconds
//          * @memberof proto.Timestamp
//          * @instance
//          */
//         Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Timestamp nanos.
//          * @member {number} nanos
//          * @memberof proto.Timestamp
//          * @instance
//          */
//         Timestamp.prototype.nanos = 0;
// 
//         /**
//          * Creates a new Timestamp instance using the specified properties.
//          * @function create
//          * @memberof proto.Timestamp
//          * @static
//          * @param {proto.ITimestamp=} [properties] Properties to set
//          * @returns {proto.Timestamp} Timestamp instance
//          */
//         Timestamp.create = function create(properties) {
//             return new Timestamp(properties);
//         };
// 
//         /**
//          * Encodes the specified Timestamp message. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Timestamp
//          * @static
//          * @param {proto.ITimestamp} message Timestamp message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Timestamp.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
//             if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Timestamp
//          * @static
//          * @param {proto.ITimestamp} message Timestamp message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Timestamp message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Timestamp
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Timestamp} Timestamp
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Timestamp.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Timestamp();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.seconds = reader.int64();
//                     break;
//                 case 2:
//                     message.nanos = reader.int32();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Timestamp message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Timestamp
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Timestamp} Timestamp
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Timestamp.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Timestamp message.
//          * @function verify
//          * @memberof proto.Timestamp
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Timestamp.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.seconds != null && message.hasOwnProperty("seconds"))
//                 if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
//                     return "seconds: integer|Long expected";
//             if (message.nanos != null && message.hasOwnProperty("nanos"))
//                 if (!$util.isInteger(message.nanos))
//                     return "nanos: integer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Timestamp
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Timestamp} Timestamp
//          */
//         Timestamp.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Timestamp)
//                 return object;
//             let message = new $root.proto.Timestamp();
//             if (object.seconds != null)
//                 if ($util.Long)
//                     (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
//                 else if (typeof object.seconds === "string")
//                     message.seconds = parseInt(object.seconds, 10);
//                 else if (typeof object.seconds === "number")
//                     message.seconds = object.seconds;
//                 else if (typeof object.seconds === "object")
//                     message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
//             if (object.nanos != null)
//                 message.nanos = object.nanos | 0;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Timestamp
//          * @static
//          * @param {proto.Timestamp} message Timestamp
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Timestamp.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.seconds = options.longs === String ? "0" : 0;
//                 object.nanos = 0;
//             }
//             if (message.seconds != null && message.hasOwnProperty("seconds"))
//                 if (typeof message.seconds === "number")
//                     object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
//                 else
//                     object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
//             if (message.nanos != null && message.hasOwnProperty("nanos"))
//                 object.nanos = message.nanos;
//             return object;
//         };
// 
//         /**
//          * Converts this Timestamp to JSON.
//          * @function toJSON
//          * @memberof proto.Timestamp
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Timestamp.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Timestamp;
//     })();
// 
//     proto.TimestampSeconds = (function() {
// 
//         /**
//          * Properties of a TimestampSeconds.
//          * @memberof proto
//          * @interface ITimestampSeconds
//          * @property {number|Long|null} [seconds] TimestampSeconds seconds
//          */
// 
//         /**
//          * Constructs a new TimestampSeconds.
//          * @memberof proto
//          * @classdesc Represents a TimestampSeconds.
//          * @implements ITimestampSeconds
//          * @constructor
//          * @param {proto.ITimestampSeconds=} [properties] Properties to set
//          */
//         function TimestampSeconds(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TimestampSeconds seconds.
//          * @member {number|Long} seconds
//          * @memberof proto.TimestampSeconds
//          * @instance
//          */
//         TimestampSeconds.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new TimestampSeconds instance using the specified properties.
//          * @function create
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {proto.ITimestampSeconds=} [properties] Properties to set
//          * @returns {proto.TimestampSeconds} TimestampSeconds instance
//          */
//         TimestampSeconds.create = function create(properties) {
//             return new TimestampSeconds(properties);
//         };
// 
//         /**
//          * Encodes the specified TimestampSeconds message. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {proto.ITimestampSeconds} message TimestampSeconds message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TimestampSeconds.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TimestampSeconds message, length delimited. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {proto.ITimestampSeconds} message TimestampSeconds message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TimestampSeconds.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TimestampSeconds message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TimestampSeconds} TimestampSeconds
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TimestampSeconds.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TimestampSeconds();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.seconds = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TimestampSeconds message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TimestampSeconds} TimestampSeconds
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TimestampSeconds.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TimestampSeconds message.
//          * @function verify
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TimestampSeconds.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.seconds != null && message.hasOwnProperty("seconds"))
//                 if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
//                     return "seconds: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a TimestampSeconds message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TimestampSeconds} TimestampSeconds
//          */
//         TimestampSeconds.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TimestampSeconds)
//                 return object;
//             let message = new $root.proto.TimestampSeconds();
//             if (object.seconds != null)
//                 if ($util.Long)
//                     (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
//                 else if (typeof object.seconds === "string")
//                     message.seconds = parseInt(object.seconds, 10);
//                 else if (typeof object.seconds === "number")
//                     message.seconds = object.seconds;
//                 else if (typeof object.seconds === "object")
//                     message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TimestampSeconds message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TimestampSeconds
//          * @static
//          * @param {proto.TimestampSeconds} message TimestampSeconds
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TimestampSeconds.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.seconds = options.longs === String ? "0" : 0;
//             if (message.seconds != null && message.hasOwnProperty("seconds"))
//                 if (typeof message.seconds === "number")
//                     object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
//                 else
//                     object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
//             return object;
//         };
// 
//         /**
//          * Converts this TimestampSeconds to JSON.
//          * @function toJSON
//          * @memberof proto.TimestampSeconds
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TimestampSeconds.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TimestampSeconds;
//     })();
// 
//     proto.ConsensusCreateTopicTransactionBody = (function() {
// 
//         /**
//          * Properties of a ConsensusCreateTopicTransactionBody.
//          * @memberof proto
//          * @interface IConsensusCreateTopicTransactionBody
//          * @property {string|null} [memo] ConsensusCreateTopicTransactionBody memo
//          * @property {proto.IKey|null} [adminKey] ConsensusCreateTopicTransactionBody adminKey
//          * @property {proto.IKey|null} [submitKey] ConsensusCreateTopicTransactionBody submitKey
//          * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusCreateTopicTransactionBody autoRenewPeriod
//          * @property {proto.IAccountID|null} [autoRenewAccount] ConsensusCreateTopicTransactionBody autoRenewAccount
//          */
// 
//         /**
//          * Constructs a new ConsensusCreateTopicTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ConsensusCreateTopicTransactionBody.
//          * @implements IConsensusCreateTopicTransactionBody
//          * @constructor
//          * @param {proto.IConsensusCreateTopicTransactionBody=} [properties] Properties to set
//          */
//         function ConsensusCreateTopicTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusCreateTopicTransactionBody memo.
//          * @member {string} memo
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @instance
//          */
//         ConsensusCreateTopicTransactionBody.prototype.memo = "";
// 
//         /**
//          * ConsensusCreateTopicTransactionBody adminKey.
//          * @member {proto.IKey|null|undefined} adminKey
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @instance
//          */
//         ConsensusCreateTopicTransactionBody.prototype.adminKey = null;
// 
//         /**
//          * ConsensusCreateTopicTransactionBody submitKey.
//          * @member {proto.IKey|null|undefined} submitKey
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @instance
//          */
//         ConsensusCreateTopicTransactionBody.prototype.submitKey = null;
// 
//         /**
//          * ConsensusCreateTopicTransactionBody autoRenewPeriod.
//          * @member {proto.IDuration|null|undefined} autoRenewPeriod
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @instance
//          */
//         ConsensusCreateTopicTransactionBody.prototype.autoRenewPeriod = null;
// 
//         /**
//          * ConsensusCreateTopicTransactionBody autoRenewAccount.
//          * @member {proto.IAccountID|null|undefined} autoRenewAccount
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @instance
//          */
//         ConsensusCreateTopicTransactionBody.prototype.autoRenewAccount = null;
// 
//         /**
//          * Creates a new ConsensusCreateTopicTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusCreateTopicTransactionBody=} [properties] Properties to set
//          * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody instance
//          */
//         ConsensusCreateTopicTransactionBody.create = function create(properties) {
//             return new ConsensusCreateTopicTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusCreateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusCreateTopicTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusCreateTopicTransactionBody} message ConsensusCreateTopicTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusCreateTopicTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).string(message.memo);
//             if (message.adminKey != null && Object.hasOwnProperty.call(message, "adminKey"))
//                 $root.proto.Key.encode(message.adminKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.submitKey != null && Object.hasOwnProperty.call(message, "submitKey"))
//                 $root.proto.Key.encode(message.submitKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                 $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.autoRenewAccount != null && Object.hasOwnProperty.call(message, "autoRenewAccount"))
//                 $root.proto.AccountID.encode(message.autoRenewAccount, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusCreateTopicTransactionBody message, length delimited. Does not implicitly {@link proto.ConsensusCreateTopicTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusCreateTopicTransactionBody} message ConsensusCreateTopicTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusCreateTopicTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusCreateTopicTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusCreateTopicTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusCreateTopicTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.memo = reader.string();
//                     break;
//                 case 2:
//                     message.adminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.submitKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.autoRenewAccount = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusCreateTopicTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusCreateTopicTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusCreateTopicTransactionBody message.
//          * @function verify
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusCreateTopicTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 if (!$util.isString(message.memo))
//                     return "memo: string expected";
//             if (message.adminKey != null && message.hasOwnProperty("adminKey")) {
//                 let error = $root.proto.Key.verify(message.adminKey);
//                 if (error)
//                     return "adminKey." + error;
//             }
//             if (message.submitKey != null && message.hasOwnProperty("submitKey")) {
//                 let error = $root.proto.Key.verify(message.submitKey);
//                 if (error)
//                     return "submitKey." + error;
//             }
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                 let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                 if (error)
//                     return "autoRenewPeriod." + error;
//             }
//             if (message.autoRenewAccount != null && message.hasOwnProperty("autoRenewAccount")) {
//                 let error = $root.proto.AccountID.verify(message.autoRenewAccount);
//                 if (error)
//                     return "autoRenewAccount." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusCreateTopicTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody
//          */
//         ConsensusCreateTopicTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusCreateTopicTransactionBody)
//                 return object;
//             let message = new $root.proto.ConsensusCreateTopicTransactionBody();
//             if (object.memo != null)
//                 message.memo = String(object.memo);
//             if (object.adminKey != null) {
//                 if (typeof object.adminKey !== "object")
//                     throw TypeError(".proto.ConsensusCreateTopicTransactionBody.adminKey: object expected");
//                 message.adminKey = $root.proto.Key.fromObject(object.adminKey);
//             }
//             if (object.submitKey != null) {
//                 if (typeof object.submitKey !== "object")
//                     throw TypeError(".proto.ConsensusCreateTopicTransactionBody.submitKey: object expected");
//                 message.submitKey = $root.proto.Key.fromObject(object.submitKey);
//             }
//             if (object.autoRenewPeriod != null) {
//                 if (typeof object.autoRenewPeriod !== "object")
//                     throw TypeError(".proto.ConsensusCreateTopicTransactionBody.autoRenewPeriod: object expected");
//                 message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//             }
//             if (object.autoRenewAccount != null) {
//                 if (typeof object.autoRenewAccount !== "object")
//                     throw TypeError(".proto.ConsensusCreateTopicTransactionBody.autoRenewAccount: object expected");
//                 message.autoRenewAccount = $root.proto.AccountID.fromObject(object.autoRenewAccount);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusCreateTopicTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @static
//          * @param {proto.ConsensusCreateTopicTransactionBody} message ConsensusCreateTopicTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusCreateTopicTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.memo = "";
//                 object.adminKey = null;
//                 object.submitKey = null;
//                 object.autoRenewPeriod = null;
//                 object.autoRenewAccount = null;
//             }
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = message.memo;
//             if (message.adminKey != null && message.hasOwnProperty("adminKey"))
//                 object.adminKey = $root.proto.Key.toObject(message.adminKey, options);
//             if (message.submitKey != null && message.hasOwnProperty("submitKey"))
//                 object.submitKey = $root.proto.Key.toObject(message.submitKey, options);
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                 object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//             if (message.autoRenewAccount != null && message.hasOwnProperty("autoRenewAccount"))
//                 object.autoRenewAccount = $root.proto.AccountID.toObject(message.autoRenewAccount, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusCreateTopicTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusCreateTopicTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusCreateTopicTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusCreateTopicTransactionBody;
//     })();
// 
//     proto.Duration = (function() {
// 
//         /**
//          * Properties of a Duration.
//          * @memberof proto
//          * @interface IDuration
//          * @property {number|Long|null} [seconds] Duration seconds
//          */
// 
//         /**
//          * Constructs a new Duration.
//          * @memberof proto
//          * @classdesc Represents a Duration.
//          * @implements IDuration
//          * @constructor
//          * @param {proto.IDuration=} [properties] Properties to set
//          */
//         function Duration(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Duration seconds.
//          * @member {number|Long} seconds
//          * @memberof proto.Duration
//          * @instance
//          */
//         Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new Duration instance using the specified properties.
//          * @function create
//          * @memberof proto.Duration
//          * @static
//          * @param {proto.IDuration=} [properties] Properties to set
//          * @returns {proto.Duration} Duration instance
//          */
//         Duration.create = function create(properties) {
//             return new Duration(properties);
//         };
// 
//         /**
//          * Encodes the specified Duration message. Does not implicitly {@link proto.Duration.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Duration
//          * @static
//          * @param {proto.IDuration} message Duration message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Duration.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Duration message, length delimited. Does not implicitly {@link proto.Duration.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Duration
//          * @static
//          * @param {proto.IDuration} message Duration message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Duration.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Duration message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Duration
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Duration} Duration
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Duration.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Duration();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.seconds = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Duration message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Duration
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Duration} Duration
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Duration.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Duration message.
//          * @function verify
//          * @memberof proto.Duration
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Duration.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.seconds != null && message.hasOwnProperty("seconds"))
//                 if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
//                     return "seconds: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a Duration message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Duration
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Duration} Duration
//          */
//         Duration.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Duration)
//                 return object;
//             let message = new $root.proto.Duration();
//             if (object.seconds != null)
//                 if ($util.Long)
//                     (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
//                 else if (typeof object.seconds === "string")
//                     message.seconds = parseInt(object.seconds, 10);
//                 else if (typeof object.seconds === "number")
//                     message.seconds = object.seconds;
//                 else if (typeof object.seconds === "object")
//                     message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Duration message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Duration
//          * @static
//          * @param {proto.Duration} message Duration
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Duration.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.seconds = options.longs === String ? "0" : 0;
//             if (message.seconds != null && message.hasOwnProperty("seconds"))
//                 if (typeof message.seconds === "number")
//                     object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
//                 else
//                     object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
//             return object;
//         };
// 
//         /**
//          * Converts this Duration to JSON.
//          * @function toJSON
//          * @memberof proto.Duration
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Duration.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Duration;
//     })();
// 
//     proto.ConsensusDeleteTopicTransactionBody = (function() {
// 
//         /**
//          * Properties of a ConsensusDeleteTopicTransactionBody.
//          * @memberof proto
//          * @interface IConsensusDeleteTopicTransactionBody
//          * @property {proto.ITopicID|null} [topicID] ConsensusDeleteTopicTransactionBody topicID
//          */
// 
//         /**
//          * Constructs a new ConsensusDeleteTopicTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ConsensusDeleteTopicTransactionBody.
//          * @implements IConsensusDeleteTopicTransactionBody
//          * @constructor
//          * @param {proto.IConsensusDeleteTopicTransactionBody=} [properties] Properties to set
//          */
//         function ConsensusDeleteTopicTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusDeleteTopicTransactionBody topicID.
//          * @member {proto.ITopicID|null|undefined} topicID
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @instance
//          */
//         ConsensusDeleteTopicTransactionBody.prototype.topicID = null;
// 
//         /**
//          * Creates a new ConsensusDeleteTopicTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusDeleteTopicTransactionBody=} [properties] Properties to set
//          * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody instance
//          */
//         ConsensusDeleteTopicTransactionBody.create = function create(properties) {
//             return new ConsensusDeleteTopicTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusDeleteTopicTransactionBody message. Does not implicitly {@link proto.ConsensusDeleteTopicTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusDeleteTopicTransactionBody} message ConsensusDeleteTopicTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusDeleteTopicTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.topicID != null && Object.hasOwnProperty.call(message, "topicID"))
//                 $root.proto.TopicID.encode(message.topicID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusDeleteTopicTransactionBody message, length delimited. Does not implicitly {@link proto.ConsensusDeleteTopicTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusDeleteTopicTransactionBody} message ConsensusDeleteTopicTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusDeleteTopicTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusDeleteTopicTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusDeleteTopicTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusDeleteTopicTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.topicID = $root.proto.TopicID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusDeleteTopicTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusDeleteTopicTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusDeleteTopicTransactionBody message.
//          * @function verify
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusDeleteTopicTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.topicID != null && message.hasOwnProperty("topicID")) {
//                 let error = $root.proto.TopicID.verify(message.topicID);
//                 if (error)
//                     return "topicID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusDeleteTopicTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody
//          */
//         ConsensusDeleteTopicTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusDeleteTopicTransactionBody)
//                 return object;
//             let message = new $root.proto.ConsensusDeleteTopicTransactionBody();
//             if (object.topicID != null) {
//                 if (typeof object.topicID !== "object")
//                     throw TypeError(".proto.ConsensusDeleteTopicTransactionBody.topicID: object expected");
//                 message.topicID = $root.proto.TopicID.fromObject(object.topicID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusDeleteTopicTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @static
//          * @param {proto.ConsensusDeleteTopicTransactionBody} message ConsensusDeleteTopicTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusDeleteTopicTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.topicID = null;
//             if (message.topicID != null && message.hasOwnProperty("topicID"))
//                 object.topicID = $root.proto.TopicID.toObject(message.topicID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusDeleteTopicTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusDeleteTopicTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusDeleteTopicTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusDeleteTopicTransactionBody;
//     })();
// 
//     proto.ConsensusGetTopicInfoQuery = (function() {
// 
//         /**
//          * Properties of a ConsensusGetTopicInfoQuery.
//          * @memberof proto
//          * @interface IConsensusGetTopicInfoQuery
//          * @property {proto.IQueryHeader|null} [header] ConsensusGetTopicInfoQuery header
//          * @property {proto.ITopicID|null} [topicID] ConsensusGetTopicInfoQuery topicID
//          */
// 
//         /**
//          * Constructs a new ConsensusGetTopicInfoQuery.
//          * @memberof proto
//          * @classdesc Represents a ConsensusGetTopicInfoQuery.
//          * @implements IConsensusGetTopicInfoQuery
//          * @constructor
//          * @param {proto.IConsensusGetTopicInfoQuery=} [properties] Properties to set
//          */
//         function ConsensusGetTopicInfoQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusGetTopicInfoQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @instance
//          */
//         ConsensusGetTopicInfoQuery.prototype.header = null;
// 
//         /**
//          * ConsensusGetTopicInfoQuery topicID.
//          * @member {proto.ITopicID|null|undefined} topicID
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @instance
//          */
//         ConsensusGetTopicInfoQuery.prototype.topicID = null;
// 
//         /**
//          * Creates a new ConsensusGetTopicInfoQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {proto.IConsensusGetTopicInfoQuery=} [properties] Properties to set
//          * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery instance
//          */
//         ConsensusGetTopicInfoQuery.create = function create(properties) {
//             return new ConsensusGetTopicInfoQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusGetTopicInfoQuery message. Does not implicitly {@link proto.ConsensusGetTopicInfoQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {proto.IConsensusGetTopicInfoQuery} message ConsensusGetTopicInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusGetTopicInfoQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.topicID != null && Object.hasOwnProperty.call(message, "topicID"))
//                 $root.proto.TopicID.encode(message.topicID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusGetTopicInfoQuery message, length delimited. Does not implicitly {@link proto.ConsensusGetTopicInfoQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {proto.IConsensusGetTopicInfoQuery} message ConsensusGetTopicInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusGetTopicInfoQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusGetTopicInfoQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusGetTopicInfoQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusGetTopicInfoQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.topicID = $root.proto.TopicID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusGetTopicInfoQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusGetTopicInfoQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusGetTopicInfoQuery message.
//          * @function verify
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusGetTopicInfoQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.topicID != null && message.hasOwnProperty("topicID")) {
//                 let error = $root.proto.TopicID.verify(message.topicID);
//                 if (error)
//                     return "topicID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusGetTopicInfoQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery
//          */
//         ConsensusGetTopicInfoQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusGetTopicInfoQuery)
//                 return object;
//             let message = new $root.proto.ConsensusGetTopicInfoQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ConsensusGetTopicInfoQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.topicID != null) {
//                 if (typeof object.topicID !== "object")
//                     throw TypeError(".proto.ConsensusGetTopicInfoQuery.topicID: object expected");
//                 message.topicID = $root.proto.TopicID.fromObject(object.topicID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusGetTopicInfoQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @static
//          * @param {proto.ConsensusGetTopicInfoQuery} message ConsensusGetTopicInfoQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusGetTopicInfoQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.topicID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.topicID != null && message.hasOwnProperty("topicID"))
//                 object.topicID = $root.proto.TopicID.toObject(message.topicID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusGetTopicInfoQuery to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusGetTopicInfoQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusGetTopicInfoQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusGetTopicInfoQuery;
//     })();
// 
//     proto.ConsensusGetTopicInfoResponse = (function() {
// 
//         /**
//          * Properties of a ConsensusGetTopicInfoResponse.
//          * @memberof proto
//          * @interface IConsensusGetTopicInfoResponse
//          * @property {proto.IResponseHeader|null} [header] ConsensusGetTopicInfoResponse header
//          * @property {proto.ITopicID|null} [topicID] ConsensusGetTopicInfoResponse topicID
//          * @property {proto.IConsensusTopicInfo|null} [topicInfo] ConsensusGetTopicInfoResponse topicInfo
//          */
// 
//         /**
//          * Constructs a new ConsensusGetTopicInfoResponse.
//          * @memberof proto
//          * @classdesc Represents a ConsensusGetTopicInfoResponse.
//          * @implements IConsensusGetTopicInfoResponse
//          * @constructor
//          * @param {proto.IConsensusGetTopicInfoResponse=} [properties] Properties to set
//          */
//         function ConsensusGetTopicInfoResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusGetTopicInfoResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @instance
//          */
//         ConsensusGetTopicInfoResponse.prototype.header = null;
// 
//         /**
//          * ConsensusGetTopicInfoResponse topicID.
//          * @member {proto.ITopicID|null|undefined} topicID
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @instance
//          */
//         ConsensusGetTopicInfoResponse.prototype.topicID = null;
// 
//         /**
//          * ConsensusGetTopicInfoResponse topicInfo.
//          * @member {proto.IConsensusTopicInfo|null|undefined} topicInfo
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @instance
//          */
//         ConsensusGetTopicInfoResponse.prototype.topicInfo = null;
// 
//         /**
//          * Creates a new ConsensusGetTopicInfoResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {proto.IConsensusGetTopicInfoResponse=} [properties] Properties to set
//          * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse instance
//          */
//         ConsensusGetTopicInfoResponse.create = function create(properties) {
//             return new ConsensusGetTopicInfoResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusGetTopicInfoResponse message. Does not implicitly {@link proto.ConsensusGetTopicInfoResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {proto.IConsensusGetTopicInfoResponse} message ConsensusGetTopicInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusGetTopicInfoResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.topicID != null && Object.hasOwnProperty.call(message, "topicID"))
//                 $root.proto.TopicID.encode(message.topicID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.topicInfo != null && Object.hasOwnProperty.call(message, "topicInfo"))
//                 $root.proto.ConsensusTopicInfo.encode(message.topicInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusGetTopicInfoResponse message, length delimited. Does not implicitly {@link proto.ConsensusGetTopicInfoResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {proto.IConsensusGetTopicInfoResponse} message ConsensusGetTopicInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusGetTopicInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusGetTopicInfoResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusGetTopicInfoResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusGetTopicInfoResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.topicID = $root.proto.TopicID.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.topicInfo = $root.proto.ConsensusTopicInfo.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusGetTopicInfoResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusGetTopicInfoResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusGetTopicInfoResponse message.
//          * @function verify
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusGetTopicInfoResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.topicID != null && message.hasOwnProperty("topicID")) {
//                 let error = $root.proto.TopicID.verify(message.topicID);
//                 if (error)
//                     return "topicID." + error;
//             }
//             if (message.topicInfo != null && message.hasOwnProperty("topicInfo")) {
//                 let error = $root.proto.ConsensusTopicInfo.verify(message.topicInfo);
//                 if (error)
//                     return "topicInfo." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusGetTopicInfoResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse
//          */
//         ConsensusGetTopicInfoResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusGetTopicInfoResponse)
//                 return object;
//             let message = new $root.proto.ConsensusGetTopicInfoResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ConsensusGetTopicInfoResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.topicID != null) {
//                 if (typeof object.topicID !== "object")
//                     throw TypeError(".proto.ConsensusGetTopicInfoResponse.topicID: object expected");
//                 message.topicID = $root.proto.TopicID.fromObject(object.topicID);
//             }
//             if (object.topicInfo != null) {
//                 if (typeof object.topicInfo !== "object")
//                     throw TypeError(".proto.ConsensusGetTopicInfoResponse.topicInfo: object expected");
//                 message.topicInfo = $root.proto.ConsensusTopicInfo.fromObject(object.topicInfo);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusGetTopicInfoResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @static
//          * @param {proto.ConsensusGetTopicInfoResponse} message ConsensusGetTopicInfoResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusGetTopicInfoResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.topicID = null;
//                 object.topicInfo = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.topicID != null && message.hasOwnProperty("topicID"))
//                 object.topicID = $root.proto.TopicID.toObject(message.topicID, options);
//             if (message.topicInfo != null && message.hasOwnProperty("topicInfo"))
//                 object.topicInfo = $root.proto.ConsensusTopicInfo.toObject(message.topicInfo, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusGetTopicInfoResponse to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusGetTopicInfoResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusGetTopicInfoResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusGetTopicInfoResponse;
//     })();
// 
//     /**
//      * ResponseType enum.
//      * @name proto.ResponseType
//      * @enum {number}
//      * @property {number} ANSWER_ONLY=0 ANSWER_ONLY value
//      * @property {number} ANSWER_STATE_PROOF=1 ANSWER_STATE_PROOF value
//      * @property {number} COST_ANSWER=2 COST_ANSWER value
//      * @property {number} COST_ANSWER_STATE_PROOF=3 COST_ANSWER_STATE_PROOF value
//      */
//     proto.ResponseType = (function() {
//         const valuesById = {}, values = Object.create(valuesById);
//         values[valuesById[0] = "ANSWER_ONLY"] = 0;
//         values[valuesById[1] = "ANSWER_STATE_PROOF"] = 1;
//         values[valuesById[2] = "COST_ANSWER"] = 2;
//         values[valuesById[3] = "COST_ANSWER_STATE_PROOF"] = 3;
//         return values;
//     })();
// 
//     proto.QueryHeader = (function() {
// 
//         /**
//          * Properties of a QueryHeader.
//          * @memberof proto
//          * @interface IQueryHeader
//          * @property {proto.ITransaction|null} [payment] QueryHeader payment
//          * @property {proto.ResponseType|null} [responseType] QueryHeader responseType
//          */
// 
//         /**
//          * Constructs a new QueryHeader.
//          * @memberof proto
//          * @classdesc Represents a QueryHeader.
//          * @implements IQueryHeader
//          * @constructor
//          * @param {proto.IQueryHeader=} [properties] Properties to set
//          */
//         function QueryHeader(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * QueryHeader payment.
//          * @member {proto.ITransaction|null|undefined} payment
//          * @memberof proto.QueryHeader
//          * @instance
//          */
//         QueryHeader.prototype.payment = null;
// 
//         /**
//          * QueryHeader responseType.
//          * @member {proto.ResponseType} responseType
//          * @memberof proto.QueryHeader
//          * @instance
//          */
//         QueryHeader.prototype.responseType = 0;
// 
//         /**
//          * Creates a new QueryHeader instance using the specified properties.
//          * @function create
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {proto.IQueryHeader=} [properties] Properties to set
//          * @returns {proto.QueryHeader} QueryHeader instance
//          */
//         QueryHeader.create = function create(properties) {
//             return new QueryHeader(properties);
//         };
// 
//         /**
//          * Encodes the specified QueryHeader message. Does not implicitly {@link proto.QueryHeader.verify|verify} messages.
//          * @function encode
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {proto.IQueryHeader} message QueryHeader message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         QueryHeader.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.payment != null && Object.hasOwnProperty.call(message, "payment"))
//                 $root.proto.Transaction.encode(message.payment, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.responseType != null && Object.hasOwnProperty.call(message, "responseType"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.responseType);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified QueryHeader message, length delimited. Does not implicitly {@link proto.QueryHeader.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {proto.IQueryHeader} message QueryHeader message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         QueryHeader.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a QueryHeader message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.QueryHeader} QueryHeader
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         QueryHeader.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QueryHeader();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.payment = $root.proto.Transaction.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.responseType = reader.int32();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a QueryHeader message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.QueryHeader} QueryHeader
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         QueryHeader.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a QueryHeader message.
//          * @function verify
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         QueryHeader.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.payment != null && message.hasOwnProperty("payment")) {
//                 let error = $root.proto.Transaction.verify(message.payment);
//                 if (error)
//                     return "payment." + error;
//             }
//             if (message.responseType != null && message.hasOwnProperty("responseType"))
//                 switch (message.responseType) {
//                 default:
//                     return "responseType: enum value expected";
//                 case 0:
//                 case 1:
//                 case 2:
//                 case 3:
//                     break;
//                 }
//             return null;
//         };
// 
//         /**
//          * Creates a QueryHeader message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.QueryHeader} QueryHeader
//          */
//         QueryHeader.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.QueryHeader)
//                 return object;
//             let message = new $root.proto.QueryHeader();
//             if (object.payment != null) {
//                 if (typeof object.payment !== "object")
//                     throw TypeError(".proto.QueryHeader.payment: object expected");
//                 message.payment = $root.proto.Transaction.fromObject(object.payment);
//             }
//             switch (object.responseType) {
//             case "ANSWER_ONLY":
//             case 0:
//                 message.responseType = 0;
//                 break;
//             case "ANSWER_STATE_PROOF":
//             case 1:
//                 message.responseType = 1;
//                 break;
//             case "COST_ANSWER":
//             case 2:
//                 message.responseType = 2;
//                 break;
//             case "COST_ANSWER_STATE_PROOF":
//             case 3:
//                 message.responseType = 3;
//                 break;
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a QueryHeader message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.QueryHeader
//          * @static
//          * @param {proto.QueryHeader} message QueryHeader
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         QueryHeader.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.payment = null;
//                 object.responseType = options.enums === String ? "ANSWER_ONLY" : 0;
//             }
//             if (message.payment != null && message.hasOwnProperty("payment"))
//                 object.payment = $root.proto.Transaction.toObject(message.payment, options);
//             if (message.responseType != null && message.hasOwnProperty("responseType"))
//                 object.responseType = options.enums === String ? $root.proto.ResponseType[message.responseType] : message.responseType;
//             return object;
//         };
// 
//         /**
//          * Converts this QueryHeader to JSON.
//          * @function toJSON
//          * @memberof proto.QueryHeader
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         QueryHeader.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return QueryHeader;
//     })();
// 
//     proto.Transaction = (function() {
// 
//         /**
//          * Properties of a Transaction.
//          * @memberof proto
//          * @interface ITransaction
//          * @property {proto.ITransactionBody|null} [body] Transaction body
//          * @property {Uint8Array|null} [bodyBytes] Transaction bodyBytes
//          * @property {proto.ISignatureList|null} [sigs] Transaction sigs
//          * @property {proto.ISignatureMap|null} [sigMap] Transaction sigMap
//          */
// 
//         /**
//          * Constructs a new Transaction.
//          * @memberof proto
//          * @classdesc Represents a Transaction.
//          * @implements ITransaction
//          * @constructor
//          * @param {proto.ITransaction=} [properties] Properties to set
//          */
//         function Transaction(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Transaction body.
//          * @member {proto.ITransactionBody|null|undefined} body
//          * @memberof proto.Transaction
//          * @instance
//          */
//         Transaction.prototype.body = null;
// 
//         /**
//          * Transaction bodyBytes.
//          * @member {Uint8Array} bodyBytes
//          * @memberof proto.Transaction
//          * @instance
//          */
//         Transaction.prototype.bodyBytes = $util.newBuffer([]);
// 
//         /**
//          * Transaction sigs.
//          * @member {proto.ISignatureList|null|undefined} sigs
//          * @memberof proto.Transaction
//          * @instance
//          */
//         Transaction.prototype.sigs = null;
// 
//         /**
//          * Transaction sigMap.
//          * @member {proto.ISignatureMap|null|undefined} sigMap
//          * @memberof proto.Transaction
//          * @instance
//          */
//         Transaction.prototype.sigMap = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * Transaction bodyData.
//          * @member {"body"|"bodyBytes"|undefined} bodyData
//          * @memberof proto.Transaction
//          * @instance
//          */
//         Object.defineProperty(Transaction.prototype, "bodyData", {
//             get: $util.oneOfGetter($oneOfFields = ["body", "bodyBytes"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new Transaction instance using the specified properties.
//          * @function create
//          * @memberof proto.Transaction
//          * @static
//          * @param {proto.ITransaction=} [properties] Properties to set
//          * @returns {proto.Transaction} Transaction instance
//          */
//         Transaction.create = function create(properties) {
//             return new Transaction(properties);
//         };
// 
//         /**
//          * Encodes the specified Transaction message. Does not implicitly {@link proto.Transaction.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Transaction
//          * @static
//          * @param {proto.ITransaction} message Transaction message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Transaction.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.body != null && Object.hasOwnProperty.call(message, "body"))
//                 $root.proto.TransactionBody.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.sigs != null && Object.hasOwnProperty.call(message, "sigs"))
//                 $root.proto.SignatureList.encode(message.sigs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.sigMap != null && Object.hasOwnProperty.call(message, "sigMap"))
//                 $root.proto.SignatureMap.encode(message.sigMap, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.bodyBytes != null && Object.hasOwnProperty.call(message, "bodyBytes"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bodyBytes);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Transaction message, length delimited. Does not implicitly {@link proto.Transaction.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Transaction
//          * @static
//          * @param {proto.ITransaction} message Transaction message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Transaction.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Transaction message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Transaction
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Transaction} Transaction
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Transaction.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Transaction();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.body = $root.proto.TransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.bodyBytes = reader.bytes();
//                     break;
//                 case 2:
//                     message.sigs = $root.proto.SignatureList.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.sigMap = $root.proto.SignatureMap.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Transaction message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Transaction
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Transaction} Transaction
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Transaction.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Transaction message.
//          * @function verify
//          * @memberof proto.Transaction
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Transaction.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.body != null && message.hasOwnProperty("body")) {
//                 properties.bodyData = 1;
//                 {
//                     let error = $root.proto.TransactionBody.verify(message.body);
//                     if (error)
//                         return "body." + error;
//                 }
//             }
//             if (message.bodyBytes != null && message.hasOwnProperty("bodyBytes")) {
//                 if (properties.bodyData === 1)
//                     return "bodyData: multiple values";
//                 properties.bodyData = 1;
//                 if (!(message.bodyBytes && typeof message.bodyBytes.length === "number" || $util.isString(message.bodyBytes)))
//                     return "bodyBytes: buffer expected";
//             }
//             if (message.sigs != null && message.hasOwnProperty("sigs")) {
//                 let error = $root.proto.SignatureList.verify(message.sigs);
//                 if (error)
//                     return "sigs." + error;
//             }
//             if (message.sigMap != null && message.hasOwnProperty("sigMap")) {
//                 let error = $root.proto.SignatureMap.verify(message.sigMap);
//                 if (error)
//                     return "sigMap." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Transaction
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Transaction} Transaction
//          */
//         Transaction.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Transaction)
//                 return object;
//             let message = new $root.proto.Transaction();
//             if (object.body != null) {
//                 if (typeof object.body !== "object")
//                     throw TypeError(".proto.Transaction.body: object expected");
//                 message.body = $root.proto.TransactionBody.fromObject(object.body);
//             }
//             if (object.bodyBytes != null)
//                 if (typeof object.bodyBytes === "string")
//                     $util.base64.decode(object.bodyBytes, message.bodyBytes = $util.newBuffer($util.base64.length(object.bodyBytes)), 0);
//                 else if (object.bodyBytes.length)
//                     message.bodyBytes = object.bodyBytes;
//             if (object.sigs != null) {
//                 if (typeof object.sigs !== "object")
//                     throw TypeError(".proto.Transaction.sigs: object expected");
//                 message.sigs = $root.proto.SignatureList.fromObject(object.sigs);
//             }
//             if (object.sigMap != null) {
//                 if (typeof object.sigMap !== "object")
//                     throw TypeError(".proto.Transaction.sigMap: object expected");
//                 message.sigMap = $root.proto.SignatureMap.fromObject(object.sigMap);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Transaction message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Transaction
//          * @static
//          * @param {proto.Transaction} message Transaction
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Transaction.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.sigs = null;
//                 object.sigMap = null;
//             }
//             if (message.body != null && message.hasOwnProperty("body")) {
//                 object.body = $root.proto.TransactionBody.toObject(message.body, options);
//                 if (options.oneofs)
//                     object.bodyData = "body";
//             }
//             if (message.sigs != null && message.hasOwnProperty("sigs"))
//                 object.sigs = $root.proto.SignatureList.toObject(message.sigs, options);
//             if (message.sigMap != null && message.hasOwnProperty("sigMap"))
//                 object.sigMap = $root.proto.SignatureMap.toObject(message.sigMap, options);
//             if (message.bodyBytes != null && message.hasOwnProperty("bodyBytes")) {
//                 object.bodyBytes = options.bytes === String ? $util.base64.encode(message.bodyBytes, 0, message.bodyBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.bodyBytes) : message.bodyBytes;
//                 if (options.oneofs)
//                     object.bodyData = "bodyBytes";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this Transaction to JSON.
//          * @function toJSON
//          * @memberof proto.Transaction
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Transaction.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Transaction;
//     })();
// 
//     proto.TransactionBody = (function() {
// 
//         /**
//          * Properties of a TransactionBody.
//          * @memberof proto
//          * @interface ITransactionBody
//          * @property {proto.ITransactionID|null} [transactionID] TransactionBody transactionID
//          * @property {proto.IAccountID|null} [nodeAccountID] TransactionBody nodeAccountID
//          * @property {number|Long|null} [transactionFee] TransactionBody transactionFee
//          * @property {proto.IDuration|null} [transactionValidDuration] TransactionBody transactionValidDuration
//          * @property {boolean|null} [generateRecord] TransactionBody generateRecord
//          * @property {string|null} [memo] TransactionBody memo
//          * @property {proto.IContractCallTransactionBody|null} [contractCall] TransactionBody contractCall
//          * @property {proto.IContractCreateTransactionBody|null} [contractCreateInstance] TransactionBody contractCreateInstance
//          * @property {proto.IContractUpdateTransactionBody|null} [contractUpdateInstance] TransactionBody contractUpdateInstance
//          * @property {proto.IContractDeleteTransactionBody|null} [contractDeleteInstance] TransactionBody contractDeleteInstance
//          * @property {proto.ICryptoAddLiveHashTransactionBody|null} [cryptoAddLiveHash] TransactionBody cryptoAddLiveHash
//          * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] TransactionBody cryptoCreateAccount
//          * @property {proto.ICryptoDeleteTransactionBody|null} [cryptoDelete] TransactionBody cryptoDelete
//          * @property {proto.ICryptoDeleteLiveHashTransactionBody|null} [cryptoDeleteLiveHash] TransactionBody cryptoDeleteLiveHash
//          * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] TransactionBody cryptoTransfer
//          * @property {proto.ICryptoUpdateTransactionBody|null} [cryptoUpdateAccount] TransactionBody cryptoUpdateAccount
//          * @property {proto.IFileAppendTransactionBody|null} [fileAppend] TransactionBody fileAppend
//          * @property {proto.IFileCreateTransactionBody|null} [fileCreate] TransactionBody fileCreate
//          * @property {proto.IFileDeleteTransactionBody|null} [fileDelete] TransactionBody fileDelete
//          * @property {proto.IFileUpdateTransactionBody|null} [fileUpdate] TransactionBody fileUpdate
//          * @property {proto.ISystemDeleteTransactionBody|null} [systemDelete] TransactionBody systemDelete
//          * @property {proto.ISystemUndeleteTransactionBody|null} [systemUndelete] TransactionBody systemUndelete
//          * @property {proto.IFreezeTransactionBody|null} [freeze] TransactionBody freeze
//          * @property {proto.IConsensusCreateTopicTransactionBody|null} [consensusCreateTopic] TransactionBody consensusCreateTopic
//          * @property {proto.IConsensusUpdateTopicTransactionBody|null} [consensusUpdateTopic] TransactionBody consensusUpdateTopic
//          * @property {proto.IConsensusDeleteTopicTransactionBody|null} [consensusDeleteTopic] TransactionBody consensusDeleteTopic
//          * @property {proto.IConsensusSubmitMessageTransactionBody|null} [consensusSubmitMessage] TransactionBody consensusSubmitMessage
//          */
// 
//         /**
//          * Constructs a new TransactionBody.
//          * @memberof proto
//          * @classdesc Represents a TransactionBody.
//          * @implements ITransactionBody
//          * @constructor
//          * @param {proto.ITransactionBody=} [properties] Properties to set
//          */
//         function TransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionBody transactionID.
//          * @member {proto.ITransactionID|null|undefined} transactionID
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.transactionID = null;
// 
//         /**
//          * TransactionBody nodeAccountID.
//          * @member {proto.IAccountID|null|undefined} nodeAccountID
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.nodeAccountID = null;
// 
//         /**
//          * TransactionBody transactionFee.
//          * @member {number|Long} transactionFee
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * TransactionBody transactionValidDuration.
//          * @member {proto.IDuration|null|undefined} transactionValidDuration
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.transactionValidDuration = null;
// 
//         /**
//          * TransactionBody generateRecord.
//          * @member {boolean} generateRecord
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.generateRecord = false;
// 
//         /**
//          * TransactionBody memo.
//          * @member {string} memo
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.memo = "";
// 
//         /**
//          * TransactionBody contractCall.
//          * @member {proto.IContractCallTransactionBody|null|undefined} contractCall
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.contractCall = null;
// 
//         /**
//          * TransactionBody contractCreateInstance.
//          * @member {proto.IContractCreateTransactionBody|null|undefined} contractCreateInstance
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.contractCreateInstance = null;
// 
//         /**
//          * TransactionBody contractUpdateInstance.
//          * @member {proto.IContractUpdateTransactionBody|null|undefined} contractUpdateInstance
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.contractUpdateInstance = null;
// 
//         /**
//          * TransactionBody contractDeleteInstance.
//          * @member {proto.IContractDeleteTransactionBody|null|undefined} contractDeleteInstance
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.contractDeleteInstance = null;
// 
//         /**
//          * TransactionBody cryptoAddLiveHash.
//          * @member {proto.ICryptoAddLiveHashTransactionBody|null|undefined} cryptoAddLiveHash
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.cryptoAddLiveHash = null;
// 
//         /**
//          * TransactionBody cryptoCreateAccount.
//          * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.cryptoCreateAccount = null;
// 
//         /**
//          * TransactionBody cryptoDelete.
//          * @member {proto.ICryptoDeleteTransactionBody|null|undefined} cryptoDelete
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.cryptoDelete = null;
// 
//         /**
//          * TransactionBody cryptoDeleteLiveHash.
//          * @member {proto.ICryptoDeleteLiveHashTransactionBody|null|undefined} cryptoDeleteLiveHash
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.cryptoDeleteLiveHash = null;
// 
//         /**
//          * TransactionBody cryptoTransfer.
//          * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.cryptoTransfer = null;
// 
//         /**
//          * TransactionBody cryptoUpdateAccount.
//          * @member {proto.ICryptoUpdateTransactionBody|null|undefined} cryptoUpdateAccount
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.cryptoUpdateAccount = null;
// 
//         /**
//          * TransactionBody fileAppend.
//          * @member {proto.IFileAppendTransactionBody|null|undefined} fileAppend
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.fileAppend = null;
// 
//         /**
//          * TransactionBody fileCreate.
//          * @member {proto.IFileCreateTransactionBody|null|undefined} fileCreate
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.fileCreate = null;
// 
//         /**
//          * TransactionBody fileDelete.
//          * @member {proto.IFileDeleteTransactionBody|null|undefined} fileDelete
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.fileDelete = null;
// 
//         /**
//          * TransactionBody fileUpdate.
//          * @member {proto.IFileUpdateTransactionBody|null|undefined} fileUpdate
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.fileUpdate = null;
// 
//         /**
//          * TransactionBody systemDelete.
//          * @member {proto.ISystemDeleteTransactionBody|null|undefined} systemDelete
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.systemDelete = null;
// 
//         /**
//          * TransactionBody systemUndelete.
//          * @member {proto.ISystemUndeleteTransactionBody|null|undefined} systemUndelete
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.systemUndelete = null;
// 
//         /**
//          * TransactionBody freeze.
//          * @member {proto.IFreezeTransactionBody|null|undefined} freeze
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.freeze = null;
// 
//         /**
//          * TransactionBody consensusCreateTopic.
//          * @member {proto.IConsensusCreateTopicTransactionBody|null|undefined} consensusCreateTopic
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.consensusCreateTopic = null;
// 
//         /**
//          * TransactionBody consensusUpdateTopic.
//          * @member {proto.IConsensusUpdateTopicTransactionBody|null|undefined} consensusUpdateTopic
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.consensusUpdateTopic = null;
// 
//         /**
//          * TransactionBody consensusDeleteTopic.
//          * @member {proto.IConsensusDeleteTopicTransactionBody|null|undefined} consensusDeleteTopic
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.consensusDeleteTopic = null;
// 
//         /**
//          * TransactionBody consensusSubmitMessage.
//          * @member {proto.IConsensusSubmitMessageTransactionBody|null|undefined} consensusSubmitMessage
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         TransactionBody.prototype.consensusSubmitMessage = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * TransactionBody data.
//          * @member {"contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"cryptoAddLiveHash"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoDeleteLiveHash"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|undefined} data
//          * @memberof proto.TransactionBody
//          * @instance
//          */
//         Object.defineProperty(TransactionBody.prototype, "data", {
//             get: $util.oneOfGetter($oneOfFields = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoAddLiveHash", "cryptoCreateAccount", "cryptoDelete", "cryptoDeleteLiveHash", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new TransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {proto.ITransactionBody=} [properties] Properties to set
//          * @returns {proto.TransactionBody} TransactionBody instance
//          */
//         TransactionBody.create = function create(properties) {
//             return new TransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionBody message. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {proto.ITransactionBody} message TransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.transactionID != null && Object.hasOwnProperty.call(message, "transactionID"))
//                 $root.proto.TransactionID.encode(message.transactionID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.nodeAccountID != null && Object.hasOwnProperty.call(message, "nodeAccountID"))
//                 $root.proto.AccountID.encode(message.nodeAccountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.transactionFee != null && Object.hasOwnProperty.call(message, "transactionFee"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.transactionFee);
//             if (message.transactionValidDuration != null && Object.hasOwnProperty.call(message, "transactionValidDuration"))
//                 $root.proto.Duration.encode(message.transactionValidDuration, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.generateRecord != null && Object.hasOwnProperty.call(message, "generateRecord"))
//                 writer.uint32(/* id 5, wireType 0 =*/40).bool(message.generateRecord);
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 writer.uint32(/* id 6, wireType 2 =*/50).string(message.memo);
//             if (message.contractCall != null && Object.hasOwnProperty.call(message, "contractCall"))
//                 $root.proto.ContractCallTransactionBody.encode(message.contractCall, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             if (message.contractCreateInstance != null && Object.hasOwnProperty.call(message, "contractCreateInstance"))
//                 $root.proto.ContractCreateTransactionBody.encode(message.contractCreateInstance, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.contractUpdateInstance != null && Object.hasOwnProperty.call(message, "contractUpdateInstance"))
//                 $root.proto.ContractUpdateTransactionBody.encode(message.contractUpdateInstance, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
//             if (message.cryptoAddLiveHash != null && Object.hasOwnProperty.call(message, "cryptoAddLiveHash"))
//                 $root.proto.CryptoAddLiveHashTransactionBody.encode(message.cryptoAddLiveHash, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
//             if (message.cryptoCreateAccount != null && Object.hasOwnProperty.call(message, "cryptoCreateAccount"))
//                 $root.proto.CryptoCreateTransactionBody.encode(message.cryptoCreateAccount, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
//             if (message.cryptoDelete != null && Object.hasOwnProperty.call(message, "cryptoDelete"))
//                 $root.proto.CryptoDeleteTransactionBody.encode(message.cryptoDelete, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
//             if (message.cryptoDeleteLiveHash != null && Object.hasOwnProperty.call(message, "cryptoDeleteLiveHash"))
//                 $root.proto.CryptoDeleteLiveHashTransactionBody.encode(message.cryptoDeleteLiveHash, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
//             if (message.cryptoTransfer != null && Object.hasOwnProperty.call(message, "cryptoTransfer"))
//                 $root.proto.CryptoTransferTransactionBody.encode(message.cryptoTransfer, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
//             if (message.cryptoUpdateAccount != null && Object.hasOwnProperty.call(message, "cryptoUpdateAccount"))
//                 $root.proto.CryptoUpdateTransactionBody.encode(message.cryptoUpdateAccount, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
//             if (message.fileAppend != null && Object.hasOwnProperty.call(message, "fileAppend"))
//                 $root.proto.FileAppendTransactionBody.encode(message.fileAppend, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
//             if (message.fileCreate != null && Object.hasOwnProperty.call(message, "fileCreate"))
//                 $root.proto.FileCreateTransactionBody.encode(message.fileCreate, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
//             if (message.fileDelete != null && Object.hasOwnProperty.call(message, "fileDelete"))
//                 $root.proto.FileDeleteTransactionBody.encode(message.fileDelete, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
//             if (message.fileUpdate != null && Object.hasOwnProperty.call(message, "fileUpdate"))
//                 $root.proto.FileUpdateTransactionBody.encode(message.fileUpdate, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
//             if (message.systemDelete != null && Object.hasOwnProperty.call(message, "systemDelete"))
//                 $root.proto.SystemDeleteTransactionBody.encode(message.systemDelete, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
//             if (message.systemUndelete != null && Object.hasOwnProperty.call(message, "systemUndelete"))
//                 $root.proto.SystemUndeleteTransactionBody.encode(message.systemUndelete, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
//             if (message.contractDeleteInstance != null && Object.hasOwnProperty.call(message, "contractDeleteInstance"))
//                 $root.proto.ContractDeleteTransactionBody.encode(message.contractDeleteInstance, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
//             if (message.freeze != null && Object.hasOwnProperty.call(message, "freeze"))
//                 $root.proto.FreezeTransactionBody.encode(message.freeze, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
//             if (message.consensusCreateTopic != null && Object.hasOwnProperty.call(message, "consensusCreateTopic"))
//                 $root.proto.ConsensusCreateTopicTransactionBody.encode(message.consensusCreateTopic, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
//             if (message.consensusUpdateTopic != null && Object.hasOwnProperty.call(message, "consensusUpdateTopic"))
//                 $root.proto.ConsensusUpdateTopicTransactionBody.encode(message.consensusUpdateTopic, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
//             if (message.consensusDeleteTopic != null && Object.hasOwnProperty.call(message, "consensusDeleteTopic"))
//                 $root.proto.ConsensusDeleteTopicTransactionBody.encode(message.consensusDeleteTopic, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
//             if (message.consensusSubmitMessage != null && Object.hasOwnProperty.call(message, "consensusSubmitMessage"))
//                 $root.proto.ConsensusSubmitMessageTransactionBody.encode(message.consensusSubmitMessage, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionBody message, length delimited. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {proto.ITransactionBody} message TransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionBody} TransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.transactionID = $root.proto.TransactionID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.nodeAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.transactionFee = reader.uint64();
//                     break;
//                 case 4:
//                     message.transactionValidDuration = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.generateRecord = reader.bool();
//                     break;
//                 case 6:
//                     message.memo = reader.string();
//                     break;
//                 case 7:
//                     message.contractCall = $root.proto.ContractCallTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 9:
//                     message.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 22:
//                     message.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 10:
//                     message.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 11:
//                     message.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 12:
//                     message.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 13:
//                     message.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 14:
//                     message.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 15:
//                     message.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 16:
//                     message.fileAppend = $root.proto.FileAppendTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 17:
//                     message.fileCreate = $root.proto.FileCreateTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 18:
//                     message.fileDelete = $root.proto.FileDeleteTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 19:
//                     message.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 20:
//                     message.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 21:
//                     message.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 23:
//                     message.freeze = $root.proto.FreezeTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 24:
//                     message.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 25:
//                     message.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 26:
//                     message.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 case 27:
//                     message.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionBody} TransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionBody message.
//          * @function verify
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.transactionID != null && message.hasOwnProperty("transactionID")) {
//                 let error = $root.proto.TransactionID.verify(message.transactionID);
//                 if (error)
//                     return "transactionID." + error;
//             }
//             if (message.nodeAccountID != null && message.hasOwnProperty("nodeAccountID")) {
//                 let error = $root.proto.AccountID.verify(message.nodeAccountID);
//                 if (error)
//                     return "nodeAccountID." + error;
//             }
//             if (message.transactionFee != null && message.hasOwnProperty("transactionFee"))
//                 if (!$util.isInteger(message.transactionFee) && !(message.transactionFee && $util.isInteger(message.transactionFee.low) && $util.isInteger(message.transactionFee.high)))
//                     return "transactionFee: integer|Long expected";
//             if (message.transactionValidDuration != null && message.hasOwnProperty("transactionValidDuration")) {
//                 let error = $root.proto.Duration.verify(message.transactionValidDuration);
//                 if (error)
//                     return "transactionValidDuration." + error;
//             }
//             if (message.generateRecord != null && message.hasOwnProperty("generateRecord"))
//                 if (typeof message.generateRecord !== "boolean")
//                     return "generateRecord: boolean expected";
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 if (!$util.isString(message.memo))
//                     return "memo: string expected";
//             if (message.contractCall != null && message.hasOwnProperty("contractCall")) {
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ContractCallTransactionBody.verify(message.contractCall);
//                     if (error)
//                         return "contractCall." + error;
//                 }
//             }
//             if (message.contractCreateInstance != null && message.hasOwnProperty("contractCreateInstance")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ContractCreateTransactionBody.verify(message.contractCreateInstance);
//                     if (error)
//                         return "contractCreateInstance." + error;
//                 }
//             }
//             if (message.contractUpdateInstance != null && message.hasOwnProperty("contractUpdateInstance")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ContractUpdateTransactionBody.verify(message.contractUpdateInstance);
//                     if (error)
//                         return "contractUpdateInstance." + error;
//                 }
//             }
//             if (message.contractDeleteInstance != null && message.hasOwnProperty("contractDeleteInstance")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ContractDeleteTransactionBody.verify(message.contractDeleteInstance);
//                     if (error)
//                         return "contractDeleteInstance." + error;
//                 }
//             }
//             if (message.cryptoAddLiveHash != null && message.hasOwnProperty("cryptoAddLiveHash")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.CryptoAddLiveHashTransactionBody.verify(message.cryptoAddLiveHash);
//                     if (error)
//                         return "cryptoAddLiveHash." + error;
//                 }
//             }
//             if (message.cryptoCreateAccount != null && message.hasOwnProperty("cryptoCreateAccount")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.CryptoCreateTransactionBody.verify(message.cryptoCreateAccount);
//                     if (error)
//                         return "cryptoCreateAccount." + error;
//                 }
//             }
//             if (message.cryptoDelete != null && message.hasOwnProperty("cryptoDelete")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.CryptoDeleteTransactionBody.verify(message.cryptoDelete);
//                     if (error)
//                         return "cryptoDelete." + error;
//                 }
//             }
//             if (message.cryptoDeleteLiveHash != null && message.hasOwnProperty("cryptoDeleteLiveHash")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.CryptoDeleteLiveHashTransactionBody.verify(message.cryptoDeleteLiveHash);
//                     if (error)
//                         return "cryptoDeleteLiveHash." + error;
//                 }
//             }
//             if (message.cryptoTransfer != null && message.hasOwnProperty("cryptoTransfer")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.CryptoTransferTransactionBody.verify(message.cryptoTransfer);
//                     if (error)
//                         return "cryptoTransfer." + error;
//                 }
//             }
//             if (message.cryptoUpdateAccount != null && message.hasOwnProperty("cryptoUpdateAccount")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.CryptoUpdateTransactionBody.verify(message.cryptoUpdateAccount);
//                     if (error)
//                         return "cryptoUpdateAccount." + error;
//                 }
//             }
//             if (message.fileAppend != null && message.hasOwnProperty("fileAppend")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.FileAppendTransactionBody.verify(message.fileAppend);
//                     if (error)
//                         return "fileAppend." + error;
//                 }
//             }
//             if (message.fileCreate != null && message.hasOwnProperty("fileCreate")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.FileCreateTransactionBody.verify(message.fileCreate);
//                     if (error)
//                         return "fileCreate." + error;
//                 }
//             }
//             if (message.fileDelete != null && message.hasOwnProperty("fileDelete")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.FileDeleteTransactionBody.verify(message.fileDelete);
//                     if (error)
//                         return "fileDelete." + error;
//                 }
//             }
//             if (message.fileUpdate != null && message.hasOwnProperty("fileUpdate")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.FileUpdateTransactionBody.verify(message.fileUpdate);
//                     if (error)
//                         return "fileUpdate." + error;
//                 }
//             }
//             if (message.systemDelete != null && message.hasOwnProperty("systemDelete")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.SystemDeleteTransactionBody.verify(message.systemDelete);
//                     if (error)
//                         return "systemDelete." + error;
//                 }
//             }
//             if (message.systemUndelete != null && message.hasOwnProperty("systemUndelete")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.SystemUndeleteTransactionBody.verify(message.systemUndelete);
//                     if (error)
//                         return "systemUndelete." + error;
//                 }
//             }
//             if (message.freeze != null && message.hasOwnProperty("freeze")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.FreezeTransactionBody.verify(message.freeze);
//                     if (error)
//                         return "freeze." + error;
//                 }
//             }
//             if (message.consensusCreateTopic != null && message.hasOwnProperty("consensusCreateTopic")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ConsensusCreateTopicTransactionBody.verify(message.consensusCreateTopic);
//                     if (error)
//                         return "consensusCreateTopic." + error;
//                 }
//             }
//             if (message.consensusUpdateTopic != null && message.hasOwnProperty("consensusUpdateTopic")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ConsensusUpdateTopicTransactionBody.verify(message.consensusUpdateTopic);
//                     if (error)
//                         return "consensusUpdateTopic." + error;
//                 }
//             }
//             if (message.consensusDeleteTopic != null && message.hasOwnProperty("consensusDeleteTopic")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ConsensusDeleteTopicTransactionBody.verify(message.consensusDeleteTopic);
//                     if (error)
//                         return "consensusDeleteTopic." + error;
//                 }
//             }
//             if (message.consensusSubmitMessage != null && message.hasOwnProperty("consensusSubmitMessage")) {
//                 if (properties.data === 1)
//                     return "data: multiple values";
//                 properties.data = 1;
//                 {
//                     let error = $root.proto.ConsensusSubmitMessageTransactionBody.verify(message.consensusSubmitMessage);
//                     if (error)
//                         return "consensusSubmitMessage." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionBody} TransactionBody
//          */
//         TransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionBody)
//                 return object;
//             let message = new $root.proto.TransactionBody();
//             if (object.transactionID != null) {
//                 if (typeof object.transactionID !== "object")
//                     throw TypeError(".proto.TransactionBody.transactionID: object expected");
//                 message.transactionID = $root.proto.TransactionID.fromObject(object.transactionID);
//             }
//             if (object.nodeAccountID != null) {
//                 if (typeof object.nodeAccountID !== "object")
//                     throw TypeError(".proto.TransactionBody.nodeAccountID: object expected");
//                 message.nodeAccountID = $root.proto.AccountID.fromObject(object.nodeAccountID);
//             }
//             if (object.transactionFee != null)
//                 if ($util.Long)
//                     (message.transactionFee = $util.Long.fromValue(object.transactionFee)).unsigned = true;
//                 else if (typeof object.transactionFee === "string")
//                     message.transactionFee = parseInt(object.transactionFee, 10);
//                 else if (typeof object.transactionFee === "number")
//                     message.transactionFee = object.transactionFee;
//                 else if (typeof object.transactionFee === "object")
//                     message.transactionFee = new $util.LongBits(object.transactionFee.low >>> 0, object.transactionFee.high >>> 0).toNumber(true);
//             if (object.transactionValidDuration != null) {
//                 if (typeof object.transactionValidDuration !== "object")
//                     throw TypeError(".proto.TransactionBody.transactionValidDuration: object expected");
//                 message.transactionValidDuration = $root.proto.Duration.fromObject(object.transactionValidDuration);
//             }
//             if (object.generateRecord != null)
//                 message.generateRecord = Boolean(object.generateRecord);
//             if (object.memo != null)
//                 message.memo = String(object.memo);
//             if (object.contractCall != null) {
//                 if (typeof object.contractCall !== "object")
//                     throw TypeError(".proto.TransactionBody.contractCall: object expected");
//                 message.contractCall = $root.proto.ContractCallTransactionBody.fromObject(object.contractCall);
//             }
//             if (object.contractCreateInstance != null) {
//                 if (typeof object.contractCreateInstance !== "object")
//                     throw TypeError(".proto.TransactionBody.contractCreateInstance: object expected");
//                 message.contractCreateInstance = $root.proto.ContractCreateTransactionBody.fromObject(object.contractCreateInstance);
//             }
//             if (object.contractUpdateInstance != null) {
//                 if (typeof object.contractUpdateInstance !== "object")
//                     throw TypeError(".proto.TransactionBody.contractUpdateInstance: object expected");
//                 message.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.fromObject(object.contractUpdateInstance);
//             }
//             if (object.contractDeleteInstance != null) {
//                 if (typeof object.contractDeleteInstance !== "object")
//                     throw TypeError(".proto.TransactionBody.contractDeleteInstance: object expected");
//                 message.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.fromObject(object.contractDeleteInstance);
//             }
//             if (object.cryptoAddLiveHash != null) {
//                 if (typeof object.cryptoAddLiveHash !== "object")
//                     throw TypeError(".proto.TransactionBody.cryptoAddLiveHash: object expected");
//                 message.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.fromObject(object.cryptoAddLiveHash);
//             }
//             if (object.cryptoCreateAccount != null) {
//                 if (typeof object.cryptoCreateAccount !== "object")
//                     throw TypeError(".proto.TransactionBody.cryptoCreateAccount: object expected");
//                 message.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.fromObject(object.cryptoCreateAccount);
//             }
//             if (object.cryptoDelete != null) {
//                 if (typeof object.cryptoDelete !== "object")
//                     throw TypeError(".proto.TransactionBody.cryptoDelete: object expected");
//                 message.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.fromObject(object.cryptoDelete);
//             }
//             if (object.cryptoDeleteLiveHash != null) {
//                 if (typeof object.cryptoDeleteLiveHash !== "object")
//                     throw TypeError(".proto.TransactionBody.cryptoDeleteLiveHash: object expected");
//                 message.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.fromObject(object.cryptoDeleteLiveHash);
//             }
//             if (object.cryptoTransfer != null) {
//                 if (typeof object.cryptoTransfer !== "object")
//                     throw TypeError(".proto.TransactionBody.cryptoTransfer: object expected");
//                 message.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.fromObject(object.cryptoTransfer);
//             }
//             if (object.cryptoUpdateAccount != null) {
//                 if (typeof object.cryptoUpdateAccount !== "object")
//                     throw TypeError(".proto.TransactionBody.cryptoUpdateAccount: object expected");
//                 message.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.fromObject(object.cryptoUpdateAccount);
//             }
//             if (object.fileAppend != null) {
//                 if (typeof object.fileAppend !== "object")
//                     throw TypeError(".proto.TransactionBody.fileAppend: object expected");
//                 message.fileAppend = $root.proto.FileAppendTransactionBody.fromObject(object.fileAppend);
//             }
//             if (object.fileCreate != null) {
//                 if (typeof object.fileCreate !== "object")
//                     throw TypeError(".proto.TransactionBody.fileCreate: object expected");
//                 message.fileCreate = $root.proto.FileCreateTransactionBody.fromObject(object.fileCreate);
//             }
//             if (object.fileDelete != null) {
//                 if (typeof object.fileDelete !== "object")
//                     throw TypeError(".proto.TransactionBody.fileDelete: object expected");
//                 message.fileDelete = $root.proto.FileDeleteTransactionBody.fromObject(object.fileDelete);
//             }
//             if (object.fileUpdate != null) {
//                 if (typeof object.fileUpdate !== "object")
//                     throw TypeError(".proto.TransactionBody.fileUpdate: object expected");
//                 message.fileUpdate = $root.proto.FileUpdateTransactionBody.fromObject(object.fileUpdate);
//             }
//             if (object.systemDelete != null) {
//                 if (typeof object.systemDelete !== "object")
//                     throw TypeError(".proto.TransactionBody.systemDelete: object expected");
//                 message.systemDelete = $root.proto.SystemDeleteTransactionBody.fromObject(object.systemDelete);
//             }
//             if (object.systemUndelete != null) {
//                 if (typeof object.systemUndelete !== "object")
//                     throw TypeError(".proto.TransactionBody.systemUndelete: object expected");
//                 message.systemUndelete = $root.proto.SystemUndeleteTransactionBody.fromObject(object.systemUndelete);
//             }
//             if (object.freeze != null) {
//                 if (typeof object.freeze !== "object")
//                     throw TypeError(".proto.TransactionBody.freeze: object expected");
//                 message.freeze = $root.proto.FreezeTransactionBody.fromObject(object.freeze);
//             }
//             if (object.consensusCreateTopic != null) {
//                 if (typeof object.consensusCreateTopic !== "object")
//                     throw TypeError(".proto.TransactionBody.consensusCreateTopic: object expected");
//                 message.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.fromObject(object.consensusCreateTopic);
//             }
//             if (object.consensusUpdateTopic != null) {
//                 if (typeof object.consensusUpdateTopic !== "object")
//                     throw TypeError(".proto.TransactionBody.consensusUpdateTopic: object expected");
//                 message.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.fromObject(object.consensusUpdateTopic);
//             }
//             if (object.consensusDeleteTopic != null) {
//                 if (typeof object.consensusDeleteTopic !== "object")
//                     throw TypeError(".proto.TransactionBody.consensusDeleteTopic: object expected");
//                 message.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.fromObject(object.consensusDeleteTopic);
//             }
//             if (object.consensusSubmitMessage != null) {
//                 if (typeof object.consensusSubmitMessage !== "object")
//                     throw TypeError(".proto.TransactionBody.consensusSubmitMessage: object expected");
//                 message.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.fromObject(object.consensusSubmitMessage);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionBody
//          * @static
//          * @param {proto.TransactionBody} message TransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.transactionID = null;
//                 object.nodeAccountID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.transactionFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.transactionFee = options.longs === String ? "0" : 0;
//                 object.transactionValidDuration = null;
//                 object.generateRecord = false;
//                 object.memo = "";
//             }
//             if (message.transactionID != null && message.hasOwnProperty("transactionID"))
//                 object.transactionID = $root.proto.TransactionID.toObject(message.transactionID, options);
//             if (message.nodeAccountID != null && message.hasOwnProperty("nodeAccountID"))
//                 object.nodeAccountID = $root.proto.AccountID.toObject(message.nodeAccountID, options);
//             if (message.transactionFee != null && message.hasOwnProperty("transactionFee"))
//                 if (typeof message.transactionFee === "number")
//                     object.transactionFee = options.longs === String ? String(message.transactionFee) : message.transactionFee;
//                 else
//                     object.transactionFee = options.longs === String ? $util.Long.prototype.toString.call(message.transactionFee) : options.longs === Number ? new $util.LongBits(message.transactionFee.low >>> 0, message.transactionFee.high >>> 0).toNumber(true) : message.transactionFee;
//             if (message.transactionValidDuration != null && message.hasOwnProperty("transactionValidDuration"))
//                 object.transactionValidDuration = $root.proto.Duration.toObject(message.transactionValidDuration, options);
//             if (message.generateRecord != null && message.hasOwnProperty("generateRecord"))
//                 object.generateRecord = message.generateRecord;
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = message.memo;
//             if (message.contractCall != null && message.hasOwnProperty("contractCall")) {
//                 object.contractCall = $root.proto.ContractCallTransactionBody.toObject(message.contractCall, options);
//                 if (options.oneofs)
//                     object.data = "contractCall";
//             }
//             if (message.contractCreateInstance != null && message.hasOwnProperty("contractCreateInstance")) {
//                 object.contractCreateInstance = $root.proto.ContractCreateTransactionBody.toObject(message.contractCreateInstance, options);
//                 if (options.oneofs)
//                     object.data = "contractCreateInstance";
//             }
//             if (message.contractUpdateInstance != null && message.hasOwnProperty("contractUpdateInstance")) {
//                 object.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.toObject(message.contractUpdateInstance, options);
//                 if (options.oneofs)
//                     object.data = "contractUpdateInstance";
//             }
//             if (message.cryptoAddLiveHash != null && message.hasOwnProperty("cryptoAddLiveHash")) {
//                 object.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.toObject(message.cryptoAddLiveHash, options);
//                 if (options.oneofs)
//                     object.data = "cryptoAddLiveHash";
//             }
//             if (message.cryptoCreateAccount != null && message.hasOwnProperty("cryptoCreateAccount")) {
//                 object.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.toObject(message.cryptoCreateAccount, options);
//                 if (options.oneofs)
//                     object.data = "cryptoCreateAccount";
//             }
//             if (message.cryptoDelete != null && message.hasOwnProperty("cryptoDelete")) {
//                 object.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.toObject(message.cryptoDelete, options);
//                 if (options.oneofs)
//                     object.data = "cryptoDelete";
//             }
//             if (message.cryptoDeleteLiveHash != null && message.hasOwnProperty("cryptoDeleteLiveHash")) {
//                 object.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.toObject(message.cryptoDeleteLiveHash, options);
//                 if (options.oneofs)
//                     object.data = "cryptoDeleteLiveHash";
//             }
//             if (message.cryptoTransfer != null && message.hasOwnProperty("cryptoTransfer")) {
//                 object.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.toObject(message.cryptoTransfer, options);
//                 if (options.oneofs)
//                     object.data = "cryptoTransfer";
//             }
//             if (message.cryptoUpdateAccount != null && message.hasOwnProperty("cryptoUpdateAccount")) {
//                 object.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.toObject(message.cryptoUpdateAccount, options);
//                 if (options.oneofs)
//                     object.data = "cryptoUpdateAccount";
//             }
//             if (message.fileAppend != null && message.hasOwnProperty("fileAppend")) {
//                 object.fileAppend = $root.proto.FileAppendTransactionBody.toObject(message.fileAppend, options);
//                 if (options.oneofs)
//                     object.data = "fileAppend";
//             }
//             if (message.fileCreate != null && message.hasOwnProperty("fileCreate")) {
//                 object.fileCreate = $root.proto.FileCreateTransactionBody.toObject(message.fileCreate, options);
//                 if (options.oneofs)
//                     object.data = "fileCreate";
//             }
//             if (message.fileDelete != null && message.hasOwnProperty("fileDelete")) {
//                 object.fileDelete = $root.proto.FileDeleteTransactionBody.toObject(message.fileDelete, options);
//                 if (options.oneofs)
//                     object.data = "fileDelete";
//             }
//             if (message.fileUpdate != null && message.hasOwnProperty("fileUpdate")) {
//                 object.fileUpdate = $root.proto.FileUpdateTransactionBody.toObject(message.fileUpdate, options);
//                 if (options.oneofs)
//                     object.data = "fileUpdate";
//             }
//             if (message.systemDelete != null && message.hasOwnProperty("systemDelete")) {
//                 object.systemDelete = $root.proto.SystemDeleteTransactionBody.toObject(message.systemDelete, options);
//                 if (options.oneofs)
//                     object.data = "systemDelete";
//             }
//             if (message.systemUndelete != null && message.hasOwnProperty("systemUndelete")) {
//                 object.systemUndelete = $root.proto.SystemUndeleteTransactionBody.toObject(message.systemUndelete, options);
//                 if (options.oneofs)
//                     object.data = "systemUndelete";
//             }
//             if (message.contractDeleteInstance != null && message.hasOwnProperty("contractDeleteInstance")) {
//                 object.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.toObject(message.contractDeleteInstance, options);
//                 if (options.oneofs)
//                     object.data = "contractDeleteInstance";
//             }
//             if (message.freeze != null && message.hasOwnProperty("freeze")) {
//                 object.freeze = $root.proto.FreezeTransactionBody.toObject(message.freeze, options);
//                 if (options.oneofs)
//                     object.data = "freeze";
//             }
//             if (message.consensusCreateTopic != null && message.hasOwnProperty("consensusCreateTopic")) {
//                 object.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.toObject(message.consensusCreateTopic, options);
//                 if (options.oneofs)
//                     object.data = "consensusCreateTopic";
//             }
//             if (message.consensusUpdateTopic != null && message.hasOwnProperty("consensusUpdateTopic")) {
//                 object.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.toObject(message.consensusUpdateTopic, options);
//                 if (options.oneofs)
//                     object.data = "consensusUpdateTopic";
//             }
//             if (message.consensusDeleteTopic != null && message.hasOwnProperty("consensusDeleteTopic")) {
//                 object.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.toObject(message.consensusDeleteTopic, options);
//                 if (options.oneofs)
//                     object.data = "consensusDeleteTopic";
//             }
//             if (message.consensusSubmitMessage != null && message.hasOwnProperty("consensusSubmitMessage")) {
//                 object.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.toObject(message.consensusSubmitMessage, options);
//                 if (options.oneofs)
//                     object.data = "consensusSubmitMessage";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionBody;
//     })();
// 
//     proto.SystemDeleteTransactionBody = (function() {
// 
//         /**
//          * Properties of a SystemDeleteTransactionBody.
//          * @memberof proto
//          * @interface ISystemDeleteTransactionBody
//          * @property {proto.IFileID|null} [fileID] SystemDeleteTransactionBody fileID
//          * @property {proto.IContractID|null} [contractID] SystemDeleteTransactionBody contractID
//          * @property {proto.ITimestampSeconds|null} [expirationTime] SystemDeleteTransactionBody expirationTime
//          */
// 
//         /**
//          * Constructs a new SystemDeleteTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a SystemDeleteTransactionBody.
//          * @implements ISystemDeleteTransactionBody
//          * @constructor
//          * @param {proto.ISystemDeleteTransactionBody=} [properties] Properties to set
//          */
//         function SystemDeleteTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * SystemDeleteTransactionBody fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.SystemDeleteTransactionBody
//          * @instance
//          */
//         SystemDeleteTransactionBody.prototype.fileID = null;
// 
//         /**
//          * SystemDeleteTransactionBody contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.SystemDeleteTransactionBody
//          * @instance
//          */
//         SystemDeleteTransactionBody.prototype.contractID = null;
// 
//         /**
//          * SystemDeleteTransactionBody expirationTime.
//          * @member {proto.ITimestampSeconds|null|undefined} expirationTime
//          * @memberof proto.SystemDeleteTransactionBody
//          * @instance
//          */
//         SystemDeleteTransactionBody.prototype.expirationTime = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * SystemDeleteTransactionBody id.
//          * @member {"fileID"|"contractID"|undefined} id
//          * @memberof proto.SystemDeleteTransactionBody
//          * @instance
//          */
//         Object.defineProperty(SystemDeleteTransactionBody.prototype, "id", {
//             get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new SystemDeleteTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {proto.ISystemDeleteTransactionBody=} [properties] Properties to set
//          * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody instance
//          */
//         SystemDeleteTransactionBody.create = function create(properties) {
//             return new SystemDeleteTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified SystemDeleteTransactionBody message. Does not implicitly {@link proto.SystemDeleteTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {proto.ISystemDeleteTransactionBody} message SystemDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SystemDeleteTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.TimestampSeconds.encode(message.expirationTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified SystemDeleteTransactionBody message, length delimited. Does not implicitly {@link proto.SystemDeleteTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {proto.ISystemDeleteTransactionBody} message SystemDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SystemDeleteTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a SystemDeleteTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SystemDeleteTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SystemDeleteTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.expirationTime = $root.proto.TimestampSeconds.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a SystemDeleteTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SystemDeleteTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a SystemDeleteTransactionBody message.
//          * @function verify
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         SystemDeleteTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 properties.id = 1;
//                 {
//                     let error = $root.proto.FileID.verify(message.fileID);
//                     if (error)
//                         return "fileID." + error;
//                 }
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 if (properties.id === 1)
//                     return "id: multiple values";
//                 properties.id = 1;
//                 {
//                     let error = $root.proto.ContractID.verify(message.contractID);
//                     if (error)
//                         return "contractID." + error;
//                 }
//             }
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.TimestampSeconds.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a SystemDeleteTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody
//          */
//         SystemDeleteTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.SystemDeleteTransactionBody)
//                 return object;
//             let message = new $root.proto.SystemDeleteTransactionBody();
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.SystemDeleteTransactionBody.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.SystemDeleteTransactionBody.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.SystemDeleteTransactionBody.expirationTime: object expected");
//                 message.expirationTime = $root.proto.TimestampSeconds.fromObject(object.expirationTime);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a SystemDeleteTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.SystemDeleteTransactionBody
//          * @static
//          * @param {proto.SystemDeleteTransactionBody} message SystemDeleteTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         SystemDeleteTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.expirationTime = null;
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//                 if (options.oneofs)
//                     object.id = "fileID";
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//                 if (options.oneofs)
//                     object.id = "contractID";
//             }
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.TimestampSeconds.toObject(message.expirationTime, options);
//             return object;
//         };
// 
//         /**
//          * Converts this SystemDeleteTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.SystemDeleteTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         SystemDeleteTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return SystemDeleteTransactionBody;
//     })();
// 
//     proto.SystemUndeleteTransactionBody = (function() {
// 
//         /**
//          * Properties of a SystemUndeleteTransactionBody.
//          * @memberof proto
//          * @interface ISystemUndeleteTransactionBody
//          * @property {proto.IFileID|null} [fileID] SystemUndeleteTransactionBody fileID
//          * @property {proto.IContractID|null} [contractID] SystemUndeleteTransactionBody contractID
//          */
// 
//         /**
//          * Constructs a new SystemUndeleteTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a SystemUndeleteTransactionBody.
//          * @implements ISystemUndeleteTransactionBody
//          * @constructor
//          * @param {proto.ISystemUndeleteTransactionBody=} [properties] Properties to set
//          */
//         function SystemUndeleteTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * SystemUndeleteTransactionBody fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @instance
//          */
//         SystemUndeleteTransactionBody.prototype.fileID = null;
// 
//         /**
//          * SystemUndeleteTransactionBody contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @instance
//          */
//         SystemUndeleteTransactionBody.prototype.contractID = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * SystemUndeleteTransactionBody id.
//          * @member {"fileID"|"contractID"|undefined} id
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @instance
//          */
//         Object.defineProperty(SystemUndeleteTransactionBody.prototype, "id", {
//             get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new SystemUndeleteTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {proto.ISystemUndeleteTransactionBody=} [properties] Properties to set
//          * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody instance
//          */
//         SystemUndeleteTransactionBody.create = function create(properties) {
//             return new SystemUndeleteTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified SystemUndeleteTransactionBody message. Does not implicitly {@link proto.SystemUndeleteTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {proto.ISystemUndeleteTransactionBody} message SystemUndeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SystemUndeleteTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified SystemUndeleteTransactionBody message, length delimited. Does not implicitly {@link proto.SystemUndeleteTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {proto.ISystemUndeleteTransactionBody} message SystemUndeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         SystemUndeleteTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a SystemUndeleteTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SystemUndeleteTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SystemUndeleteTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a SystemUndeleteTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         SystemUndeleteTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a SystemUndeleteTransactionBody message.
//          * @function verify
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         SystemUndeleteTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 properties.id = 1;
//                 {
//                     let error = $root.proto.FileID.verify(message.fileID);
//                     if (error)
//                         return "fileID." + error;
//                 }
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 if (properties.id === 1)
//                     return "id: multiple values";
//                 properties.id = 1;
//                 {
//                     let error = $root.proto.ContractID.verify(message.contractID);
//                     if (error)
//                         return "contractID." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a SystemUndeleteTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody
//          */
//         SystemUndeleteTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.SystemUndeleteTransactionBody)
//                 return object;
//             let message = new $root.proto.SystemUndeleteTransactionBody();
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.SystemUndeleteTransactionBody.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.SystemUndeleteTransactionBody.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a SystemUndeleteTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @static
//          * @param {proto.SystemUndeleteTransactionBody} message SystemUndeleteTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         SystemUndeleteTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//                 if (options.oneofs)
//                     object.id = "fileID";
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//                 if (options.oneofs)
//                     object.id = "contractID";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this SystemUndeleteTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.SystemUndeleteTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         SystemUndeleteTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return SystemUndeleteTransactionBody;
//     })();
// 
//     proto.FreezeTransactionBody = (function() {
// 
//         /**
//          * Properties of a FreezeTransactionBody.
//          * @memberof proto
//          * @interface IFreezeTransactionBody
//          * @property {number|null} [startHour] FreezeTransactionBody startHour
//          * @property {number|null} [startMin] FreezeTransactionBody startMin
//          * @property {number|null} [endHour] FreezeTransactionBody endHour
//          * @property {number|null} [endMin] FreezeTransactionBody endMin
//          * @property {proto.IFileID|null} [updateFile] FreezeTransactionBody updateFile
//          */
// 
//         /**
//          * Constructs a new FreezeTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a FreezeTransactionBody.
//          * @implements IFreezeTransactionBody
//          * @constructor
//          * @param {proto.IFreezeTransactionBody=} [properties] Properties to set
//          */
//         function FreezeTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FreezeTransactionBody startHour.
//          * @member {number} startHour
//          * @memberof proto.FreezeTransactionBody
//          * @instance
//          */
//         FreezeTransactionBody.prototype.startHour = 0;
// 
//         /**
//          * FreezeTransactionBody startMin.
//          * @member {number} startMin
//          * @memberof proto.FreezeTransactionBody
//          * @instance
//          */
//         FreezeTransactionBody.prototype.startMin = 0;
// 
//         /**
//          * FreezeTransactionBody endHour.
//          * @member {number} endHour
//          * @memberof proto.FreezeTransactionBody
//          * @instance
//          */
//         FreezeTransactionBody.prototype.endHour = 0;
// 
//         /**
//          * FreezeTransactionBody endMin.
//          * @member {number} endMin
//          * @memberof proto.FreezeTransactionBody
//          * @instance
//          */
//         FreezeTransactionBody.prototype.endMin = 0;
// 
//         /**
//          * FreezeTransactionBody updateFile.
//          * @member {proto.IFileID|null|undefined} updateFile
//          * @memberof proto.FreezeTransactionBody
//          * @instance
//          */
//         FreezeTransactionBody.prototype.updateFile = null;
// 
//         /**
//          * Creates a new FreezeTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {proto.IFreezeTransactionBody=} [properties] Properties to set
//          * @returns {proto.FreezeTransactionBody} FreezeTransactionBody instance
//          */
//         FreezeTransactionBody.create = function create(properties) {
//             return new FreezeTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified FreezeTransactionBody message. Does not implicitly {@link proto.FreezeTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {proto.IFreezeTransactionBody} message FreezeTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FreezeTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.startHour != null && Object.hasOwnProperty.call(message, "startHour"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.startHour);
//             if (message.startMin != null && Object.hasOwnProperty.call(message, "startMin"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.startMin);
//             if (message.endHour != null && Object.hasOwnProperty.call(message, "endHour"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int32(message.endHour);
//             if (message.endMin != null && Object.hasOwnProperty.call(message, "endMin"))
//                 writer.uint32(/* id 4, wireType 0 =*/32).int32(message.endMin);
//             if (message.updateFile != null && Object.hasOwnProperty.call(message, "updateFile"))
//                 $root.proto.FileID.encode(message.updateFile, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FreezeTransactionBody message, length delimited. Does not implicitly {@link proto.FreezeTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {proto.IFreezeTransactionBody} message FreezeTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FreezeTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FreezeTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FreezeTransactionBody} FreezeTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FreezeTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FreezeTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.startHour = reader.int32();
//                     break;
//                 case 2:
//                     message.startMin = reader.int32();
//                     break;
//                 case 3:
//                     message.endHour = reader.int32();
//                     break;
//                 case 4:
//                     message.endMin = reader.int32();
//                     break;
//                 case 5:
//                     message.updateFile = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FreezeTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FreezeTransactionBody} FreezeTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FreezeTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FreezeTransactionBody message.
//          * @function verify
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FreezeTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.startHour != null && message.hasOwnProperty("startHour"))
//                 if (!$util.isInteger(message.startHour))
//                     return "startHour: integer expected";
//             if (message.startMin != null && message.hasOwnProperty("startMin"))
//                 if (!$util.isInteger(message.startMin))
//                     return "startMin: integer expected";
//             if (message.endHour != null && message.hasOwnProperty("endHour"))
//                 if (!$util.isInteger(message.endHour))
//                     return "endHour: integer expected";
//             if (message.endMin != null && message.hasOwnProperty("endMin"))
//                 if (!$util.isInteger(message.endMin))
//                     return "endMin: integer expected";
//             if (message.updateFile != null && message.hasOwnProperty("updateFile")) {
//                 let error = $root.proto.FileID.verify(message.updateFile);
//                 if (error)
//                     return "updateFile." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FreezeTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FreezeTransactionBody} FreezeTransactionBody
//          */
//         FreezeTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FreezeTransactionBody)
//                 return object;
//             let message = new $root.proto.FreezeTransactionBody();
//             if (object.startHour != null)
//                 message.startHour = object.startHour | 0;
//             if (object.startMin != null)
//                 message.startMin = object.startMin | 0;
//             if (object.endHour != null)
//                 message.endHour = object.endHour | 0;
//             if (object.endMin != null)
//                 message.endMin = object.endMin | 0;
//             if (object.updateFile != null) {
//                 if (typeof object.updateFile !== "object")
//                     throw TypeError(".proto.FreezeTransactionBody.updateFile: object expected");
//                 message.updateFile = $root.proto.FileID.fromObject(object.updateFile);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FreezeTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FreezeTransactionBody
//          * @static
//          * @param {proto.FreezeTransactionBody} message FreezeTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FreezeTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.startHour = 0;
//                 object.startMin = 0;
//                 object.endHour = 0;
//                 object.endMin = 0;
//                 object.updateFile = null;
//             }
//             if (message.startHour != null && message.hasOwnProperty("startHour"))
//                 object.startHour = message.startHour;
//             if (message.startMin != null && message.hasOwnProperty("startMin"))
//                 object.startMin = message.startMin;
//             if (message.endHour != null && message.hasOwnProperty("endHour"))
//                 object.endHour = message.endHour;
//             if (message.endMin != null && message.hasOwnProperty("endMin"))
//                 object.endMin = message.endMin;
//             if (message.updateFile != null && message.hasOwnProperty("updateFile"))
//                 object.updateFile = $root.proto.FileID.toObject(message.updateFile, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FreezeTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.FreezeTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FreezeTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FreezeTransactionBody;
//     })();
// 
//     proto.ContractCallTransactionBody = (function() {
// 
//         /**
//          * Properties of a ContractCallTransactionBody.
//          * @memberof proto
//          * @interface IContractCallTransactionBody
//          * @property {proto.IContractID|null} [contractID] ContractCallTransactionBody contractID
//          * @property {number|Long|null} [gas] ContractCallTransactionBody gas
//          * @property {number|Long|null} [amount] ContractCallTransactionBody amount
//          * @property {Uint8Array|null} [functionParameters] ContractCallTransactionBody functionParameters
//          */
// 
//         /**
//          * Constructs a new ContractCallTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ContractCallTransactionBody.
//          * @implements IContractCallTransactionBody
//          * @constructor
//          * @param {proto.IContractCallTransactionBody=} [properties] Properties to set
//          */
//         function ContractCallTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractCallTransactionBody contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractCallTransactionBody
//          * @instance
//          */
//         ContractCallTransactionBody.prototype.contractID = null;
// 
//         /**
//          * ContractCallTransactionBody gas.
//          * @member {number|Long} gas
//          * @memberof proto.ContractCallTransactionBody
//          * @instance
//          */
//         ContractCallTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * ContractCallTransactionBody amount.
//          * @member {number|Long} amount
//          * @memberof proto.ContractCallTransactionBody
//          * @instance
//          */
//         ContractCallTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * ContractCallTransactionBody functionParameters.
//          * @member {Uint8Array} functionParameters
//          * @memberof proto.ContractCallTransactionBody
//          * @instance
//          */
//         ContractCallTransactionBody.prototype.functionParameters = $util.newBuffer([]);
// 
//         /**
//          * Creates a new ContractCallTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {proto.IContractCallTransactionBody=} [properties] Properties to set
//          * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody instance
//          */
//         ContractCallTransactionBody.create = function create(properties) {
//             return new ContractCallTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractCallTransactionBody message. Does not implicitly {@link proto.ContractCallTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {proto.IContractCallTransactionBody} message ContractCallTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCallTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gas);
//             if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
//             if (message.functionParameters != null && Object.hasOwnProperty.call(message, "functionParameters"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.functionParameters);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractCallTransactionBody message, length delimited. Does not implicitly {@link proto.ContractCallTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {proto.IContractCallTransactionBody} message ContractCallTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCallTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractCallTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCallTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractCallTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.gas = reader.int64();
//                     break;
//                 case 3:
//                     message.amount = reader.int64();
//                     break;
//                 case 4:
//                     message.functionParameters = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractCallTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCallTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractCallTransactionBody message.
//          * @function verify
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractCallTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
//                     return "gas: integer|Long expected";
//             if (message.amount != null && message.hasOwnProperty("amount"))
//                 if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
//                     return "amount: integer|Long expected";
//             if (message.functionParameters != null && message.hasOwnProperty("functionParameters"))
//                 if (!(message.functionParameters && typeof message.functionParameters.length === "number" || $util.isString(message.functionParameters)))
//                     return "functionParameters: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ContractCallTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody
//          */
//         ContractCallTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractCallTransactionBody)
//                 return object;
//             let message = new $root.proto.ContractCallTransactionBody();
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractCallTransactionBody.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.gas != null)
//                 if ($util.Long)
//                     (message.gas = $util.Long.fromValue(object.gas)).unsigned = false;
//                 else if (typeof object.gas === "string")
//                     message.gas = parseInt(object.gas, 10);
//                 else if (typeof object.gas === "number")
//                     message.gas = object.gas;
//                 else if (typeof object.gas === "object")
//                     message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber();
//             if (object.amount != null)
//                 if ($util.Long)
//                     (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
//                 else if (typeof object.amount === "string")
//                     message.amount = parseInt(object.amount, 10);
//                 else if (typeof object.amount === "number")
//                     message.amount = object.amount;
//                 else if (typeof object.amount === "object")
//                     message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
//             if (object.functionParameters != null)
//                 if (typeof object.functionParameters === "string")
//                     $util.base64.decode(object.functionParameters, message.functionParameters = $util.newBuffer($util.base64.length(object.functionParameters)), 0);
//                 else if (object.functionParameters.length)
//                     message.functionParameters = object.functionParameters;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractCallTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractCallTransactionBody
//          * @static
//          * @param {proto.ContractCallTransactionBody} message ContractCallTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractCallTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.contractID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.gas = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.amount = options.longs === String ? "0" : 0;
//                 if (options.bytes === String)
//                     object.functionParameters = "";
//                 else {
//                     object.functionParameters = [];
//                     if (options.bytes !== Array)
//                         object.functionParameters = $util.newBuffer(object.functionParameters);
//                 }
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (typeof message.gas === "number")
//                     object.gas = options.longs === String ? String(message.gas) : message.gas;
//                 else
//                     object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber() : message.gas;
//             if (message.amount != null && message.hasOwnProperty("amount"))
//                 if (typeof message.amount === "number")
//                     object.amount = options.longs === String ? String(message.amount) : message.amount;
//                 else
//                     object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
//             if (message.functionParameters != null && message.hasOwnProperty("functionParameters"))
//                 object.functionParameters = options.bytes === String ? $util.base64.encode(message.functionParameters, 0, message.functionParameters.length) : options.bytes === Array ? Array.prototype.slice.call(message.functionParameters) : message.functionParameters;
//             return object;
//         };
// 
//         /**
//          * Converts this ContractCallTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ContractCallTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractCallTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractCallTransactionBody;
//     })();
// 
//     proto.ContractCreateTransactionBody = (function() {
// 
//         /**
//          * Properties of a ContractCreateTransactionBody.
//          * @memberof proto
//          * @interface IContractCreateTransactionBody
//          * @property {proto.IFileID|null} [fileID] ContractCreateTransactionBody fileID
//          * @property {proto.IKey|null} [adminKey] ContractCreateTransactionBody adminKey
//          * @property {number|Long|null} [gas] ContractCreateTransactionBody gas
//          * @property {number|Long|null} [initialBalance] ContractCreateTransactionBody initialBalance
//          * @property {proto.IAccountID|null} [proxyAccountID] ContractCreateTransactionBody proxyAccountID
//          * @property {proto.IDuration|null} [autoRenewPeriod] ContractCreateTransactionBody autoRenewPeriod
//          * @property {Uint8Array|null} [constructorParameters] ContractCreateTransactionBody constructorParameters
//          * @property {proto.IShardID|null} [shardID] ContractCreateTransactionBody shardID
//          * @property {proto.IRealmID|null} [realmID] ContractCreateTransactionBody realmID
//          * @property {proto.IKey|null} [newRealmAdminKey] ContractCreateTransactionBody newRealmAdminKey
//          * @property {string|null} [memo] ContractCreateTransactionBody memo
//          */
// 
//         /**
//          * Constructs a new ContractCreateTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ContractCreateTransactionBody.
//          * @implements IContractCreateTransactionBody
//          * @constructor
//          * @param {proto.IContractCreateTransactionBody=} [properties] Properties to set
//          */
//         function ContractCreateTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractCreateTransactionBody fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.fileID = null;
// 
//         /**
//          * ContractCreateTransactionBody adminKey.
//          * @member {proto.IKey|null|undefined} adminKey
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.adminKey = null;
// 
//         /**
//          * ContractCreateTransactionBody gas.
//          * @member {number|Long} gas
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * ContractCreateTransactionBody initialBalance.
//          * @member {number|Long} initialBalance
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * ContractCreateTransactionBody proxyAccountID.
//          * @member {proto.IAccountID|null|undefined} proxyAccountID
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.proxyAccountID = null;
// 
//         /**
//          * ContractCreateTransactionBody autoRenewPeriod.
//          * @member {proto.IDuration|null|undefined} autoRenewPeriod
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.autoRenewPeriod = null;
// 
//         /**
//          * ContractCreateTransactionBody constructorParameters.
//          * @member {Uint8Array} constructorParameters
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.constructorParameters = $util.newBuffer([]);
// 
//         /**
//          * ContractCreateTransactionBody shardID.
//          * @member {proto.IShardID|null|undefined} shardID
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.shardID = null;
// 
//         /**
//          * ContractCreateTransactionBody realmID.
//          * @member {proto.IRealmID|null|undefined} realmID
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.realmID = null;
// 
//         /**
//          * ContractCreateTransactionBody newRealmAdminKey.
//          * @member {proto.IKey|null|undefined} newRealmAdminKey
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.newRealmAdminKey = null;
// 
//         /**
//          * ContractCreateTransactionBody memo.
//          * @member {string} memo
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          */
//         ContractCreateTransactionBody.prototype.memo = "";
// 
//         /**
//          * Creates a new ContractCreateTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {proto.IContractCreateTransactionBody=} [properties] Properties to set
//          * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody instance
//          */
//         ContractCreateTransactionBody.create = function create(properties) {
//             return new ContractCreateTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractCreateTransactionBody message. Does not implicitly {@link proto.ContractCreateTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {proto.IContractCreateTransactionBody} message ContractCreateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCreateTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.adminKey != null && Object.hasOwnProperty.call(message, "adminKey"))
//                 $root.proto.Key.encode(message.adminKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
//                 writer.uint32(/* id 4, wireType 0 =*/32).int64(message.gas);
//             if (message.initialBalance != null && Object.hasOwnProperty.call(message, "initialBalance"))
//                 writer.uint32(/* id 5, wireType 0 =*/40).int64(message.initialBalance);
//             if (message.proxyAccountID != null && Object.hasOwnProperty.call(message, "proxyAccountID"))
//                 $root.proto.AccountID.encode(message.proxyAccountID, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                 $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.constructorParameters != null && Object.hasOwnProperty.call(message, "constructorParameters"))
//                 writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.constructorParameters);
//             if (message.shardID != null && Object.hasOwnProperty.call(message, "shardID"))
//                 $root.proto.ShardID.encode(message.shardID, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
//             if (message.realmID != null && Object.hasOwnProperty.call(message, "realmID"))
//                 $root.proto.RealmID.encode(message.realmID, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
//             if (message.newRealmAdminKey != null && Object.hasOwnProperty.call(message, "newRealmAdminKey"))
//                 $root.proto.Key.encode(message.newRealmAdminKey, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 writer.uint32(/* id 13, wireType 2 =*/106).string(message.memo);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractCreateTransactionBody message, length delimited. Does not implicitly {@link proto.ContractCreateTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {proto.IContractCreateTransactionBody} message ContractCreateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCreateTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractCreateTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCreateTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractCreateTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.adminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.gas = reader.int64();
//                     break;
//                 case 5:
//                     message.initialBalance = reader.int64();
//                     break;
//                 case 6:
//                     message.proxyAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 9:
//                     message.constructorParameters = reader.bytes();
//                     break;
//                 case 10:
//                     message.shardID = $root.proto.ShardID.decode(reader, reader.uint32());
//                     break;
//                 case 11:
//                     message.realmID = $root.proto.RealmID.decode(reader, reader.uint32());
//                     break;
//                 case 12:
//                     message.newRealmAdminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 13:
//                     message.memo = reader.string();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractCreateTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCreateTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractCreateTransactionBody message.
//          * @function verify
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractCreateTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             if (message.adminKey != null && message.hasOwnProperty("adminKey")) {
//                 let error = $root.proto.Key.verify(message.adminKey);
//                 if (error)
//                     return "adminKey." + error;
//             }
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
//                     return "gas: integer|Long expected";
//             if (message.initialBalance != null && message.hasOwnProperty("initialBalance"))
//                 if (!$util.isInteger(message.initialBalance) && !(message.initialBalance && $util.isInteger(message.initialBalance.low) && $util.isInteger(message.initialBalance.high)))
//                     return "initialBalance: integer|Long expected";
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID")) {
//                 let error = $root.proto.AccountID.verify(message.proxyAccountID);
//                 if (error)
//                     return "proxyAccountID." + error;
//             }
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                 let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                 if (error)
//                     return "autoRenewPeriod." + error;
//             }
//             if (message.constructorParameters != null && message.hasOwnProperty("constructorParameters"))
//                 if (!(message.constructorParameters && typeof message.constructorParameters.length === "number" || $util.isString(message.constructorParameters)))
//                     return "constructorParameters: buffer expected";
//             if (message.shardID != null && message.hasOwnProperty("shardID")) {
//                 let error = $root.proto.ShardID.verify(message.shardID);
//                 if (error)
//                     return "shardID." + error;
//             }
//             if (message.realmID != null && message.hasOwnProperty("realmID")) {
//                 let error = $root.proto.RealmID.verify(message.realmID);
//                 if (error)
//                     return "realmID." + error;
//             }
//             if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey")) {
//                 let error = $root.proto.Key.verify(message.newRealmAdminKey);
//                 if (error)
//                     return "newRealmAdminKey." + error;
//             }
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 if (!$util.isString(message.memo))
//                     return "memo: string expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ContractCreateTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody
//          */
//         ContractCreateTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractCreateTransactionBody)
//                 return object;
//             let message = new $root.proto.ContractCreateTransactionBody();
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.ContractCreateTransactionBody.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.adminKey != null) {
//                 if (typeof object.adminKey !== "object")
//                     throw TypeError(".proto.ContractCreateTransactionBody.adminKey: object expected");
//                 message.adminKey = $root.proto.Key.fromObject(object.adminKey);
//             }
//             if (object.gas != null)
//                 if ($util.Long)
//                     (message.gas = $util.Long.fromValue(object.gas)).unsigned = false;
//                 else if (typeof object.gas === "string")
//                     message.gas = parseInt(object.gas, 10);
//                 else if (typeof object.gas === "number")
//                     message.gas = object.gas;
//                 else if (typeof object.gas === "object")
//                     message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber();
//             if (object.initialBalance != null)
//                 if ($util.Long)
//                     (message.initialBalance = $util.Long.fromValue(object.initialBalance)).unsigned = false;
//                 else if (typeof object.initialBalance === "string")
//                     message.initialBalance = parseInt(object.initialBalance, 10);
//                 else if (typeof object.initialBalance === "number")
//                     message.initialBalance = object.initialBalance;
//                 else if (typeof object.initialBalance === "object")
//                     message.initialBalance = new $util.LongBits(object.initialBalance.low >>> 0, object.initialBalance.high >>> 0).toNumber();
//             if (object.proxyAccountID != null) {
//                 if (typeof object.proxyAccountID !== "object")
//                     throw TypeError(".proto.ContractCreateTransactionBody.proxyAccountID: object expected");
//                 message.proxyAccountID = $root.proto.AccountID.fromObject(object.proxyAccountID);
//             }
//             if (object.autoRenewPeriod != null) {
//                 if (typeof object.autoRenewPeriod !== "object")
//                     throw TypeError(".proto.ContractCreateTransactionBody.autoRenewPeriod: object expected");
//                 message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//             }
//             if (object.constructorParameters != null)
//                 if (typeof object.constructorParameters === "string")
//                     $util.base64.decode(object.constructorParameters, message.constructorParameters = $util.newBuffer($util.base64.length(object.constructorParameters)), 0);
//                 else if (object.constructorParameters.length)
//                     message.constructorParameters = object.constructorParameters;
//             if (object.shardID != null) {
//                 if (typeof object.shardID !== "object")
//                     throw TypeError(".proto.ContractCreateTransactionBody.shardID: object expected");
//                 message.shardID = $root.proto.ShardID.fromObject(object.shardID);
//             }
//             if (object.realmID != null) {
//                 if (typeof object.realmID !== "object")
//                     throw TypeError(".proto.ContractCreateTransactionBody.realmID: object expected");
//                 message.realmID = $root.proto.RealmID.fromObject(object.realmID);
//             }
//             if (object.newRealmAdminKey != null) {
//                 if (typeof object.newRealmAdminKey !== "object")
//                     throw TypeError(".proto.ContractCreateTransactionBody.newRealmAdminKey: object expected");
//                 message.newRealmAdminKey = $root.proto.Key.fromObject(object.newRealmAdminKey);
//             }
//             if (object.memo != null)
//                 message.memo = String(object.memo);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractCreateTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractCreateTransactionBody
//          * @static
//          * @param {proto.ContractCreateTransactionBody} message ContractCreateTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractCreateTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.fileID = null;
//                 object.adminKey = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.gas = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.initialBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.initialBalance = options.longs === String ? "0" : 0;
//                 object.proxyAccountID = null;
//                 object.autoRenewPeriod = null;
//                 if (options.bytes === String)
//                     object.constructorParameters = "";
//                 else {
//                     object.constructorParameters = [];
//                     if (options.bytes !== Array)
//                         object.constructorParameters = $util.newBuffer(object.constructorParameters);
//                 }
//                 object.shardID = null;
//                 object.realmID = null;
//                 object.newRealmAdminKey = null;
//                 object.memo = "";
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             if (message.adminKey != null && message.hasOwnProperty("adminKey"))
//                 object.adminKey = $root.proto.Key.toObject(message.adminKey, options);
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (typeof message.gas === "number")
//                     object.gas = options.longs === String ? String(message.gas) : message.gas;
//                 else
//                     object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber() : message.gas;
//             if (message.initialBalance != null && message.hasOwnProperty("initialBalance"))
//                 if (typeof message.initialBalance === "number")
//                     object.initialBalance = options.longs === String ? String(message.initialBalance) : message.initialBalance;
//                 else
//                     object.initialBalance = options.longs === String ? $util.Long.prototype.toString.call(message.initialBalance) : options.longs === Number ? new $util.LongBits(message.initialBalance.low >>> 0, message.initialBalance.high >>> 0).toNumber() : message.initialBalance;
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID"))
//                 object.proxyAccountID = $root.proto.AccountID.toObject(message.proxyAccountID, options);
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                 object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//             if (message.constructorParameters != null && message.hasOwnProperty("constructorParameters"))
//                 object.constructorParameters = options.bytes === String ? $util.base64.encode(message.constructorParameters, 0, message.constructorParameters.length) : options.bytes === Array ? Array.prototype.slice.call(message.constructorParameters) : message.constructorParameters;
//             if (message.shardID != null && message.hasOwnProperty("shardID"))
//                 object.shardID = $root.proto.ShardID.toObject(message.shardID, options);
//             if (message.realmID != null && message.hasOwnProperty("realmID"))
//                 object.realmID = $root.proto.RealmID.toObject(message.realmID, options);
//             if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey"))
//                 object.newRealmAdminKey = $root.proto.Key.toObject(message.newRealmAdminKey, options);
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = message.memo;
//             return object;
//         };
// 
//         /**
//          * Converts this ContractCreateTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ContractCreateTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractCreateTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractCreateTransactionBody;
//     })();
// 
//     proto.ContractUpdateTransactionBody = (function() {
// 
//         /**
//          * Properties of a ContractUpdateTransactionBody.
//          * @memberof proto
//          * @interface IContractUpdateTransactionBody
//          * @property {proto.IContractID|null} [contractID] ContractUpdateTransactionBody contractID
//          * @property {proto.ITimestamp|null} [expirationTime] ContractUpdateTransactionBody expirationTime
//          * @property {proto.IKey|null} [adminKey] ContractUpdateTransactionBody adminKey
//          * @property {proto.IAccountID|null} [proxyAccountID] ContractUpdateTransactionBody proxyAccountID
//          * @property {proto.IDuration|null} [autoRenewPeriod] ContractUpdateTransactionBody autoRenewPeriod
//          * @property {proto.IFileID|null} [fileID] ContractUpdateTransactionBody fileID
//          * @property {string|null} [memo] ContractUpdateTransactionBody memo
//          */
// 
//         /**
//          * Constructs a new ContractUpdateTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ContractUpdateTransactionBody.
//          * @implements IContractUpdateTransactionBody
//          * @constructor
//          * @param {proto.IContractUpdateTransactionBody=} [properties] Properties to set
//          */
//         function ContractUpdateTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractUpdateTransactionBody contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          */
//         ContractUpdateTransactionBody.prototype.contractID = null;
// 
//         /**
//          * ContractUpdateTransactionBody expirationTime.
//          * @member {proto.ITimestamp|null|undefined} expirationTime
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          */
//         ContractUpdateTransactionBody.prototype.expirationTime = null;
// 
//         /**
//          * ContractUpdateTransactionBody adminKey.
//          * @member {proto.IKey|null|undefined} adminKey
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          */
//         ContractUpdateTransactionBody.prototype.adminKey = null;
// 
//         /**
//          * ContractUpdateTransactionBody proxyAccountID.
//          * @member {proto.IAccountID|null|undefined} proxyAccountID
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          */
//         ContractUpdateTransactionBody.prototype.proxyAccountID = null;
// 
//         /**
//          * ContractUpdateTransactionBody autoRenewPeriod.
//          * @member {proto.IDuration|null|undefined} autoRenewPeriod
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          */
//         ContractUpdateTransactionBody.prototype.autoRenewPeriod = null;
// 
//         /**
//          * ContractUpdateTransactionBody fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          */
//         ContractUpdateTransactionBody.prototype.fileID = null;
// 
//         /**
//          * ContractUpdateTransactionBody memo.
//          * @member {string} memo
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          */
//         ContractUpdateTransactionBody.prototype.memo = "";
// 
//         /**
//          * Creates a new ContractUpdateTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {proto.IContractUpdateTransactionBody=} [properties] Properties to set
//          * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody instance
//          */
//         ContractUpdateTransactionBody.create = function create(properties) {
//             return new ContractUpdateTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractUpdateTransactionBody message. Does not implicitly {@link proto.ContractUpdateTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {proto.IContractUpdateTransactionBody} message ContractUpdateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractUpdateTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.adminKey != null && Object.hasOwnProperty.call(message, "adminKey"))
//                 $root.proto.Key.encode(message.adminKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.proxyAccountID != null && Object.hasOwnProperty.call(message, "proxyAccountID"))
//                 $root.proto.AccountID.encode(message.proxyAccountID, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                 $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 writer.uint32(/* id 9, wireType 2 =*/74).string(message.memo);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractUpdateTransactionBody message, length delimited. Does not implicitly {@link proto.ContractUpdateTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {proto.IContractUpdateTransactionBody} message ContractUpdateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractUpdateTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractUpdateTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractUpdateTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractUpdateTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.adminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.proxyAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 9:
//                     message.memo = reader.string();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractUpdateTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractUpdateTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractUpdateTransactionBody message.
//          * @function verify
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractUpdateTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.Timestamp.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             if (message.adminKey != null && message.hasOwnProperty("adminKey")) {
//                 let error = $root.proto.Key.verify(message.adminKey);
//                 if (error)
//                     return "adminKey." + error;
//             }
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID")) {
//                 let error = $root.proto.AccountID.verify(message.proxyAccountID);
//                 if (error)
//                     return "proxyAccountID." + error;
//             }
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                 let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                 if (error)
//                     return "autoRenewPeriod." + error;
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 if (!$util.isString(message.memo))
//                     return "memo: string expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ContractUpdateTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody
//          */
//         ContractUpdateTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractUpdateTransactionBody)
//                 return object;
//             let message = new $root.proto.ContractUpdateTransactionBody();
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractUpdateTransactionBody.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.ContractUpdateTransactionBody.expirationTime: object expected");
//                 message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//             }
//             if (object.adminKey != null) {
//                 if (typeof object.adminKey !== "object")
//                     throw TypeError(".proto.ContractUpdateTransactionBody.adminKey: object expected");
//                 message.adminKey = $root.proto.Key.fromObject(object.adminKey);
//             }
//             if (object.proxyAccountID != null) {
//                 if (typeof object.proxyAccountID !== "object")
//                     throw TypeError(".proto.ContractUpdateTransactionBody.proxyAccountID: object expected");
//                 message.proxyAccountID = $root.proto.AccountID.fromObject(object.proxyAccountID);
//             }
//             if (object.autoRenewPeriod != null) {
//                 if (typeof object.autoRenewPeriod !== "object")
//                     throw TypeError(".proto.ContractUpdateTransactionBody.autoRenewPeriod: object expected");
//                 message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//             }
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.ContractUpdateTransactionBody.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.memo != null)
//                 message.memo = String(object.memo);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractUpdateTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractUpdateTransactionBody
//          * @static
//          * @param {proto.ContractUpdateTransactionBody} message ContractUpdateTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractUpdateTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.contractID = null;
//                 object.expirationTime = null;
//                 object.adminKey = null;
//                 object.proxyAccountID = null;
//                 object.autoRenewPeriod = null;
//                 object.fileID = null;
//                 object.memo = "";
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//             if (message.adminKey != null && message.hasOwnProperty("adminKey"))
//                 object.adminKey = $root.proto.Key.toObject(message.adminKey, options);
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID"))
//                 object.proxyAccountID = $root.proto.AccountID.toObject(message.proxyAccountID, options);
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                 object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = message.memo;
//             return object;
//         };
// 
//         /**
//          * Converts this ContractUpdateTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ContractUpdateTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractUpdateTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractUpdateTransactionBody;
//     })();
// 
//     proto.LiveHash = (function() {
// 
//         /**
//          * Properties of a LiveHash.
//          * @memberof proto
//          * @interface ILiveHash
//          * @property {proto.IAccountID|null} [accountId] LiveHash accountId
//          * @property {Uint8Array|null} [hash] LiveHash hash
//          * @property {proto.IKeyList|null} [keys] LiveHash keys
//          * @property {proto.IDuration|null} [duration] LiveHash duration
//          */
// 
//         /**
//          * Constructs a new LiveHash.
//          * @memberof proto
//          * @classdesc Represents a LiveHash.
//          * @implements ILiveHash
//          * @constructor
//          * @param {proto.ILiveHash=} [properties] Properties to set
//          */
//         function LiveHash(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * LiveHash accountId.
//          * @member {proto.IAccountID|null|undefined} accountId
//          * @memberof proto.LiveHash
//          * @instance
//          */
//         LiveHash.prototype.accountId = null;
// 
//         /**
//          * LiveHash hash.
//          * @member {Uint8Array} hash
//          * @memberof proto.LiveHash
//          * @instance
//          */
//         LiveHash.prototype.hash = $util.newBuffer([]);
// 
//         /**
//          * LiveHash keys.
//          * @member {proto.IKeyList|null|undefined} keys
//          * @memberof proto.LiveHash
//          * @instance
//          */
//         LiveHash.prototype.keys = null;
// 
//         /**
//          * LiveHash duration.
//          * @member {proto.IDuration|null|undefined} duration
//          * @memberof proto.LiveHash
//          * @instance
//          */
//         LiveHash.prototype.duration = null;
// 
//         /**
//          * Creates a new LiveHash instance using the specified properties.
//          * @function create
//          * @memberof proto.LiveHash
//          * @static
//          * @param {proto.ILiveHash=} [properties] Properties to set
//          * @returns {proto.LiveHash} LiveHash instance
//          */
//         LiveHash.create = function create(properties) {
//             return new LiveHash(properties);
//         };
// 
//         /**
//          * Encodes the specified LiveHash message. Does not implicitly {@link proto.LiveHash.verify|verify} messages.
//          * @function encode
//          * @memberof proto.LiveHash
//          * @static
//          * @param {proto.ILiveHash} message LiveHash message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         LiveHash.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
//                 $root.proto.AccountID.encode(message.accountId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
//             if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
//                 $root.proto.KeyList.encode(message.keys, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
//                 $root.proto.Duration.encode(message.duration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified LiveHash message, length delimited. Does not implicitly {@link proto.LiveHash.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.LiveHash
//          * @static
//          * @param {proto.ILiveHash} message LiveHash message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         LiveHash.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a LiveHash message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.LiveHash
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.LiveHash} LiveHash
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         LiveHash.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.LiveHash();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountId = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.hash = reader.bytes();
//                     break;
//                 case 3:
//                     message.keys = $root.proto.KeyList.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.duration = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a LiveHash message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.LiveHash
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.LiveHash} LiveHash
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         LiveHash.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a LiveHash message.
//          * @function verify
//          * @memberof proto.LiveHash
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         LiveHash.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountId != null && message.hasOwnProperty("accountId")) {
//                 let error = $root.proto.AccountID.verify(message.accountId);
//                 if (error)
//                     return "accountId." + error;
//             }
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
//                     return "hash: buffer expected";
//             if (message.keys != null && message.hasOwnProperty("keys")) {
//                 let error = $root.proto.KeyList.verify(message.keys);
//                 if (error)
//                     return "keys." + error;
//             }
//             if (message.duration != null && message.hasOwnProperty("duration")) {
//                 let error = $root.proto.Duration.verify(message.duration);
//                 if (error)
//                     return "duration." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a LiveHash message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.LiveHash
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.LiveHash} LiveHash
//          */
//         LiveHash.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.LiveHash)
//                 return object;
//             let message = new $root.proto.LiveHash();
//             if (object.accountId != null) {
//                 if (typeof object.accountId !== "object")
//                     throw TypeError(".proto.LiveHash.accountId: object expected");
//                 message.accountId = $root.proto.AccountID.fromObject(object.accountId);
//             }
//             if (object.hash != null)
//                 if (typeof object.hash === "string")
//                     $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
//                 else if (object.hash.length)
//                     message.hash = object.hash;
//             if (object.keys != null) {
//                 if (typeof object.keys !== "object")
//                     throw TypeError(".proto.LiveHash.keys: object expected");
//                 message.keys = $root.proto.KeyList.fromObject(object.keys);
//             }
//             if (object.duration != null) {
//                 if (typeof object.duration !== "object")
//                     throw TypeError(".proto.LiveHash.duration: object expected");
//                 message.duration = $root.proto.Duration.fromObject(object.duration);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a LiveHash message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.LiveHash
//          * @static
//          * @param {proto.LiveHash} message LiveHash
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         LiveHash.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.accountId = null;
//                 if (options.bytes === String)
//                     object.hash = "";
//                 else {
//                     object.hash = [];
//                     if (options.bytes !== Array)
//                         object.hash = $util.newBuffer(object.hash);
//                 }
//                 object.keys = null;
//                 object.duration = null;
//             }
//             if (message.accountId != null && message.hasOwnProperty("accountId"))
//                 object.accountId = $root.proto.AccountID.toObject(message.accountId, options);
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
//             if (message.keys != null && message.hasOwnProperty("keys"))
//                 object.keys = $root.proto.KeyList.toObject(message.keys, options);
//             if (message.duration != null && message.hasOwnProperty("duration"))
//                 object.duration = $root.proto.Duration.toObject(message.duration, options);
//             return object;
//         };
// 
//         /**
//          * Converts this LiveHash to JSON.
//          * @function toJSON
//          * @memberof proto.LiveHash
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         LiveHash.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return LiveHash;
//     })();
// 
//     proto.CryptoAddLiveHashTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoAddLiveHashTransactionBody.
//          * @memberof proto
//          * @interface ICryptoAddLiveHashTransactionBody
//          * @property {proto.ILiveHash|null} [liveHash] CryptoAddLiveHashTransactionBody liveHash
//          */
// 
//         /**
//          * Constructs a new CryptoAddLiveHashTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoAddLiveHashTransactionBody.
//          * @implements ICryptoAddLiveHashTransactionBody
//          * @constructor
//          * @param {proto.ICryptoAddLiveHashTransactionBody=} [properties] Properties to set
//          */
//         function CryptoAddLiveHashTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoAddLiveHashTransactionBody liveHash.
//          * @member {proto.ILiveHash|null|undefined} liveHash
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @instance
//          */
//         CryptoAddLiveHashTransactionBody.prototype.liveHash = null;
// 
//         /**
//          * Creates a new CryptoAddLiveHashTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {proto.ICryptoAddLiveHashTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody instance
//          */
//         CryptoAddLiveHashTransactionBody.create = function create(properties) {
//             return new CryptoAddLiveHashTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoAddLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoAddLiveHashTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {proto.ICryptoAddLiveHashTransactionBody} message CryptoAddLiveHashTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoAddLiveHashTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.liveHash != null && Object.hasOwnProperty.call(message, "liveHash"))
//                 $root.proto.LiveHash.encode(message.liveHash, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoAddLiveHashTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoAddLiveHashTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {proto.ICryptoAddLiveHashTransactionBody} message CryptoAddLiveHashTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoAddLiveHashTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoAddLiveHashTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoAddLiveHashTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoAddLiveHashTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 3:
//                     message.liveHash = $root.proto.LiveHash.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoAddLiveHashTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoAddLiveHashTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoAddLiveHashTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoAddLiveHashTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.liveHash != null && message.hasOwnProperty("liveHash")) {
//                 let error = $root.proto.LiveHash.verify(message.liveHash);
//                 if (error)
//                     return "liveHash." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoAddLiveHashTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody
//          */
//         CryptoAddLiveHashTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoAddLiveHashTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoAddLiveHashTransactionBody();
//             if (object.liveHash != null) {
//                 if (typeof object.liveHash !== "object")
//                     throw TypeError(".proto.CryptoAddLiveHashTransactionBody.liveHash: object expected");
//                 message.liveHash = $root.proto.LiveHash.fromObject(object.liveHash);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoAddLiveHashTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @static
//          * @param {proto.CryptoAddLiveHashTransactionBody} message CryptoAddLiveHashTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoAddLiveHashTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.liveHash = null;
//             if (message.liveHash != null && message.hasOwnProperty("liveHash"))
//                 object.liveHash = $root.proto.LiveHash.toObject(message.liveHash, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoAddLiveHashTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoAddLiveHashTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoAddLiveHashTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoAddLiveHashTransactionBody;
//     })();
// 
//     proto.CryptoCreateTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoCreateTransactionBody.
//          * @memberof proto
//          * @interface ICryptoCreateTransactionBody
//          * @property {proto.IKey|null} [key] CryptoCreateTransactionBody key
//          * @property {number|Long|null} [initialBalance] CryptoCreateTransactionBody initialBalance
//          * @property {proto.IAccountID|null} [proxyAccountID] CryptoCreateTransactionBody proxyAccountID
//          * @property {number|Long|null} [sendRecordThreshold] CryptoCreateTransactionBody sendRecordThreshold
//          * @property {number|Long|null} [receiveRecordThreshold] CryptoCreateTransactionBody receiveRecordThreshold
//          * @property {boolean|null} [receiverSigRequired] CryptoCreateTransactionBody receiverSigRequired
//          * @property {proto.IDuration|null} [autoRenewPeriod] CryptoCreateTransactionBody autoRenewPeriod
//          * @property {proto.IShardID|null} [shardID] CryptoCreateTransactionBody shardID
//          * @property {proto.IRealmID|null} [realmID] CryptoCreateTransactionBody realmID
//          * @property {proto.IKey|null} [newRealmAdminKey] CryptoCreateTransactionBody newRealmAdminKey
//          */
// 
//         /**
//          * Constructs a new CryptoCreateTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoCreateTransactionBody.
//          * @implements ICryptoCreateTransactionBody
//          * @constructor
//          * @param {proto.ICryptoCreateTransactionBody=} [properties] Properties to set
//          */
//         function CryptoCreateTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoCreateTransactionBody key.
//          * @member {proto.IKey|null|undefined} key
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.key = null;
// 
//         /**
//          * CryptoCreateTransactionBody initialBalance.
//          * @member {number|Long} initialBalance
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * CryptoCreateTransactionBody proxyAccountID.
//          * @member {proto.IAccountID|null|undefined} proxyAccountID
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.proxyAccountID = null;
// 
//         /**
//          * CryptoCreateTransactionBody sendRecordThreshold.
//          * @member {number|Long} sendRecordThreshold
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * CryptoCreateTransactionBody receiveRecordThreshold.
//          * @member {number|Long} receiveRecordThreshold
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * CryptoCreateTransactionBody receiverSigRequired.
//          * @member {boolean} receiverSigRequired
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.receiverSigRequired = false;
// 
//         /**
//          * CryptoCreateTransactionBody autoRenewPeriod.
//          * @member {proto.IDuration|null|undefined} autoRenewPeriod
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.autoRenewPeriod = null;
// 
//         /**
//          * CryptoCreateTransactionBody shardID.
//          * @member {proto.IShardID|null|undefined} shardID
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.shardID = null;
// 
//         /**
//          * CryptoCreateTransactionBody realmID.
//          * @member {proto.IRealmID|null|undefined} realmID
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.realmID = null;
// 
//         /**
//          * CryptoCreateTransactionBody newRealmAdminKey.
//          * @member {proto.IKey|null|undefined} newRealmAdminKey
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          */
//         CryptoCreateTransactionBody.prototype.newRealmAdminKey = null;
// 
//         /**
//          * Creates a new CryptoCreateTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {proto.ICryptoCreateTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody instance
//          */
//         CryptoCreateTransactionBody.create = function create(properties) {
//             return new CryptoCreateTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {proto.ICryptoCreateTransactionBody} message CryptoCreateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoCreateTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.key != null && Object.hasOwnProperty.call(message, "key"))
//                 $root.proto.Key.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.initialBalance != null && Object.hasOwnProperty.call(message, "initialBalance"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.initialBalance);
//             if (message.proxyAccountID != null && Object.hasOwnProperty.call(message, "proxyAccountID"))
//                 $root.proto.AccountID.encode(message.proxyAccountID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.sendRecordThreshold != null && Object.hasOwnProperty.call(message, "sendRecordThreshold"))
//                 writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.sendRecordThreshold);
//             if (message.receiveRecordThreshold != null && Object.hasOwnProperty.call(message, "receiveRecordThreshold"))
//                 writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.receiveRecordThreshold);
//             if (message.receiverSigRequired != null && Object.hasOwnProperty.call(message, "receiverSigRequired"))
//                 writer.uint32(/* id 8, wireType 0 =*/64).bool(message.receiverSigRequired);
//             if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                 $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
//             if (message.shardID != null && Object.hasOwnProperty.call(message, "shardID"))
//                 $root.proto.ShardID.encode(message.shardID, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
//             if (message.realmID != null && Object.hasOwnProperty.call(message, "realmID"))
//                 $root.proto.RealmID.encode(message.realmID, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
//             if (message.newRealmAdminKey != null && Object.hasOwnProperty.call(message, "newRealmAdminKey"))
//                 $root.proto.Key.encode(message.newRealmAdminKey, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoCreateTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {proto.ICryptoCreateTransactionBody} message CryptoCreateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoCreateTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoCreateTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoCreateTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.key = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.initialBalance = reader.uint64();
//                     break;
//                 case 3:
//                     message.proxyAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.sendRecordThreshold = reader.uint64();
//                     break;
//                 case 7:
//                     message.receiveRecordThreshold = reader.uint64();
//                     break;
//                 case 8:
//                     message.receiverSigRequired = reader.bool();
//                     break;
//                 case 9:
//                     message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 10:
//                     message.shardID = $root.proto.ShardID.decode(reader, reader.uint32());
//                     break;
//                 case 11:
//                     message.realmID = $root.proto.RealmID.decode(reader, reader.uint32());
//                     break;
//                 case 12:
//                     message.newRealmAdminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoCreateTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoCreateTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoCreateTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.key != null && message.hasOwnProperty("key")) {
//                 let error = $root.proto.Key.verify(message.key);
//                 if (error)
//                     return "key." + error;
//             }
//             if (message.initialBalance != null && message.hasOwnProperty("initialBalance"))
//                 if (!$util.isInteger(message.initialBalance) && !(message.initialBalance && $util.isInteger(message.initialBalance.low) && $util.isInteger(message.initialBalance.high)))
//                     return "initialBalance: integer|Long expected";
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID")) {
//                 let error = $root.proto.AccountID.verify(message.proxyAccountID);
//                 if (error)
//                     return "proxyAccountID." + error;
//             }
//             if (message.sendRecordThreshold != null && message.hasOwnProperty("sendRecordThreshold"))
//                 if (!$util.isInteger(message.sendRecordThreshold) && !(message.sendRecordThreshold && $util.isInteger(message.sendRecordThreshold.low) && $util.isInteger(message.sendRecordThreshold.high)))
//                     return "sendRecordThreshold: integer|Long expected";
//             if (message.receiveRecordThreshold != null && message.hasOwnProperty("receiveRecordThreshold"))
//                 if (!$util.isInteger(message.receiveRecordThreshold) && !(message.receiveRecordThreshold && $util.isInteger(message.receiveRecordThreshold.low) && $util.isInteger(message.receiveRecordThreshold.high)))
//                     return "receiveRecordThreshold: integer|Long expected";
//             if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired"))
//                 if (typeof message.receiverSigRequired !== "boolean")
//                     return "receiverSigRequired: boolean expected";
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                 let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                 if (error)
//                     return "autoRenewPeriod." + error;
//             }
//             if (message.shardID != null && message.hasOwnProperty("shardID")) {
//                 let error = $root.proto.ShardID.verify(message.shardID);
//                 if (error)
//                     return "shardID." + error;
//             }
//             if (message.realmID != null && message.hasOwnProperty("realmID")) {
//                 let error = $root.proto.RealmID.verify(message.realmID);
//                 if (error)
//                     return "realmID." + error;
//             }
//             if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey")) {
//                 let error = $root.proto.Key.verify(message.newRealmAdminKey);
//                 if (error)
//                     return "newRealmAdminKey." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoCreateTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
//          */
//         CryptoCreateTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoCreateTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoCreateTransactionBody();
//             if (object.key != null) {
//                 if (typeof object.key !== "object")
//                     throw TypeError(".proto.CryptoCreateTransactionBody.key: object expected");
//                 message.key = $root.proto.Key.fromObject(object.key);
//             }
//             if (object.initialBalance != null)
//                 if ($util.Long)
//                     (message.initialBalance = $util.Long.fromValue(object.initialBalance)).unsigned = true;
//                 else if (typeof object.initialBalance === "string")
//                     message.initialBalance = parseInt(object.initialBalance, 10);
//                 else if (typeof object.initialBalance === "number")
//                     message.initialBalance = object.initialBalance;
//                 else if (typeof object.initialBalance === "object")
//                     message.initialBalance = new $util.LongBits(object.initialBalance.low >>> 0, object.initialBalance.high >>> 0).toNumber(true);
//             if (object.proxyAccountID != null) {
//                 if (typeof object.proxyAccountID !== "object")
//                     throw TypeError(".proto.CryptoCreateTransactionBody.proxyAccountID: object expected");
//                 message.proxyAccountID = $root.proto.AccountID.fromObject(object.proxyAccountID);
//             }
//             if (object.sendRecordThreshold != null)
//                 if ($util.Long)
//                     (message.sendRecordThreshold = $util.Long.fromValue(object.sendRecordThreshold)).unsigned = true;
//                 else if (typeof object.sendRecordThreshold === "string")
//                     message.sendRecordThreshold = parseInt(object.sendRecordThreshold, 10);
//                 else if (typeof object.sendRecordThreshold === "number")
//                     message.sendRecordThreshold = object.sendRecordThreshold;
//                 else if (typeof object.sendRecordThreshold === "object")
//                     message.sendRecordThreshold = new $util.LongBits(object.sendRecordThreshold.low >>> 0, object.sendRecordThreshold.high >>> 0).toNumber(true);
//             if (object.receiveRecordThreshold != null)
//                 if ($util.Long)
//                     (message.receiveRecordThreshold = $util.Long.fromValue(object.receiveRecordThreshold)).unsigned = true;
//                 else if (typeof object.receiveRecordThreshold === "string")
//                     message.receiveRecordThreshold = parseInt(object.receiveRecordThreshold, 10);
//                 else if (typeof object.receiveRecordThreshold === "number")
//                     message.receiveRecordThreshold = object.receiveRecordThreshold;
//                 else if (typeof object.receiveRecordThreshold === "object")
//                     message.receiveRecordThreshold = new $util.LongBits(object.receiveRecordThreshold.low >>> 0, object.receiveRecordThreshold.high >>> 0).toNumber(true);
//             if (object.receiverSigRequired != null)
//                 message.receiverSigRequired = Boolean(object.receiverSigRequired);
//             if (object.autoRenewPeriod != null) {
//                 if (typeof object.autoRenewPeriod !== "object")
//                     throw TypeError(".proto.CryptoCreateTransactionBody.autoRenewPeriod: object expected");
//                 message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//             }
//             if (object.shardID != null) {
//                 if (typeof object.shardID !== "object")
//                     throw TypeError(".proto.CryptoCreateTransactionBody.shardID: object expected");
//                 message.shardID = $root.proto.ShardID.fromObject(object.shardID);
//             }
//             if (object.realmID != null) {
//                 if (typeof object.realmID !== "object")
//                     throw TypeError(".proto.CryptoCreateTransactionBody.realmID: object expected");
//                 message.realmID = $root.proto.RealmID.fromObject(object.realmID);
//             }
//             if (object.newRealmAdminKey != null) {
//                 if (typeof object.newRealmAdminKey !== "object")
//                     throw TypeError(".proto.CryptoCreateTransactionBody.newRealmAdminKey: object expected");
//                 message.newRealmAdminKey = $root.proto.Key.fromObject(object.newRealmAdminKey);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoCreateTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoCreateTransactionBody
//          * @static
//          * @param {proto.CryptoCreateTransactionBody} message CryptoCreateTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoCreateTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.key = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.initialBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.initialBalance = options.longs === String ? "0" : 0;
//                 object.proxyAccountID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.sendRecordThreshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.sendRecordThreshold = options.longs === String ? "0" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.receiveRecordThreshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.receiveRecordThreshold = options.longs === String ? "0" : 0;
//                 object.receiverSigRequired = false;
//                 object.autoRenewPeriod = null;
//                 object.shardID = null;
//                 object.realmID = null;
//                 object.newRealmAdminKey = null;
//             }
//             if (message.key != null && message.hasOwnProperty("key"))
//                 object.key = $root.proto.Key.toObject(message.key, options);
//             if (message.initialBalance != null && message.hasOwnProperty("initialBalance"))
//                 if (typeof message.initialBalance === "number")
//                     object.initialBalance = options.longs === String ? String(message.initialBalance) : message.initialBalance;
//                 else
//                     object.initialBalance = options.longs === String ? $util.Long.prototype.toString.call(message.initialBalance) : options.longs === Number ? new $util.LongBits(message.initialBalance.low >>> 0, message.initialBalance.high >>> 0).toNumber(true) : message.initialBalance;
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID"))
//                 object.proxyAccountID = $root.proto.AccountID.toObject(message.proxyAccountID, options);
//             if (message.sendRecordThreshold != null && message.hasOwnProperty("sendRecordThreshold"))
//                 if (typeof message.sendRecordThreshold === "number")
//                     object.sendRecordThreshold = options.longs === String ? String(message.sendRecordThreshold) : message.sendRecordThreshold;
//                 else
//                     object.sendRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.sendRecordThreshold) : options.longs === Number ? new $util.LongBits(message.sendRecordThreshold.low >>> 0, message.sendRecordThreshold.high >>> 0).toNumber(true) : message.sendRecordThreshold;
//             if (message.receiveRecordThreshold != null && message.hasOwnProperty("receiveRecordThreshold"))
//                 if (typeof message.receiveRecordThreshold === "number")
//                     object.receiveRecordThreshold = options.longs === String ? String(message.receiveRecordThreshold) : message.receiveRecordThreshold;
//                 else
//                     object.receiveRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.receiveRecordThreshold) : options.longs === Number ? new $util.LongBits(message.receiveRecordThreshold.low >>> 0, message.receiveRecordThreshold.high >>> 0).toNumber(true) : message.receiveRecordThreshold;
//             if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired"))
//                 object.receiverSigRequired = message.receiverSigRequired;
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                 object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//             if (message.shardID != null && message.hasOwnProperty("shardID"))
//                 object.shardID = $root.proto.ShardID.toObject(message.shardID, options);
//             if (message.realmID != null && message.hasOwnProperty("realmID"))
//                 object.realmID = $root.proto.RealmID.toObject(message.realmID, options);
//             if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey"))
//                 object.newRealmAdminKey = $root.proto.Key.toObject(message.newRealmAdminKey, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoCreateTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoCreateTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoCreateTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoCreateTransactionBody;
//     })();
// 
//     proto.CryptoDeleteTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoDeleteTransactionBody.
//          * @memberof proto
//          * @interface ICryptoDeleteTransactionBody
//          * @property {proto.IAccountID|null} [transferAccountID] CryptoDeleteTransactionBody transferAccountID
//          * @property {proto.IAccountID|null} [deleteAccountID] CryptoDeleteTransactionBody deleteAccountID
//          */
// 
//         /**
//          * Constructs a new CryptoDeleteTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoDeleteTransactionBody.
//          * @implements ICryptoDeleteTransactionBody
//          * @constructor
//          * @param {proto.ICryptoDeleteTransactionBody=} [properties] Properties to set
//          */
//         function CryptoDeleteTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoDeleteTransactionBody transferAccountID.
//          * @member {proto.IAccountID|null|undefined} transferAccountID
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @instance
//          */
//         CryptoDeleteTransactionBody.prototype.transferAccountID = null;
// 
//         /**
//          * CryptoDeleteTransactionBody deleteAccountID.
//          * @member {proto.IAccountID|null|undefined} deleteAccountID
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @instance
//          */
//         CryptoDeleteTransactionBody.prototype.deleteAccountID = null;
// 
//         /**
//          * Creates a new CryptoDeleteTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody instance
//          */
//         CryptoDeleteTransactionBody.create = function create(properties) {
//             return new CryptoDeleteTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoDeleteTransactionBody message. Does not implicitly {@link proto.CryptoDeleteTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteTransactionBody} message CryptoDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoDeleteTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.transferAccountID != null && Object.hasOwnProperty.call(message, "transferAccountID"))
//                 $root.proto.AccountID.encode(message.transferAccountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.deleteAccountID != null && Object.hasOwnProperty.call(message, "deleteAccountID"))
//                 $root.proto.AccountID.encode(message.deleteAccountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoDeleteTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoDeleteTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteTransactionBody} message CryptoDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoDeleteTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoDeleteTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoDeleteTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoDeleteTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.transferAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.deleteAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoDeleteTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoDeleteTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoDeleteTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoDeleteTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.transferAccountID != null && message.hasOwnProperty("transferAccountID")) {
//                 let error = $root.proto.AccountID.verify(message.transferAccountID);
//                 if (error)
//                     return "transferAccountID." + error;
//             }
//             if (message.deleteAccountID != null && message.hasOwnProperty("deleteAccountID")) {
//                 let error = $root.proto.AccountID.verify(message.deleteAccountID);
//                 if (error)
//                     return "deleteAccountID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoDeleteTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody
//          */
//         CryptoDeleteTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoDeleteTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoDeleteTransactionBody();
//             if (object.transferAccountID != null) {
//                 if (typeof object.transferAccountID !== "object")
//                     throw TypeError(".proto.CryptoDeleteTransactionBody.transferAccountID: object expected");
//                 message.transferAccountID = $root.proto.AccountID.fromObject(object.transferAccountID);
//             }
//             if (object.deleteAccountID != null) {
//                 if (typeof object.deleteAccountID !== "object")
//                     throw TypeError(".proto.CryptoDeleteTransactionBody.deleteAccountID: object expected");
//                 message.deleteAccountID = $root.proto.AccountID.fromObject(object.deleteAccountID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoDeleteTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @static
//          * @param {proto.CryptoDeleteTransactionBody} message CryptoDeleteTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoDeleteTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.transferAccountID = null;
//                 object.deleteAccountID = null;
//             }
//             if (message.transferAccountID != null && message.hasOwnProperty("transferAccountID"))
//                 object.transferAccountID = $root.proto.AccountID.toObject(message.transferAccountID, options);
//             if (message.deleteAccountID != null && message.hasOwnProperty("deleteAccountID"))
//                 object.deleteAccountID = $root.proto.AccountID.toObject(message.deleteAccountID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoDeleteTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoDeleteTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoDeleteTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoDeleteTransactionBody;
//     })();
// 
//     proto.CryptoDeleteLiveHashTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoDeleteLiveHashTransactionBody.
//          * @memberof proto
//          * @interface ICryptoDeleteLiveHashTransactionBody
//          * @property {proto.IAccountID|null} [accountOfLiveHash] CryptoDeleteLiveHashTransactionBody accountOfLiveHash
//          * @property {Uint8Array|null} [liveHashToDelete] CryptoDeleteLiveHashTransactionBody liveHashToDelete
//          */
// 
//         /**
//          * Constructs a new CryptoDeleteLiveHashTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoDeleteLiveHashTransactionBody.
//          * @implements ICryptoDeleteLiveHashTransactionBody
//          * @constructor
//          * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [properties] Properties to set
//          */
//         function CryptoDeleteLiveHashTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoDeleteLiveHashTransactionBody accountOfLiveHash.
//          * @member {proto.IAccountID|null|undefined} accountOfLiveHash
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @instance
//          */
//         CryptoDeleteLiveHashTransactionBody.prototype.accountOfLiveHash = null;
// 
//         /**
//          * CryptoDeleteLiveHashTransactionBody liveHashToDelete.
//          * @member {Uint8Array} liveHashToDelete
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @instance
//          */
//         CryptoDeleteLiveHashTransactionBody.prototype.liveHashToDelete = $util.newBuffer([]);
// 
//         /**
//          * Creates a new CryptoDeleteLiveHashTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody instance
//          */
//         CryptoDeleteLiveHashTransactionBody.create = function create(properties) {
//             return new CryptoDeleteLiveHashTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoDeleteLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoDeleteLiveHashTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteLiveHashTransactionBody} message CryptoDeleteLiveHashTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoDeleteLiveHashTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountOfLiveHash != null && Object.hasOwnProperty.call(message, "accountOfLiveHash"))
//                 $root.proto.AccountID.encode(message.accountOfLiveHash, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.liveHashToDelete != null && Object.hasOwnProperty.call(message, "liveHashToDelete"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.liveHashToDelete);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoDeleteLiveHashTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoDeleteLiveHashTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteLiveHashTransactionBody} message CryptoDeleteLiveHashTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoDeleteLiveHashTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoDeleteLiveHashTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoDeleteLiveHashTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoDeleteLiveHashTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountOfLiveHash = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.liveHashToDelete = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoDeleteLiveHashTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoDeleteLiveHashTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoDeleteLiveHashTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoDeleteLiveHashTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountOfLiveHash != null && message.hasOwnProperty("accountOfLiveHash")) {
//                 let error = $root.proto.AccountID.verify(message.accountOfLiveHash);
//                 if (error)
//                     return "accountOfLiveHash." + error;
//             }
//             if (message.liveHashToDelete != null && message.hasOwnProperty("liveHashToDelete"))
//                 if (!(message.liveHashToDelete && typeof message.liveHashToDelete.length === "number" || $util.isString(message.liveHashToDelete)))
//                     return "liveHashToDelete: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoDeleteLiveHashTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody
//          */
//         CryptoDeleteLiveHashTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoDeleteLiveHashTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoDeleteLiveHashTransactionBody();
//             if (object.accountOfLiveHash != null) {
//                 if (typeof object.accountOfLiveHash !== "object")
//                     throw TypeError(".proto.CryptoDeleteLiveHashTransactionBody.accountOfLiveHash: object expected");
//                 message.accountOfLiveHash = $root.proto.AccountID.fromObject(object.accountOfLiveHash);
//             }
//             if (object.liveHashToDelete != null)
//                 if (typeof object.liveHashToDelete === "string")
//                     $util.base64.decode(object.liveHashToDelete, message.liveHashToDelete = $util.newBuffer($util.base64.length(object.liveHashToDelete)), 0);
//                 else if (object.liveHashToDelete.length)
//                     message.liveHashToDelete = object.liveHashToDelete;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoDeleteLiveHashTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @static
//          * @param {proto.CryptoDeleteLiveHashTransactionBody} message CryptoDeleteLiveHashTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoDeleteLiveHashTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.accountOfLiveHash = null;
//                 if (options.bytes === String)
//                     object.liveHashToDelete = "";
//                 else {
//                     object.liveHashToDelete = [];
//                     if (options.bytes !== Array)
//                         object.liveHashToDelete = $util.newBuffer(object.liveHashToDelete);
//                 }
//             }
//             if (message.accountOfLiveHash != null && message.hasOwnProperty("accountOfLiveHash"))
//                 object.accountOfLiveHash = $root.proto.AccountID.toObject(message.accountOfLiveHash, options);
//             if (message.liveHashToDelete != null && message.hasOwnProperty("liveHashToDelete"))
//                 object.liveHashToDelete = options.bytes === String ? $util.base64.encode(message.liveHashToDelete, 0, message.liveHashToDelete.length) : options.bytes === Array ? Array.prototype.slice.call(message.liveHashToDelete) : message.liveHashToDelete;
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoDeleteLiveHashTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoDeleteLiveHashTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoDeleteLiveHashTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoDeleteLiveHashTransactionBody;
//     })();
// 
//     proto.AccountAmount = (function() {
// 
//         /**
//          * Properties of an AccountAmount.
//          * @memberof proto
//          * @interface IAccountAmount
//          * @property {proto.IAccountID|null} [accountID] AccountAmount accountID
//          * @property {number|Long|null} [amount] AccountAmount amount
//          */
// 
//         /**
//          * Constructs a new AccountAmount.
//          * @memberof proto
//          * @classdesc Represents an AccountAmount.
//          * @implements IAccountAmount
//          * @constructor
//          * @param {proto.IAccountAmount=} [properties] Properties to set
//          */
//         function AccountAmount(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * AccountAmount accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.AccountAmount
//          * @instance
//          */
//         AccountAmount.prototype.accountID = null;
// 
//         /**
//          * AccountAmount amount.
//          * @member {number|Long} amount
//          * @memberof proto.AccountAmount
//          * @instance
//          */
//         AccountAmount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new AccountAmount instance using the specified properties.
//          * @function create
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {proto.IAccountAmount=} [properties] Properties to set
//          * @returns {proto.AccountAmount} AccountAmount instance
//          */
//         AccountAmount.create = function create(properties) {
//             return new AccountAmount(properties);
//         };
// 
//         /**
//          * Encodes the specified AccountAmount message. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
//          * @function encode
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {proto.IAccountAmount} message AccountAmount message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         AccountAmount.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.amount);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified AccountAmount message, length delimited. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {proto.IAccountAmount} message AccountAmount message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         AccountAmount.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an AccountAmount message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.AccountAmount} AccountAmount
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         AccountAmount.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AccountAmount();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.amount = reader.sint64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an AccountAmount message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.AccountAmount} AccountAmount
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         AccountAmount.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an AccountAmount message.
//          * @function verify
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         AccountAmount.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.amount != null && message.hasOwnProperty("amount"))
//                 if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
//                     return "amount: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates an AccountAmount message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.AccountAmount} AccountAmount
//          */
//         AccountAmount.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.AccountAmount)
//                 return object;
//             let message = new $root.proto.AccountAmount();
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.AccountAmount.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.amount != null)
//                 if ($util.Long)
//                     (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
//                 else if (typeof object.amount === "string")
//                     message.amount = parseInt(object.amount, 10);
//                 else if (typeof object.amount === "number")
//                     message.amount = object.amount;
//                 else if (typeof object.amount === "object")
//                     message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an AccountAmount message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.AccountAmount
//          * @static
//          * @param {proto.AccountAmount} message AccountAmount
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         AccountAmount.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.accountID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.amount = options.longs === String ? "0" : 0;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.amount != null && message.hasOwnProperty("amount"))
//                 if (typeof message.amount === "number")
//                     object.amount = options.longs === String ? String(message.amount) : message.amount;
//                 else
//                     object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
//             return object;
//         };
// 
//         /**
//          * Converts this AccountAmount to JSON.
//          * @function toJSON
//          * @memberof proto.AccountAmount
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         AccountAmount.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return AccountAmount;
//     })();
// 
//     proto.TransferList = (function() {
// 
//         /**
//          * Properties of a TransferList.
//          * @memberof proto
//          * @interface ITransferList
//          * @property {Array.<proto.IAccountAmount>|null} [accountAmounts] TransferList accountAmounts
//          */
// 
//         /**
//          * Constructs a new TransferList.
//          * @memberof proto
//          * @classdesc Represents a TransferList.
//          * @implements ITransferList
//          * @constructor
//          * @param {proto.ITransferList=} [properties] Properties to set
//          */
//         function TransferList(properties) {
//             this.accountAmounts = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransferList accountAmounts.
//          * @member {Array.<proto.IAccountAmount>} accountAmounts
//          * @memberof proto.TransferList
//          * @instance
//          */
//         TransferList.prototype.accountAmounts = $util.emptyArray;
// 
//         /**
//          * Creates a new TransferList instance using the specified properties.
//          * @function create
//          * @memberof proto.TransferList
//          * @static
//          * @param {proto.ITransferList=} [properties] Properties to set
//          * @returns {proto.TransferList} TransferList instance
//          */
//         TransferList.create = function create(properties) {
//             return new TransferList(properties);
//         };
// 
//         /**
//          * Encodes the specified TransferList message. Does not implicitly {@link proto.TransferList.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransferList
//          * @static
//          * @param {proto.ITransferList} message TransferList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransferList.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountAmounts != null && message.accountAmounts.length)
//                 for (let i = 0; i < message.accountAmounts.length; ++i)
//                     $root.proto.AccountAmount.encode(message.accountAmounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransferList message, length delimited. Does not implicitly {@link proto.TransferList.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransferList
//          * @static
//          * @param {proto.ITransferList} message TransferList message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransferList.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransferList message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransferList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransferList} TransferList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransferList.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransferList();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     if (!(message.accountAmounts && message.accountAmounts.length))
//                         message.accountAmounts = [];
//                     message.accountAmounts.push($root.proto.AccountAmount.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransferList message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransferList
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransferList} TransferList
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransferList.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransferList message.
//          * @function verify
//          * @memberof proto.TransferList
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransferList.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountAmounts != null && message.hasOwnProperty("accountAmounts")) {
//                 if (!Array.isArray(message.accountAmounts))
//                     return "accountAmounts: array expected";
//                 for (let i = 0; i < message.accountAmounts.length; ++i) {
//                     let error = $root.proto.AccountAmount.verify(message.accountAmounts[i]);
//                     if (error)
//                         return "accountAmounts." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransferList message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransferList
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransferList} TransferList
//          */
//         TransferList.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransferList)
//                 return object;
//             let message = new $root.proto.TransferList();
//             if (object.accountAmounts) {
//                 if (!Array.isArray(object.accountAmounts))
//                     throw TypeError(".proto.TransferList.accountAmounts: array expected");
//                 message.accountAmounts = [];
//                 for (let i = 0; i < object.accountAmounts.length; ++i) {
//                     if (typeof object.accountAmounts[i] !== "object")
//                         throw TypeError(".proto.TransferList.accountAmounts: object expected");
//                     message.accountAmounts[i] = $root.proto.AccountAmount.fromObject(object.accountAmounts[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransferList message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransferList
//          * @static
//          * @param {proto.TransferList} message TransferList
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransferList.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.accountAmounts = [];
//             if (message.accountAmounts && message.accountAmounts.length) {
//                 object.accountAmounts = [];
//                 for (let j = 0; j < message.accountAmounts.length; ++j)
//                     object.accountAmounts[j] = $root.proto.AccountAmount.toObject(message.accountAmounts[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this TransferList to JSON.
//          * @function toJSON
//          * @memberof proto.TransferList
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransferList.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransferList;
//     })();
// 
//     proto.CryptoTransferTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoTransferTransactionBody.
//          * @memberof proto
//          * @interface ICryptoTransferTransactionBody
//          * @property {proto.ITransferList|null} [transfers] CryptoTransferTransactionBody transfers
//          */
// 
//         /**
//          * Constructs a new CryptoTransferTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoTransferTransactionBody.
//          * @implements ICryptoTransferTransactionBody
//          * @constructor
//          * @param {proto.ICryptoTransferTransactionBody=} [properties] Properties to set
//          */
//         function CryptoTransferTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoTransferTransactionBody transfers.
//          * @member {proto.ITransferList|null|undefined} transfers
//          * @memberof proto.CryptoTransferTransactionBody
//          * @instance
//          */
//         CryptoTransferTransactionBody.prototype.transfers = null;
// 
//         /**
//          * Creates a new CryptoTransferTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {proto.ICryptoTransferTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody instance
//          */
//         CryptoTransferTransactionBody.create = function create(properties) {
//             return new CryptoTransferTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {proto.ICryptoTransferTransactionBody} message CryptoTransferTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoTransferTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.transfers != null && Object.hasOwnProperty.call(message, "transfers"))
//                 $root.proto.TransferList.encode(message.transfers, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoTransferTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {proto.ICryptoTransferTransactionBody} message CryptoTransferTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoTransferTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoTransferTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoTransferTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.transfers = $root.proto.TransferList.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoTransferTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoTransferTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoTransferTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.transfers != null && message.hasOwnProperty("transfers")) {
//                 let error = $root.proto.TransferList.verify(message.transfers);
//                 if (error)
//                     return "transfers." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoTransferTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
//          */
//         CryptoTransferTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoTransferTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoTransferTransactionBody();
//             if (object.transfers != null) {
//                 if (typeof object.transfers !== "object")
//                     throw TypeError(".proto.CryptoTransferTransactionBody.transfers: object expected");
//                 message.transfers = $root.proto.TransferList.fromObject(object.transfers);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoTransferTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoTransferTransactionBody
//          * @static
//          * @param {proto.CryptoTransferTransactionBody} message CryptoTransferTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoTransferTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.transfers = null;
//             if (message.transfers != null && message.hasOwnProperty("transfers"))
//                 object.transfers = $root.proto.TransferList.toObject(message.transfers, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoTransferTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoTransferTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoTransferTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoTransferTransactionBody;
//     })();
// 
//     proto.CryptoUpdateTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoUpdateTransactionBody.
//          * @memberof proto
//          * @interface ICryptoUpdateTransactionBody
//          * @property {proto.IAccountID|null} [accountIDToUpdate] CryptoUpdateTransactionBody accountIDToUpdate
//          * @property {proto.IKey|null} [key] CryptoUpdateTransactionBody key
//          * @property {proto.IAccountID|null} [proxyAccountID] CryptoUpdateTransactionBody proxyAccountID
//          * @property {number|null} [proxyFraction] CryptoUpdateTransactionBody proxyFraction
//          * @property {number|Long|null} [sendRecordThreshold] CryptoUpdateTransactionBody sendRecordThreshold
//          * @property {proto.IUInt64Value|null} [sendRecordThresholdWrapper] CryptoUpdateTransactionBody sendRecordThresholdWrapper
//          * @property {number|Long|null} [receiveRecordThreshold] CryptoUpdateTransactionBody receiveRecordThreshold
//          * @property {proto.IUInt64Value|null} [receiveRecordThresholdWrapper] CryptoUpdateTransactionBody receiveRecordThresholdWrapper
//          * @property {proto.IDuration|null} [autoRenewPeriod] CryptoUpdateTransactionBody autoRenewPeriod
//          * @property {proto.ITimestamp|null} [expirationTime] CryptoUpdateTransactionBody expirationTime
//          * @property {boolean|null} [receiverSigRequired] CryptoUpdateTransactionBody receiverSigRequired
//          * @property {proto.IBoolValue|null} [receiverSigRequiredWrapper] CryptoUpdateTransactionBody receiverSigRequiredWrapper
//          */
// 
//         /**
//          * Constructs a new CryptoUpdateTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoUpdateTransactionBody.
//          * @implements ICryptoUpdateTransactionBody
//          * @constructor
//          * @param {proto.ICryptoUpdateTransactionBody=} [properties] Properties to set
//          */
//         function CryptoUpdateTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoUpdateTransactionBody accountIDToUpdate.
//          * @member {proto.IAccountID|null|undefined} accountIDToUpdate
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.accountIDToUpdate = null;
// 
//         /**
//          * CryptoUpdateTransactionBody key.
//          * @member {proto.IKey|null|undefined} key
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.key = null;
// 
//         /**
//          * CryptoUpdateTransactionBody proxyAccountID.
//          * @member {proto.IAccountID|null|undefined} proxyAccountID
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.proxyAccountID = null;
// 
//         /**
//          * CryptoUpdateTransactionBody proxyFraction.
//          * @member {number} proxyFraction
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.proxyFraction = 0;
// 
//         /**
//          * CryptoUpdateTransactionBody sendRecordThreshold.
//          * @member {number|Long} sendRecordThreshold
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * CryptoUpdateTransactionBody sendRecordThresholdWrapper.
//          * @member {proto.IUInt64Value|null|undefined} sendRecordThresholdWrapper
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.sendRecordThresholdWrapper = null;
// 
//         /**
//          * CryptoUpdateTransactionBody receiveRecordThreshold.
//          * @member {number|Long} receiveRecordThreshold
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * CryptoUpdateTransactionBody receiveRecordThresholdWrapper.
//          * @member {proto.IUInt64Value|null|undefined} receiveRecordThresholdWrapper
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.receiveRecordThresholdWrapper = null;
// 
//         /**
//          * CryptoUpdateTransactionBody autoRenewPeriod.
//          * @member {proto.IDuration|null|undefined} autoRenewPeriod
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.autoRenewPeriod = null;
// 
//         /**
//          * CryptoUpdateTransactionBody expirationTime.
//          * @member {proto.ITimestamp|null|undefined} expirationTime
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.expirationTime = null;
// 
//         /**
//          * CryptoUpdateTransactionBody receiverSigRequired.
//          * @member {boolean} receiverSigRequired
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.receiverSigRequired = false;
// 
//         /**
//          * CryptoUpdateTransactionBody receiverSigRequiredWrapper.
//          * @member {proto.IBoolValue|null|undefined} receiverSigRequiredWrapper
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         CryptoUpdateTransactionBody.prototype.receiverSigRequiredWrapper = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * CryptoUpdateTransactionBody sendRecordThresholdField.
//          * @member {"sendRecordThreshold"|"sendRecordThresholdWrapper"|undefined} sendRecordThresholdField
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         Object.defineProperty(CryptoUpdateTransactionBody.prototype, "sendRecordThresholdField", {
//             get: $util.oneOfGetter($oneOfFields = ["sendRecordThreshold", "sendRecordThresholdWrapper"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * CryptoUpdateTransactionBody receiveRecordThresholdField.
//          * @member {"receiveRecordThreshold"|"receiveRecordThresholdWrapper"|undefined} receiveRecordThresholdField
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiveRecordThresholdField", {
//             get: $util.oneOfGetter($oneOfFields = ["receiveRecordThreshold", "receiveRecordThresholdWrapper"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * CryptoUpdateTransactionBody receiverSigRequiredField.
//          * @member {"receiverSigRequired"|"receiverSigRequiredWrapper"|undefined} receiverSigRequiredField
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          */
//         Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiverSigRequiredField", {
//             get: $util.oneOfGetter($oneOfFields = ["receiverSigRequired", "receiverSigRequiredWrapper"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new CryptoUpdateTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {proto.ICryptoUpdateTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody instance
//          */
//         CryptoUpdateTransactionBody.create = function create(properties) {
//             return new CryptoUpdateTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoUpdateTransactionBody message. Does not implicitly {@link proto.CryptoUpdateTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {proto.ICryptoUpdateTransactionBody} message CryptoUpdateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoUpdateTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountIDToUpdate != null && Object.hasOwnProperty.call(message, "accountIDToUpdate"))
//                 $root.proto.AccountID.encode(message.accountIDToUpdate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.key != null && Object.hasOwnProperty.call(message, "key"))
//                 $root.proto.Key.encode(message.key, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.proxyAccountID != null && Object.hasOwnProperty.call(message, "proxyAccountID"))
//                 $root.proto.AccountID.encode(message.proxyAccountID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.proxyFraction != null && Object.hasOwnProperty.call(message, "proxyFraction"))
//                 writer.uint32(/* id 5, wireType 0 =*/40).int32(message.proxyFraction);
//             if (message.sendRecordThreshold != null && Object.hasOwnProperty.call(message, "sendRecordThreshold"))
//                 writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.sendRecordThreshold);
//             if (message.receiveRecordThreshold != null && Object.hasOwnProperty.call(message, "receiveRecordThreshold"))
//                 writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.receiveRecordThreshold);
//             if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                 $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
//             if (message.receiverSigRequired != null && Object.hasOwnProperty.call(message, "receiverSigRequired"))
//                 writer.uint32(/* id 10, wireType 0 =*/80).bool(message.receiverSigRequired);
//             if (message.sendRecordThresholdWrapper != null && Object.hasOwnProperty.call(message, "sendRecordThresholdWrapper"))
//                 $root.proto.UInt64Value.encode(message.sendRecordThresholdWrapper, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
//             if (message.receiveRecordThresholdWrapper != null && Object.hasOwnProperty.call(message, "receiveRecordThresholdWrapper"))
//                 $root.proto.UInt64Value.encode(message.receiveRecordThresholdWrapper, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
//             if (message.receiverSigRequiredWrapper != null && Object.hasOwnProperty.call(message, "receiverSigRequiredWrapper"))
//                 $root.proto.BoolValue.encode(message.receiverSigRequiredWrapper, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoUpdateTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoUpdateTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {proto.ICryptoUpdateTransactionBody} message CryptoUpdateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoUpdateTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoUpdateTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoUpdateTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoUpdateTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 2:
//                     message.accountIDToUpdate = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.key = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.proxyAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.proxyFraction = reader.int32();
//                     break;
//                 case 6:
//                     message.sendRecordThreshold = reader.uint64();
//                     break;
//                 case 11:
//                     message.sendRecordThresholdWrapper = $root.proto.UInt64Value.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.receiveRecordThreshold = reader.uint64();
//                     break;
//                 case 12:
//                     message.receiveRecordThresholdWrapper = $root.proto.UInt64Value.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 9:
//                     message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 10:
//                     message.receiverSigRequired = reader.bool();
//                     break;
//                 case 13:
//                     message.receiverSigRequiredWrapper = $root.proto.BoolValue.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoUpdateTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoUpdateTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoUpdateTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoUpdateTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.accountIDToUpdate != null && message.hasOwnProperty("accountIDToUpdate")) {
//                 let error = $root.proto.AccountID.verify(message.accountIDToUpdate);
//                 if (error)
//                     return "accountIDToUpdate." + error;
//             }
//             if (message.key != null && message.hasOwnProperty("key")) {
//                 let error = $root.proto.Key.verify(message.key);
//                 if (error)
//                     return "key." + error;
//             }
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID")) {
//                 let error = $root.proto.AccountID.verify(message.proxyAccountID);
//                 if (error)
//                     return "proxyAccountID." + error;
//             }
//             if (message.proxyFraction != null && message.hasOwnProperty("proxyFraction"))
//                 if (!$util.isInteger(message.proxyFraction))
//                     return "proxyFraction: integer expected";
//             if (message.sendRecordThreshold != null && message.hasOwnProperty("sendRecordThreshold")) {
//                 properties.sendRecordThresholdField = 1;
//                 if (!$util.isInteger(message.sendRecordThreshold) && !(message.sendRecordThreshold && $util.isInteger(message.sendRecordThreshold.low) && $util.isInteger(message.sendRecordThreshold.high)))
//                     return "sendRecordThreshold: integer|Long expected";
//             }
//             if (message.sendRecordThresholdWrapper != null && message.hasOwnProperty("sendRecordThresholdWrapper")) {
//                 if (properties.sendRecordThresholdField === 1)
//                     return "sendRecordThresholdField: multiple values";
//                 properties.sendRecordThresholdField = 1;
//                 {
//                     let error = $root.proto.UInt64Value.verify(message.sendRecordThresholdWrapper);
//                     if (error)
//                         return "sendRecordThresholdWrapper." + error;
//                 }
//             }
//             if (message.receiveRecordThreshold != null && message.hasOwnProperty("receiveRecordThreshold")) {
//                 properties.receiveRecordThresholdField = 1;
//                 if (!$util.isInteger(message.receiveRecordThreshold) && !(message.receiveRecordThreshold && $util.isInteger(message.receiveRecordThreshold.low) && $util.isInteger(message.receiveRecordThreshold.high)))
//                     return "receiveRecordThreshold: integer|Long expected";
//             }
//             if (message.receiveRecordThresholdWrapper != null && message.hasOwnProperty("receiveRecordThresholdWrapper")) {
//                 if (properties.receiveRecordThresholdField === 1)
//                     return "receiveRecordThresholdField: multiple values";
//                 properties.receiveRecordThresholdField = 1;
//                 {
//                     let error = $root.proto.UInt64Value.verify(message.receiveRecordThresholdWrapper);
//                     if (error)
//                         return "receiveRecordThresholdWrapper." + error;
//                 }
//             }
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                 let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                 if (error)
//                     return "autoRenewPeriod." + error;
//             }
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.Timestamp.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired")) {
//                 properties.receiverSigRequiredField = 1;
//                 if (typeof message.receiverSigRequired !== "boolean")
//                     return "receiverSigRequired: boolean expected";
//             }
//             if (message.receiverSigRequiredWrapper != null && message.hasOwnProperty("receiverSigRequiredWrapper")) {
//                 if (properties.receiverSigRequiredField === 1)
//                     return "receiverSigRequiredField: multiple values";
//                 properties.receiverSigRequiredField = 1;
//                 {
//                     let error = $root.proto.BoolValue.verify(message.receiverSigRequiredWrapper);
//                     if (error)
//                         return "receiverSigRequiredWrapper." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoUpdateTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody
//          */
//         CryptoUpdateTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoUpdateTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoUpdateTransactionBody();
//             if (object.accountIDToUpdate != null) {
//                 if (typeof object.accountIDToUpdate !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.accountIDToUpdate: object expected");
//                 message.accountIDToUpdate = $root.proto.AccountID.fromObject(object.accountIDToUpdate);
//             }
//             if (object.key != null) {
//                 if (typeof object.key !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.key: object expected");
//                 message.key = $root.proto.Key.fromObject(object.key);
//             }
//             if (object.proxyAccountID != null) {
//                 if (typeof object.proxyAccountID !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.proxyAccountID: object expected");
//                 message.proxyAccountID = $root.proto.AccountID.fromObject(object.proxyAccountID);
//             }
//             if (object.proxyFraction != null)
//                 message.proxyFraction = object.proxyFraction | 0;
//             if (object.sendRecordThreshold != null)
//                 if ($util.Long)
//                     (message.sendRecordThreshold = $util.Long.fromValue(object.sendRecordThreshold)).unsigned = true;
//                 else if (typeof object.sendRecordThreshold === "string")
//                     message.sendRecordThreshold = parseInt(object.sendRecordThreshold, 10);
//                 else if (typeof object.sendRecordThreshold === "number")
//                     message.sendRecordThreshold = object.sendRecordThreshold;
//                 else if (typeof object.sendRecordThreshold === "object")
//                     message.sendRecordThreshold = new $util.LongBits(object.sendRecordThreshold.low >>> 0, object.sendRecordThreshold.high >>> 0).toNumber(true);
//             if (object.sendRecordThresholdWrapper != null) {
//                 if (typeof object.sendRecordThresholdWrapper !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.sendRecordThresholdWrapper: object expected");
//                 message.sendRecordThresholdWrapper = $root.proto.UInt64Value.fromObject(object.sendRecordThresholdWrapper);
//             }
//             if (object.receiveRecordThreshold != null)
//                 if ($util.Long)
//                     (message.receiveRecordThreshold = $util.Long.fromValue(object.receiveRecordThreshold)).unsigned = true;
//                 else if (typeof object.receiveRecordThreshold === "string")
//                     message.receiveRecordThreshold = parseInt(object.receiveRecordThreshold, 10);
//                 else if (typeof object.receiveRecordThreshold === "number")
//                     message.receiveRecordThreshold = object.receiveRecordThreshold;
//                 else if (typeof object.receiveRecordThreshold === "object")
//                     message.receiveRecordThreshold = new $util.LongBits(object.receiveRecordThreshold.low >>> 0, object.receiveRecordThreshold.high >>> 0).toNumber(true);
//             if (object.receiveRecordThresholdWrapper != null) {
//                 if (typeof object.receiveRecordThresholdWrapper !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.receiveRecordThresholdWrapper: object expected");
//                 message.receiveRecordThresholdWrapper = $root.proto.UInt64Value.fromObject(object.receiveRecordThresholdWrapper);
//             }
//             if (object.autoRenewPeriod != null) {
//                 if (typeof object.autoRenewPeriod !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.autoRenewPeriod: object expected");
//                 message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//             }
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.expirationTime: object expected");
//                 message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//             }
//             if (object.receiverSigRequired != null)
//                 message.receiverSigRequired = Boolean(object.receiverSigRequired);
//             if (object.receiverSigRequiredWrapper != null) {
//                 if (typeof object.receiverSigRequiredWrapper !== "object")
//                     throw TypeError(".proto.CryptoUpdateTransactionBody.receiverSigRequiredWrapper: object expected");
//                 message.receiverSigRequiredWrapper = $root.proto.BoolValue.fromObject(object.receiverSigRequiredWrapper);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoUpdateTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @static
//          * @param {proto.CryptoUpdateTransactionBody} message CryptoUpdateTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoUpdateTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.accountIDToUpdate = null;
//                 object.key = null;
//                 object.proxyAccountID = null;
//                 object.proxyFraction = 0;
//                 object.autoRenewPeriod = null;
//                 object.expirationTime = null;
//             }
//             if (message.accountIDToUpdate != null && message.hasOwnProperty("accountIDToUpdate"))
//                 object.accountIDToUpdate = $root.proto.AccountID.toObject(message.accountIDToUpdate, options);
//             if (message.key != null && message.hasOwnProperty("key"))
//                 object.key = $root.proto.Key.toObject(message.key, options);
//             if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID"))
//                 object.proxyAccountID = $root.proto.AccountID.toObject(message.proxyAccountID, options);
//             if (message.proxyFraction != null && message.hasOwnProperty("proxyFraction"))
//                 object.proxyFraction = message.proxyFraction;
//             if (message.sendRecordThreshold != null && message.hasOwnProperty("sendRecordThreshold")) {
//                 if (typeof message.sendRecordThreshold === "number")
//                     object.sendRecordThreshold = options.longs === String ? String(message.sendRecordThreshold) : message.sendRecordThreshold;
//                 else
//                     object.sendRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.sendRecordThreshold) : options.longs === Number ? new $util.LongBits(message.sendRecordThreshold.low >>> 0, message.sendRecordThreshold.high >>> 0).toNumber(true) : message.sendRecordThreshold;
//                 if (options.oneofs)
//                     object.sendRecordThresholdField = "sendRecordThreshold";
//             }
//             if (message.receiveRecordThreshold != null && message.hasOwnProperty("receiveRecordThreshold")) {
//                 if (typeof message.receiveRecordThreshold === "number")
//                     object.receiveRecordThreshold = options.longs === String ? String(message.receiveRecordThreshold) : message.receiveRecordThreshold;
//                 else
//                     object.receiveRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.receiveRecordThreshold) : options.longs === Number ? new $util.LongBits(message.receiveRecordThreshold.low >>> 0, message.receiveRecordThreshold.high >>> 0).toNumber(true) : message.receiveRecordThreshold;
//                 if (options.oneofs)
//                     object.receiveRecordThresholdField = "receiveRecordThreshold";
//             }
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                 object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//             if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired")) {
//                 object.receiverSigRequired = message.receiverSigRequired;
//                 if (options.oneofs)
//                     object.receiverSigRequiredField = "receiverSigRequired";
//             }
//             if (message.sendRecordThresholdWrapper != null && message.hasOwnProperty("sendRecordThresholdWrapper")) {
//                 object.sendRecordThresholdWrapper = $root.proto.UInt64Value.toObject(message.sendRecordThresholdWrapper, options);
//                 if (options.oneofs)
//                     object.sendRecordThresholdField = "sendRecordThresholdWrapper";
//             }
//             if (message.receiveRecordThresholdWrapper != null && message.hasOwnProperty("receiveRecordThresholdWrapper")) {
//                 object.receiveRecordThresholdWrapper = $root.proto.UInt64Value.toObject(message.receiveRecordThresholdWrapper, options);
//                 if (options.oneofs)
//                     object.receiveRecordThresholdField = "receiveRecordThresholdWrapper";
//             }
//             if (message.receiverSigRequiredWrapper != null && message.hasOwnProperty("receiverSigRequiredWrapper")) {
//                 object.receiverSigRequiredWrapper = $root.proto.BoolValue.toObject(message.receiverSigRequiredWrapper, options);
//                 if (options.oneofs)
//                     object.receiverSigRequiredField = "receiverSigRequiredWrapper";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoUpdateTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoUpdateTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoUpdateTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoUpdateTransactionBody;
//     })();
// 
//     proto.DoubleValue = (function() {
// 
//         /**
//          * Properties of a DoubleValue.
//          * @memberof proto
//          * @interface IDoubleValue
//          * @property {number|null} [value] DoubleValue value
//          */
// 
//         /**
//          * Constructs a new DoubleValue.
//          * @memberof proto
//          * @classdesc Represents a DoubleValue.
//          * @implements IDoubleValue
//          * @constructor
//          * @param {proto.IDoubleValue=} [properties] Properties to set
//          */
//         function DoubleValue(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * DoubleValue value.
//          * @member {number} value
//          * @memberof proto.DoubleValue
//          * @instance
//          */
//         DoubleValue.prototype.value = 0;
// 
//         /**
//          * Creates a new DoubleValue instance using the specified properties.
//          * @function create
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {proto.IDoubleValue=} [properties] Properties to set
//          * @returns {proto.DoubleValue} DoubleValue instance
//          */
//         DoubleValue.create = function create(properties) {
//             return new DoubleValue(properties);
//         };
// 
//         /**
//          * Encodes the specified DoubleValue message. Does not implicitly {@link proto.DoubleValue.verify|verify} messages.
//          * @function encode
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {proto.IDoubleValue} message DoubleValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         DoubleValue.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified DoubleValue message, length delimited. Does not implicitly {@link proto.DoubleValue.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {proto.IDoubleValue} message DoubleValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         DoubleValue.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a DoubleValue message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.DoubleValue} DoubleValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         DoubleValue.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.DoubleValue();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.double();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a DoubleValue message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.DoubleValue} DoubleValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         DoubleValue.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a DoubleValue message.
//          * @function verify
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         DoubleValue.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (typeof message.value !== "number")
//                     return "value: number expected";
//             return null;
//         };
// 
//         /**
//          * Creates a DoubleValue message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.DoubleValue} DoubleValue
//          */
//         DoubleValue.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.DoubleValue)
//                 return object;
//             let message = new $root.proto.DoubleValue();
//             if (object.value != null)
//                 message.value = Number(object.value);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a DoubleValue message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.DoubleValue
//          * @static
//          * @param {proto.DoubleValue} message DoubleValue
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         DoubleValue.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.value = 0;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this DoubleValue to JSON.
//          * @function toJSON
//          * @memberof proto.DoubleValue
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         DoubleValue.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return DoubleValue;
//     })();
// 
//     proto.FloatValue = (function() {
// 
//         /**
//          * Properties of a FloatValue.
//          * @memberof proto
//          * @interface IFloatValue
//          * @property {number|null} [value] FloatValue value
//          */
// 
//         /**
//          * Constructs a new FloatValue.
//          * @memberof proto
//          * @classdesc Represents a FloatValue.
//          * @implements IFloatValue
//          * @constructor
//          * @param {proto.IFloatValue=} [properties] Properties to set
//          */
//         function FloatValue(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FloatValue value.
//          * @member {number} value
//          * @memberof proto.FloatValue
//          * @instance
//          */
//         FloatValue.prototype.value = 0;
// 
//         /**
//          * Creates a new FloatValue instance using the specified properties.
//          * @function create
//          * @memberof proto.FloatValue
//          * @static
//          * @param {proto.IFloatValue=} [properties] Properties to set
//          * @returns {proto.FloatValue} FloatValue instance
//          */
//         FloatValue.create = function create(properties) {
//             return new FloatValue(properties);
//         };
// 
//         /**
//          * Encodes the specified FloatValue message. Does not implicitly {@link proto.FloatValue.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FloatValue
//          * @static
//          * @param {proto.IFloatValue} message FloatValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FloatValue.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FloatValue message, length delimited. Does not implicitly {@link proto.FloatValue.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FloatValue
//          * @static
//          * @param {proto.IFloatValue} message FloatValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FloatValue.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FloatValue message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FloatValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FloatValue} FloatValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FloatValue.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FloatValue();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.float();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FloatValue message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FloatValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FloatValue} FloatValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FloatValue.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FloatValue message.
//          * @function verify
//          * @memberof proto.FloatValue
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FloatValue.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (typeof message.value !== "number")
//                     return "value: number expected";
//             return null;
//         };
// 
//         /**
//          * Creates a FloatValue message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FloatValue
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FloatValue} FloatValue
//          */
//         FloatValue.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FloatValue)
//                 return object;
//             let message = new $root.proto.FloatValue();
//             if (object.value != null)
//                 message.value = Number(object.value);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FloatValue message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FloatValue
//          * @static
//          * @param {proto.FloatValue} message FloatValue
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FloatValue.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.value = 0;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this FloatValue to JSON.
//          * @function toJSON
//          * @memberof proto.FloatValue
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FloatValue.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FloatValue;
//     })();
// 
//     proto.Int64Value = (function() {
// 
//         /**
//          * Properties of an Int64Value.
//          * @memberof proto
//          * @interface IInt64Value
//          * @property {number|Long|null} [value] Int64Value value
//          */
// 
//         /**
//          * Constructs a new Int64Value.
//          * @memberof proto
//          * @classdesc Represents an Int64Value.
//          * @implements IInt64Value
//          * @constructor
//          * @param {proto.IInt64Value=} [properties] Properties to set
//          */
//         function Int64Value(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Int64Value value.
//          * @member {number|Long} value
//          * @memberof proto.Int64Value
//          * @instance
//          */
//         Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new Int64Value instance using the specified properties.
//          * @function create
//          * @memberof proto.Int64Value
//          * @static
//          * @param {proto.IInt64Value=} [properties] Properties to set
//          * @returns {proto.Int64Value} Int64Value instance
//          */
//         Int64Value.create = function create(properties) {
//             return new Int64Value(properties);
//         };
// 
//         /**
//          * Encodes the specified Int64Value message. Does not implicitly {@link proto.Int64Value.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Int64Value
//          * @static
//          * @param {proto.IInt64Value} message Int64Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Int64Value.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Int64Value message, length delimited. Does not implicitly {@link proto.Int64Value.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Int64Value
//          * @static
//          * @param {proto.IInt64Value} message Int64Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Int64Value.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an Int64Value message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Int64Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Int64Value} Int64Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Int64Value.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Int64Value();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an Int64Value message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Int64Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Int64Value} Int64Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Int64Value.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an Int64Value message.
//          * @function verify
//          * @memberof proto.Int64Value
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Int64Value.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
//                     return "value: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates an Int64Value message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Int64Value
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Int64Value} Int64Value
//          */
//         Int64Value.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Int64Value)
//                 return object;
//             let message = new $root.proto.Int64Value();
//             if (object.value != null)
//                 if ($util.Long)
//                     (message.value = $util.Long.fromValue(object.value)).unsigned = false;
//                 else if (typeof object.value === "string")
//                     message.value = parseInt(object.value, 10);
//                 else if (typeof object.value === "number")
//                     message.value = object.value;
//                 else if (typeof object.value === "object")
//                     message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an Int64Value message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Int64Value
//          * @static
//          * @param {proto.Int64Value} message Int64Value
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Int64Value.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.value = options.longs === String ? "0" : 0;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (typeof message.value === "number")
//                     object.value = options.longs === String ? String(message.value) : message.value;
//                 else
//                     object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this Int64Value to JSON.
//          * @function toJSON
//          * @memberof proto.Int64Value
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Int64Value.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Int64Value;
//     })();
// 
//     proto.UInt64Value = (function() {
// 
//         /**
//          * Properties of a UInt64Value.
//          * @memberof proto
//          * @interface IUInt64Value
//          * @property {number|Long|null} [value] UInt64Value value
//          */
// 
//         /**
//          * Constructs a new UInt64Value.
//          * @memberof proto
//          * @classdesc Represents a UInt64Value.
//          * @implements IUInt64Value
//          * @constructor
//          * @param {proto.IUInt64Value=} [properties] Properties to set
//          */
//         function UInt64Value(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * UInt64Value value.
//          * @member {number|Long} value
//          * @memberof proto.UInt64Value
//          * @instance
//          */
//         UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * Creates a new UInt64Value instance using the specified properties.
//          * @function create
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {proto.IUInt64Value=} [properties] Properties to set
//          * @returns {proto.UInt64Value} UInt64Value instance
//          */
//         UInt64Value.create = function create(properties) {
//             return new UInt64Value(properties);
//         };
// 
//         /**
//          * Encodes the specified UInt64Value message. Does not implicitly {@link proto.UInt64Value.verify|verify} messages.
//          * @function encode
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {proto.IUInt64Value} message UInt64Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         UInt64Value.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified UInt64Value message, length delimited. Does not implicitly {@link proto.UInt64Value.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {proto.IUInt64Value} message UInt64Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         UInt64Value.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a UInt64Value message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.UInt64Value} UInt64Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         UInt64Value.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UInt64Value();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.uint64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a UInt64Value message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.UInt64Value} UInt64Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         UInt64Value.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a UInt64Value message.
//          * @function verify
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         UInt64Value.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
//                     return "value: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a UInt64Value message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.UInt64Value} UInt64Value
//          */
//         UInt64Value.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.UInt64Value)
//                 return object;
//             let message = new $root.proto.UInt64Value();
//             if (object.value != null)
//                 if ($util.Long)
//                     (message.value = $util.Long.fromValue(object.value)).unsigned = true;
//                 else if (typeof object.value === "string")
//                     message.value = parseInt(object.value, 10);
//                 else if (typeof object.value === "number")
//                     message.value = object.value;
//                 else if (typeof object.value === "object")
//                     message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a UInt64Value message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.UInt64Value
//          * @static
//          * @param {proto.UInt64Value} message UInt64Value
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         UInt64Value.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.value = options.longs === String ? "0" : 0;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (typeof message.value === "number")
//                     object.value = options.longs === String ? String(message.value) : message.value;
//                 else
//                     object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this UInt64Value to JSON.
//          * @function toJSON
//          * @memberof proto.UInt64Value
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         UInt64Value.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return UInt64Value;
//     })();
// 
//     proto.Int32Value = (function() {
// 
//         /**
//          * Properties of an Int32Value.
//          * @memberof proto
//          * @interface IInt32Value
//          * @property {number|null} [value] Int32Value value
//          */
// 
//         /**
//          * Constructs a new Int32Value.
//          * @memberof proto
//          * @classdesc Represents an Int32Value.
//          * @implements IInt32Value
//          * @constructor
//          * @param {proto.IInt32Value=} [properties] Properties to set
//          */
//         function Int32Value(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Int32Value value.
//          * @member {number} value
//          * @memberof proto.Int32Value
//          * @instance
//          */
//         Int32Value.prototype.value = 0;
// 
//         /**
//          * Creates a new Int32Value instance using the specified properties.
//          * @function create
//          * @memberof proto.Int32Value
//          * @static
//          * @param {proto.IInt32Value=} [properties] Properties to set
//          * @returns {proto.Int32Value} Int32Value instance
//          */
//         Int32Value.create = function create(properties) {
//             return new Int32Value(properties);
//         };
// 
//         /**
//          * Encodes the specified Int32Value message. Does not implicitly {@link proto.Int32Value.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Int32Value
//          * @static
//          * @param {proto.IInt32Value} message Int32Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Int32Value.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Int32Value message, length delimited. Does not implicitly {@link proto.Int32Value.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Int32Value
//          * @static
//          * @param {proto.IInt32Value} message Int32Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Int32Value.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an Int32Value message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Int32Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Int32Value} Int32Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Int32Value.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Int32Value();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.int32();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an Int32Value message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Int32Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Int32Value} Int32Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Int32Value.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an Int32Value message.
//          * @function verify
//          * @memberof proto.Int32Value
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Int32Value.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (!$util.isInteger(message.value))
//                     return "value: integer expected";
//             return null;
//         };
// 
//         /**
//          * Creates an Int32Value message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Int32Value
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Int32Value} Int32Value
//          */
//         Int32Value.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Int32Value)
//                 return object;
//             let message = new $root.proto.Int32Value();
//             if (object.value != null)
//                 message.value = object.value | 0;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an Int32Value message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Int32Value
//          * @static
//          * @param {proto.Int32Value} message Int32Value
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Int32Value.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.value = 0;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this Int32Value to JSON.
//          * @function toJSON
//          * @memberof proto.Int32Value
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Int32Value.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Int32Value;
//     })();
// 
//     proto.UInt32Value = (function() {
// 
//         /**
//          * Properties of a UInt32Value.
//          * @memberof proto
//          * @interface IUInt32Value
//          * @property {number|null} [value] UInt32Value value
//          */
// 
//         /**
//          * Constructs a new UInt32Value.
//          * @memberof proto
//          * @classdesc Represents a UInt32Value.
//          * @implements IUInt32Value
//          * @constructor
//          * @param {proto.IUInt32Value=} [properties] Properties to set
//          */
//         function UInt32Value(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * UInt32Value value.
//          * @member {number} value
//          * @memberof proto.UInt32Value
//          * @instance
//          */
//         UInt32Value.prototype.value = 0;
// 
//         /**
//          * Creates a new UInt32Value instance using the specified properties.
//          * @function create
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {proto.IUInt32Value=} [properties] Properties to set
//          * @returns {proto.UInt32Value} UInt32Value instance
//          */
//         UInt32Value.create = function create(properties) {
//             return new UInt32Value(properties);
//         };
// 
//         /**
//          * Encodes the specified UInt32Value message. Does not implicitly {@link proto.UInt32Value.verify|verify} messages.
//          * @function encode
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {proto.IUInt32Value} message UInt32Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         UInt32Value.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified UInt32Value message, length delimited. Does not implicitly {@link proto.UInt32Value.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {proto.IUInt32Value} message UInt32Value message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         UInt32Value.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a UInt32Value message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.UInt32Value} UInt32Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         UInt32Value.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UInt32Value();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.uint32();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a UInt32Value message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.UInt32Value} UInt32Value
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         UInt32Value.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a UInt32Value message.
//          * @function verify
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         UInt32Value.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (!$util.isInteger(message.value))
//                     return "value: integer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a UInt32Value message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.UInt32Value} UInt32Value
//          */
//         UInt32Value.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.UInt32Value)
//                 return object;
//             let message = new $root.proto.UInt32Value();
//             if (object.value != null)
//                 message.value = object.value >>> 0;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a UInt32Value message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.UInt32Value
//          * @static
//          * @param {proto.UInt32Value} message UInt32Value
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         UInt32Value.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.value = 0;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this UInt32Value to JSON.
//          * @function toJSON
//          * @memberof proto.UInt32Value
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         UInt32Value.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return UInt32Value;
//     })();
// 
//     proto.BoolValue = (function() {
// 
//         /**
//          * Properties of a BoolValue.
//          * @memberof proto
//          * @interface IBoolValue
//          * @property {boolean|null} [value] BoolValue value
//          */
// 
//         /**
//          * Constructs a new BoolValue.
//          * @memberof proto
//          * @classdesc Represents a BoolValue.
//          * @implements IBoolValue
//          * @constructor
//          * @param {proto.IBoolValue=} [properties] Properties to set
//          */
//         function BoolValue(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * BoolValue value.
//          * @member {boolean} value
//          * @memberof proto.BoolValue
//          * @instance
//          */
//         BoolValue.prototype.value = false;
// 
//         /**
//          * Creates a new BoolValue instance using the specified properties.
//          * @function create
//          * @memberof proto.BoolValue
//          * @static
//          * @param {proto.IBoolValue=} [properties] Properties to set
//          * @returns {proto.BoolValue} BoolValue instance
//          */
//         BoolValue.create = function create(properties) {
//             return new BoolValue(properties);
//         };
// 
//         /**
//          * Encodes the specified BoolValue message. Does not implicitly {@link proto.BoolValue.verify|verify} messages.
//          * @function encode
//          * @memberof proto.BoolValue
//          * @static
//          * @param {proto.IBoolValue} message BoolValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         BoolValue.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified BoolValue message, length delimited. Does not implicitly {@link proto.BoolValue.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.BoolValue
//          * @static
//          * @param {proto.IBoolValue} message BoolValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         BoolValue.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a BoolValue message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.BoolValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.BoolValue} BoolValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         BoolValue.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.BoolValue();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.bool();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a BoolValue message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.BoolValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.BoolValue} BoolValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         BoolValue.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a BoolValue message.
//          * @function verify
//          * @memberof proto.BoolValue
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         BoolValue.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (typeof message.value !== "boolean")
//                     return "value: boolean expected";
//             return null;
//         };
// 
//         /**
//          * Creates a BoolValue message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.BoolValue
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.BoolValue} BoolValue
//          */
//         BoolValue.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.BoolValue)
//                 return object;
//             let message = new $root.proto.BoolValue();
//             if (object.value != null)
//                 message.value = Boolean(object.value);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a BoolValue message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.BoolValue
//          * @static
//          * @param {proto.BoolValue} message BoolValue
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         BoolValue.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.value = false;
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this BoolValue to JSON.
//          * @function toJSON
//          * @memberof proto.BoolValue
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         BoolValue.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return BoolValue;
//     })();
// 
//     proto.StringValue = (function() {
// 
//         /**
//          * Properties of a StringValue.
//          * @memberof proto
//          * @interface IStringValue
//          * @property {string|null} [value] StringValue value
//          */
// 
//         /**
//          * Constructs a new StringValue.
//          * @memberof proto
//          * @classdesc Represents a StringValue.
//          * @implements IStringValue
//          * @constructor
//          * @param {proto.IStringValue=} [properties] Properties to set
//          */
//         function StringValue(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * StringValue value.
//          * @member {string} value
//          * @memberof proto.StringValue
//          * @instance
//          */
//         StringValue.prototype.value = "";
// 
//         /**
//          * Creates a new StringValue instance using the specified properties.
//          * @function create
//          * @memberof proto.StringValue
//          * @static
//          * @param {proto.IStringValue=} [properties] Properties to set
//          * @returns {proto.StringValue} StringValue instance
//          */
//         StringValue.create = function create(properties) {
//             return new StringValue(properties);
//         };
// 
//         /**
//          * Encodes the specified StringValue message. Does not implicitly {@link proto.StringValue.verify|verify} messages.
//          * @function encode
//          * @memberof proto.StringValue
//          * @static
//          * @param {proto.IStringValue} message StringValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         StringValue.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified StringValue message, length delimited. Does not implicitly {@link proto.StringValue.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.StringValue
//          * @static
//          * @param {proto.IStringValue} message StringValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         StringValue.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a StringValue message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.StringValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.StringValue} StringValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         StringValue.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.StringValue();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.string();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a StringValue message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.StringValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.StringValue} StringValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         StringValue.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a StringValue message.
//          * @function verify
//          * @memberof proto.StringValue
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         StringValue.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (!$util.isString(message.value))
//                     return "value: string expected";
//             return null;
//         };
// 
//         /**
//          * Creates a StringValue message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.StringValue
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.StringValue} StringValue
//          */
//         StringValue.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.StringValue)
//                 return object;
//             let message = new $root.proto.StringValue();
//             if (object.value != null)
//                 message.value = String(object.value);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a StringValue message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.StringValue
//          * @static
//          * @param {proto.StringValue} message StringValue
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         StringValue.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.value = "";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this StringValue to JSON.
//          * @function toJSON
//          * @memberof proto.StringValue
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         StringValue.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return StringValue;
//     })();
// 
//     proto.BytesValue = (function() {
// 
//         /**
//          * Properties of a BytesValue.
//          * @memberof proto
//          * @interface IBytesValue
//          * @property {Uint8Array|null} [value] BytesValue value
//          */
// 
//         /**
//          * Constructs a new BytesValue.
//          * @memberof proto
//          * @classdesc Represents a BytesValue.
//          * @implements IBytesValue
//          * @constructor
//          * @param {proto.IBytesValue=} [properties] Properties to set
//          */
//         function BytesValue(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * BytesValue value.
//          * @member {Uint8Array} value
//          * @memberof proto.BytesValue
//          * @instance
//          */
//         BytesValue.prototype.value = $util.newBuffer([]);
// 
//         /**
//          * Creates a new BytesValue instance using the specified properties.
//          * @function create
//          * @memberof proto.BytesValue
//          * @static
//          * @param {proto.IBytesValue=} [properties] Properties to set
//          * @returns {proto.BytesValue} BytesValue instance
//          */
//         BytesValue.create = function create(properties) {
//             return new BytesValue(properties);
//         };
// 
//         /**
//          * Encodes the specified BytesValue message. Does not implicitly {@link proto.BytesValue.verify|verify} messages.
//          * @function encode
//          * @memberof proto.BytesValue
//          * @static
//          * @param {proto.IBytesValue} message BytesValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         BytesValue.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.value != null && Object.hasOwnProperty.call(message, "value"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified BytesValue message, length delimited. Does not implicitly {@link proto.BytesValue.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.BytesValue
//          * @static
//          * @param {proto.IBytesValue} message BytesValue message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         BytesValue.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a BytesValue message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.BytesValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.BytesValue} BytesValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         BytesValue.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.BytesValue();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.value = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a BytesValue message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.BytesValue
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.BytesValue} BytesValue
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         BytesValue.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a BytesValue message.
//          * @function verify
//          * @memberof proto.BytesValue
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         BytesValue.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.value != null && message.hasOwnProperty("value"))
//                 if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
//                     return "value: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a BytesValue message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.BytesValue
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.BytesValue} BytesValue
//          */
//         BytesValue.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.BytesValue)
//                 return object;
//             let message = new $root.proto.BytesValue();
//             if (object.value != null)
//                 if (typeof object.value === "string")
//                     $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
//                 else if (object.value.length)
//                     message.value = object.value;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a BytesValue message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.BytesValue
//          * @static
//          * @param {proto.BytesValue} message BytesValue
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         BytesValue.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 if (options.bytes === String)
//                     object.value = "";
//                 else {
//                     object.value = [];
//                     if (options.bytes !== Array)
//                         object.value = $util.newBuffer(object.value);
//                 }
//             if (message.value != null && message.hasOwnProperty("value"))
//                 object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
//             return object;
//         };
// 
//         /**
//          * Converts this BytesValue to JSON.
//          * @function toJSON
//          * @memberof proto.BytesValue
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         BytesValue.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return BytesValue;
//     })();
// 
//     proto.FileAppendTransactionBody = (function() {
// 
//         /**
//          * Properties of a FileAppendTransactionBody.
//          * @memberof proto
//          * @interface IFileAppendTransactionBody
//          * @property {proto.IFileID|null} [fileID] FileAppendTransactionBody fileID
//          * @property {Uint8Array|null} [contents] FileAppendTransactionBody contents
//          */
// 
//         /**
//          * Constructs a new FileAppendTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a FileAppendTransactionBody.
//          * @implements IFileAppendTransactionBody
//          * @constructor
//          * @param {proto.IFileAppendTransactionBody=} [properties] Properties to set
//          */
//         function FileAppendTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileAppendTransactionBody fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.FileAppendTransactionBody
//          * @instance
//          */
//         FileAppendTransactionBody.prototype.fileID = null;
// 
//         /**
//          * FileAppendTransactionBody contents.
//          * @member {Uint8Array} contents
//          * @memberof proto.FileAppendTransactionBody
//          * @instance
//          */
//         FileAppendTransactionBody.prototype.contents = $util.newBuffer([]);
// 
//         /**
//          * Creates a new FileAppendTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {proto.IFileAppendTransactionBody=} [properties] Properties to set
//          * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody instance
//          */
//         FileAppendTransactionBody.create = function create(properties) {
//             return new FileAppendTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified FileAppendTransactionBody message. Does not implicitly {@link proto.FileAppendTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {proto.IFileAppendTransactionBody} message FileAppendTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileAppendTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.contents != null && Object.hasOwnProperty.call(message, "contents"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.contents);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileAppendTransactionBody message, length delimited. Does not implicitly {@link proto.FileAppendTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {proto.IFileAppendTransactionBody} message FileAppendTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileAppendTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileAppendTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileAppendTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileAppendTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 2:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contents = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileAppendTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileAppendTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileAppendTransactionBody message.
//          * @function verify
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileAppendTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             if (message.contents != null && message.hasOwnProperty("contents"))
//                 if (!(message.contents && typeof message.contents.length === "number" || $util.isString(message.contents)))
//                     return "contents: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a FileAppendTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody
//          */
//         FileAppendTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileAppendTransactionBody)
//                 return object;
//             let message = new $root.proto.FileAppendTransactionBody();
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.FileAppendTransactionBody.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.contents != null)
//                 if (typeof object.contents === "string")
//                     $util.base64.decode(object.contents, message.contents = $util.newBuffer($util.base64.length(object.contents)), 0);
//                 else if (object.contents.length)
//                     message.contents = object.contents;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileAppendTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileAppendTransactionBody
//          * @static
//          * @param {proto.FileAppendTransactionBody} message FileAppendTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileAppendTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.fileID = null;
//                 if (options.bytes === String)
//                     object.contents = "";
//                 else {
//                     object.contents = [];
//                     if (options.bytes !== Array)
//                         object.contents = $util.newBuffer(object.contents);
//                 }
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             if (message.contents != null && message.hasOwnProperty("contents"))
//                 object.contents = options.bytes === String ? $util.base64.encode(message.contents, 0, message.contents.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents) : message.contents;
//             return object;
//         };
// 
//         /**
//          * Converts this FileAppendTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.FileAppendTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileAppendTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FileAppendTransactionBody;
//     })();
// 
//     proto.FileCreateTransactionBody = (function() {
// 
//         /**
//          * Properties of a FileCreateTransactionBody.
//          * @memberof proto
//          * @interface IFileCreateTransactionBody
//          * @property {proto.ITimestamp|null} [expirationTime] FileCreateTransactionBody expirationTime
//          * @property {proto.IKeyList|null} [keys] FileCreateTransactionBody keys
//          * @property {Uint8Array|null} [contents] FileCreateTransactionBody contents
//          * @property {proto.IShardID|null} [shardID] FileCreateTransactionBody shardID
//          * @property {proto.IRealmID|null} [realmID] FileCreateTransactionBody realmID
//          * @property {proto.IKey|null} [newRealmAdminKey] FileCreateTransactionBody newRealmAdminKey
//          */
// 
//         /**
//          * Constructs a new FileCreateTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a FileCreateTransactionBody.
//          * @implements IFileCreateTransactionBody
//          * @constructor
//          * @param {proto.IFileCreateTransactionBody=} [properties] Properties to set
//          */
//         function FileCreateTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileCreateTransactionBody expirationTime.
//          * @member {proto.ITimestamp|null|undefined} expirationTime
//          * @memberof proto.FileCreateTransactionBody
//          * @instance
//          */
//         FileCreateTransactionBody.prototype.expirationTime = null;
// 
//         /**
//          * FileCreateTransactionBody keys.
//          * @member {proto.IKeyList|null|undefined} keys
//          * @memberof proto.FileCreateTransactionBody
//          * @instance
//          */
//         FileCreateTransactionBody.prototype.keys = null;
// 
//         /**
//          * FileCreateTransactionBody contents.
//          * @member {Uint8Array} contents
//          * @memberof proto.FileCreateTransactionBody
//          * @instance
//          */
//         FileCreateTransactionBody.prototype.contents = $util.newBuffer([]);
// 
//         /**
//          * FileCreateTransactionBody shardID.
//          * @member {proto.IShardID|null|undefined} shardID
//          * @memberof proto.FileCreateTransactionBody
//          * @instance
//          */
//         FileCreateTransactionBody.prototype.shardID = null;
// 
//         /**
//          * FileCreateTransactionBody realmID.
//          * @member {proto.IRealmID|null|undefined} realmID
//          * @memberof proto.FileCreateTransactionBody
//          * @instance
//          */
//         FileCreateTransactionBody.prototype.realmID = null;
// 
//         /**
//          * FileCreateTransactionBody newRealmAdminKey.
//          * @member {proto.IKey|null|undefined} newRealmAdminKey
//          * @memberof proto.FileCreateTransactionBody
//          * @instance
//          */
//         FileCreateTransactionBody.prototype.newRealmAdminKey = null;
// 
//         /**
//          * Creates a new FileCreateTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {proto.IFileCreateTransactionBody=} [properties] Properties to set
//          * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody instance
//          */
//         FileCreateTransactionBody.create = function create(properties) {
//             return new FileCreateTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified FileCreateTransactionBody message. Does not implicitly {@link proto.FileCreateTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {proto.IFileCreateTransactionBody} message FileCreateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileCreateTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
//                 $root.proto.KeyList.encode(message.keys, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.contents != null && Object.hasOwnProperty.call(message, "contents"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.contents);
//             if (message.shardID != null && Object.hasOwnProperty.call(message, "shardID"))
//                 $root.proto.ShardID.encode(message.shardID, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             if (message.realmID != null && Object.hasOwnProperty.call(message, "realmID"))
//                 $root.proto.RealmID.encode(message.realmID, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.newRealmAdminKey != null && Object.hasOwnProperty.call(message, "newRealmAdminKey"))
//                 $root.proto.Key.encode(message.newRealmAdminKey, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileCreateTransactionBody message, length delimited. Does not implicitly {@link proto.FileCreateTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {proto.IFileCreateTransactionBody} message FileCreateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileCreateTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileCreateTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileCreateTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileCreateTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 2:
//                     message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.keys = $root.proto.KeyList.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contents = reader.bytes();
//                     break;
//                 case 5:
//                     message.shardID = $root.proto.ShardID.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.realmID = $root.proto.RealmID.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.newRealmAdminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileCreateTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileCreateTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileCreateTransactionBody message.
//          * @function verify
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileCreateTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.Timestamp.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             if (message.keys != null && message.hasOwnProperty("keys")) {
//                 let error = $root.proto.KeyList.verify(message.keys);
//                 if (error)
//                     return "keys." + error;
//             }
//             if (message.contents != null && message.hasOwnProperty("contents"))
//                 if (!(message.contents && typeof message.contents.length === "number" || $util.isString(message.contents)))
//                     return "contents: buffer expected";
//             if (message.shardID != null && message.hasOwnProperty("shardID")) {
//                 let error = $root.proto.ShardID.verify(message.shardID);
//                 if (error)
//                     return "shardID." + error;
//             }
//             if (message.realmID != null && message.hasOwnProperty("realmID")) {
//                 let error = $root.proto.RealmID.verify(message.realmID);
//                 if (error)
//                     return "realmID." + error;
//             }
//             if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey")) {
//                 let error = $root.proto.Key.verify(message.newRealmAdminKey);
//                 if (error)
//                     return "newRealmAdminKey." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FileCreateTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody
//          */
//         FileCreateTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileCreateTransactionBody)
//                 return object;
//             let message = new $root.proto.FileCreateTransactionBody();
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.FileCreateTransactionBody.expirationTime: object expected");
//                 message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//             }
//             if (object.keys != null) {
//                 if (typeof object.keys !== "object")
//                     throw TypeError(".proto.FileCreateTransactionBody.keys: object expected");
//                 message.keys = $root.proto.KeyList.fromObject(object.keys);
//             }
//             if (object.contents != null)
//                 if (typeof object.contents === "string")
//                     $util.base64.decode(object.contents, message.contents = $util.newBuffer($util.base64.length(object.contents)), 0);
//                 else if (object.contents.length)
//                     message.contents = object.contents;
//             if (object.shardID != null) {
//                 if (typeof object.shardID !== "object")
//                     throw TypeError(".proto.FileCreateTransactionBody.shardID: object expected");
//                 message.shardID = $root.proto.ShardID.fromObject(object.shardID);
//             }
//             if (object.realmID != null) {
//                 if (typeof object.realmID !== "object")
//                     throw TypeError(".proto.FileCreateTransactionBody.realmID: object expected");
//                 message.realmID = $root.proto.RealmID.fromObject(object.realmID);
//             }
//             if (object.newRealmAdminKey != null) {
//                 if (typeof object.newRealmAdminKey !== "object")
//                     throw TypeError(".proto.FileCreateTransactionBody.newRealmAdminKey: object expected");
//                 message.newRealmAdminKey = $root.proto.Key.fromObject(object.newRealmAdminKey);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileCreateTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileCreateTransactionBody
//          * @static
//          * @param {proto.FileCreateTransactionBody} message FileCreateTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileCreateTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.expirationTime = null;
//                 object.keys = null;
//                 if (options.bytes === String)
//                     object.contents = "";
//                 else {
//                     object.contents = [];
//                     if (options.bytes !== Array)
//                         object.contents = $util.newBuffer(object.contents);
//                 }
//                 object.shardID = null;
//                 object.realmID = null;
//                 object.newRealmAdminKey = null;
//             }
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//             if (message.keys != null && message.hasOwnProperty("keys"))
//                 object.keys = $root.proto.KeyList.toObject(message.keys, options);
//             if (message.contents != null && message.hasOwnProperty("contents"))
//                 object.contents = options.bytes === String ? $util.base64.encode(message.contents, 0, message.contents.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents) : message.contents;
//             if (message.shardID != null && message.hasOwnProperty("shardID"))
//                 object.shardID = $root.proto.ShardID.toObject(message.shardID, options);
//             if (message.realmID != null && message.hasOwnProperty("realmID"))
//                 object.realmID = $root.proto.RealmID.toObject(message.realmID, options);
//             if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey"))
//                 object.newRealmAdminKey = $root.proto.Key.toObject(message.newRealmAdminKey, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FileCreateTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.FileCreateTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileCreateTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FileCreateTransactionBody;
//     })();
// 
//     proto.FileDeleteTransactionBody = (function() {
// 
//         /**
//          * Properties of a FileDeleteTransactionBody.
//          * @memberof proto
//          * @interface IFileDeleteTransactionBody
//          * @property {proto.IFileID|null} [fileID] FileDeleteTransactionBody fileID
//          */
// 
//         /**
//          * Constructs a new FileDeleteTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a FileDeleteTransactionBody.
//          * @implements IFileDeleteTransactionBody
//          * @constructor
//          * @param {proto.IFileDeleteTransactionBody=} [properties] Properties to set
//          */
//         function FileDeleteTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileDeleteTransactionBody fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.FileDeleteTransactionBody
//          * @instance
//          */
//         FileDeleteTransactionBody.prototype.fileID = null;
// 
//         /**
//          * Creates a new FileDeleteTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {proto.IFileDeleteTransactionBody=} [properties] Properties to set
//          * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody instance
//          */
//         FileDeleteTransactionBody.create = function create(properties) {
//             return new FileDeleteTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified FileDeleteTransactionBody message. Does not implicitly {@link proto.FileDeleteTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {proto.IFileDeleteTransactionBody} message FileDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileDeleteTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileDeleteTransactionBody message, length delimited. Does not implicitly {@link proto.FileDeleteTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {proto.IFileDeleteTransactionBody} message FileDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileDeleteTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileDeleteTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileDeleteTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileDeleteTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 2:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileDeleteTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileDeleteTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileDeleteTransactionBody message.
//          * @function verify
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileDeleteTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FileDeleteTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody
//          */
//         FileDeleteTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileDeleteTransactionBody)
//                 return object;
//             let message = new $root.proto.FileDeleteTransactionBody();
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.FileDeleteTransactionBody.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileDeleteTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileDeleteTransactionBody
//          * @static
//          * @param {proto.FileDeleteTransactionBody} message FileDeleteTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileDeleteTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.fileID = null;
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FileDeleteTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.FileDeleteTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileDeleteTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FileDeleteTransactionBody;
//     })();
// 
//     proto.FileUpdateTransactionBody = (function() {
// 
//         /**
//          * Properties of a FileUpdateTransactionBody.
//          * @memberof proto
//          * @interface IFileUpdateTransactionBody
//          * @property {proto.IFileID|null} [fileID] FileUpdateTransactionBody fileID
//          * @property {proto.ITimestamp|null} [expirationTime] FileUpdateTransactionBody expirationTime
//          * @property {proto.IKeyList|null} [keys] FileUpdateTransactionBody keys
//          * @property {Uint8Array|null} [contents] FileUpdateTransactionBody contents
//          */
// 
//         /**
//          * Constructs a new FileUpdateTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a FileUpdateTransactionBody.
//          * @implements IFileUpdateTransactionBody
//          * @constructor
//          * @param {proto.IFileUpdateTransactionBody=} [properties] Properties to set
//          */
//         function FileUpdateTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileUpdateTransactionBody fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.FileUpdateTransactionBody
//          * @instance
//          */
//         FileUpdateTransactionBody.prototype.fileID = null;
// 
//         /**
//          * FileUpdateTransactionBody expirationTime.
//          * @member {proto.ITimestamp|null|undefined} expirationTime
//          * @memberof proto.FileUpdateTransactionBody
//          * @instance
//          */
//         FileUpdateTransactionBody.prototype.expirationTime = null;
// 
//         /**
//          * FileUpdateTransactionBody keys.
//          * @member {proto.IKeyList|null|undefined} keys
//          * @memberof proto.FileUpdateTransactionBody
//          * @instance
//          */
//         FileUpdateTransactionBody.prototype.keys = null;
// 
//         /**
//          * FileUpdateTransactionBody contents.
//          * @member {Uint8Array} contents
//          * @memberof proto.FileUpdateTransactionBody
//          * @instance
//          */
//         FileUpdateTransactionBody.prototype.contents = $util.newBuffer([]);
// 
//         /**
//          * Creates a new FileUpdateTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {proto.IFileUpdateTransactionBody=} [properties] Properties to set
//          * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody instance
//          */
//         FileUpdateTransactionBody.create = function create(properties) {
//             return new FileUpdateTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified FileUpdateTransactionBody message. Does not implicitly {@link proto.FileUpdateTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {proto.IFileUpdateTransactionBody} message FileUpdateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileUpdateTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
//                 $root.proto.KeyList.encode(message.keys, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.contents != null && Object.hasOwnProperty.call(message, "contents"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.contents);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileUpdateTransactionBody message, length delimited. Does not implicitly {@link proto.FileUpdateTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {proto.IFileUpdateTransactionBody} message FileUpdateTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileUpdateTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileUpdateTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileUpdateTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUpdateTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.keys = $root.proto.KeyList.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contents = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileUpdateTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileUpdateTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileUpdateTransactionBody message.
//          * @function verify
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileUpdateTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.Timestamp.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             if (message.keys != null && message.hasOwnProperty("keys")) {
//                 let error = $root.proto.KeyList.verify(message.keys);
//                 if (error)
//                     return "keys." + error;
//             }
//             if (message.contents != null && message.hasOwnProperty("contents"))
//                 if (!(message.contents && typeof message.contents.length === "number" || $util.isString(message.contents)))
//                     return "contents: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a FileUpdateTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody
//          */
//         FileUpdateTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileUpdateTransactionBody)
//                 return object;
//             let message = new $root.proto.FileUpdateTransactionBody();
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.FileUpdateTransactionBody.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.FileUpdateTransactionBody.expirationTime: object expected");
//                 message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//             }
//             if (object.keys != null) {
//                 if (typeof object.keys !== "object")
//                     throw TypeError(".proto.FileUpdateTransactionBody.keys: object expected");
//                 message.keys = $root.proto.KeyList.fromObject(object.keys);
//             }
//             if (object.contents != null)
//                 if (typeof object.contents === "string")
//                     $util.base64.decode(object.contents, message.contents = $util.newBuffer($util.base64.length(object.contents)), 0);
//                 else if (object.contents.length)
//                     message.contents = object.contents;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileUpdateTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileUpdateTransactionBody
//          * @static
//          * @param {proto.FileUpdateTransactionBody} message FileUpdateTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileUpdateTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.fileID = null;
//                 object.expirationTime = null;
//                 object.keys = null;
//                 if (options.bytes === String)
//                     object.contents = "";
//                 else {
//                     object.contents = [];
//                     if (options.bytes !== Array)
//                         object.contents = $util.newBuffer(object.contents);
//                 }
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//             if (message.keys != null && message.hasOwnProperty("keys"))
//                 object.keys = $root.proto.KeyList.toObject(message.keys, options);
//             if (message.contents != null && message.hasOwnProperty("contents"))
//                 object.contents = options.bytes === String ? $util.base64.encode(message.contents, 0, message.contents.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents) : message.contents;
//             return object;
//         };
// 
//         /**
//          * Converts this FileUpdateTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.FileUpdateTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileUpdateTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FileUpdateTransactionBody;
//     })();
// 
//     proto.ContractDeleteTransactionBody = (function() {
// 
//         /**
//          * Properties of a ContractDeleteTransactionBody.
//          * @memberof proto
//          * @interface IContractDeleteTransactionBody
//          * @property {proto.IContractID|null} [contractID] ContractDeleteTransactionBody contractID
//          * @property {proto.IAccountID|null} [transferAccountID] ContractDeleteTransactionBody transferAccountID
//          * @property {proto.IContractID|null} [transferContractID] ContractDeleteTransactionBody transferContractID
//          */
// 
//         /**
//          * Constructs a new ContractDeleteTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ContractDeleteTransactionBody.
//          * @implements IContractDeleteTransactionBody
//          * @constructor
//          * @param {proto.IContractDeleteTransactionBody=} [properties] Properties to set
//          */
//         function ContractDeleteTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractDeleteTransactionBody contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractDeleteTransactionBody
//          * @instance
//          */
//         ContractDeleteTransactionBody.prototype.contractID = null;
// 
//         /**
//          * ContractDeleteTransactionBody transferAccountID.
//          * @member {proto.IAccountID|null|undefined} transferAccountID
//          * @memberof proto.ContractDeleteTransactionBody
//          * @instance
//          */
//         ContractDeleteTransactionBody.prototype.transferAccountID = null;
// 
//         /**
//          * ContractDeleteTransactionBody transferContractID.
//          * @member {proto.IContractID|null|undefined} transferContractID
//          * @memberof proto.ContractDeleteTransactionBody
//          * @instance
//          */
//         ContractDeleteTransactionBody.prototype.transferContractID = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * ContractDeleteTransactionBody obtainers.
//          * @member {"transferAccountID"|"transferContractID"|undefined} obtainers
//          * @memberof proto.ContractDeleteTransactionBody
//          * @instance
//          */
//         Object.defineProperty(ContractDeleteTransactionBody.prototype, "obtainers", {
//             get: $util.oneOfGetter($oneOfFields = ["transferAccountID", "transferContractID"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new ContractDeleteTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {proto.IContractDeleteTransactionBody=} [properties] Properties to set
//          * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody instance
//          */
//         ContractDeleteTransactionBody.create = function create(properties) {
//             return new ContractDeleteTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractDeleteTransactionBody message. Does not implicitly {@link proto.ContractDeleteTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {proto.IContractDeleteTransactionBody} message ContractDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractDeleteTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.transferAccountID != null && Object.hasOwnProperty.call(message, "transferAccountID"))
//                 $root.proto.AccountID.encode(message.transferAccountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.transferContractID != null && Object.hasOwnProperty.call(message, "transferContractID"))
//                 $root.proto.ContractID.encode(message.transferContractID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractDeleteTransactionBody message, length delimited. Does not implicitly {@link proto.ContractDeleteTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {proto.IContractDeleteTransactionBody} message ContractDeleteTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractDeleteTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractDeleteTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractDeleteTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractDeleteTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.transferAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.transferContractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractDeleteTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractDeleteTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractDeleteTransactionBody message.
//          * @function verify
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractDeleteTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.transferAccountID != null && message.hasOwnProperty("transferAccountID")) {
//                 properties.obtainers = 1;
//                 {
//                     let error = $root.proto.AccountID.verify(message.transferAccountID);
//                     if (error)
//                         return "transferAccountID." + error;
//                 }
//             }
//             if (message.transferContractID != null && message.hasOwnProperty("transferContractID")) {
//                 if (properties.obtainers === 1)
//                     return "obtainers: multiple values";
//                 properties.obtainers = 1;
//                 {
//                     let error = $root.proto.ContractID.verify(message.transferContractID);
//                     if (error)
//                         return "transferContractID." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractDeleteTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody
//          */
//         ContractDeleteTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractDeleteTransactionBody)
//                 return object;
//             let message = new $root.proto.ContractDeleteTransactionBody();
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractDeleteTransactionBody.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.transferAccountID != null) {
//                 if (typeof object.transferAccountID !== "object")
//                     throw TypeError(".proto.ContractDeleteTransactionBody.transferAccountID: object expected");
//                 message.transferAccountID = $root.proto.AccountID.fromObject(object.transferAccountID);
//             }
//             if (object.transferContractID != null) {
//                 if (typeof object.transferContractID !== "object")
//                     throw TypeError(".proto.ContractDeleteTransactionBody.transferContractID: object expected");
//                 message.transferContractID = $root.proto.ContractID.fromObject(object.transferContractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractDeleteTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractDeleteTransactionBody
//          * @static
//          * @param {proto.ContractDeleteTransactionBody} message ContractDeleteTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractDeleteTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.contractID = null;
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.transferAccountID != null && message.hasOwnProperty("transferAccountID")) {
//                 object.transferAccountID = $root.proto.AccountID.toObject(message.transferAccountID, options);
//                 if (options.oneofs)
//                     object.obtainers = "transferAccountID";
//             }
//             if (message.transferContractID != null && message.hasOwnProperty("transferContractID")) {
//                 object.transferContractID = $root.proto.ContractID.toObject(message.transferContractID, options);
//                 if (options.oneofs)
//                     object.obtainers = "transferContractID";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this ContractDeleteTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ContractDeleteTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractDeleteTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractDeleteTransactionBody;
//     })();
// 
//     proto.ConsensusUpdateTopicTransactionBody = (function() {
// 
//         /**
//          * Properties of a ConsensusUpdateTopicTransactionBody.
//          * @memberof proto
//          * @interface IConsensusUpdateTopicTransactionBody
//          * @property {proto.ITopicID|null} [topicID] ConsensusUpdateTopicTransactionBody topicID
//          * @property {proto.IStringValue|null} [memo] ConsensusUpdateTopicTransactionBody memo
//          * @property {proto.ITimestamp|null} [expirationTime] ConsensusUpdateTopicTransactionBody expirationTime
//          * @property {proto.IKey|null} [adminKey] ConsensusUpdateTopicTransactionBody adminKey
//          * @property {proto.IKey|null} [submitKey] ConsensusUpdateTopicTransactionBody submitKey
//          * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusUpdateTopicTransactionBody autoRenewPeriod
//          * @property {proto.IAccountID|null} [autoRenewAccount] ConsensusUpdateTopicTransactionBody autoRenewAccount
//          */
// 
//         /**
//          * Constructs a new ConsensusUpdateTopicTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ConsensusUpdateTopicTransactionBody.
//          * @implements IConsensusUpdateTopicTransactionBody
//          * @constructor
//          * @param {proto.IConsensusUpdateTopicTransactionBody=} [properties] Properties to set
//          */
//         function ConsensusUpdateTopicTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusUpdateTopicTransactionBody topicID.
//          * @member {proto.ITopicID|null|undefined} topicID
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.topicID = null;
// 
//         /**
//          * ConsensusUpdateTopicTransactionBody memo.
//          * @member {proto.IStringValue|null|undefined} memo
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.memo = null;
// 
//         /**
//          * ConsensusUpdateTopicTransactionBody expirationTime.
//          * @member {proto.ITimestamp|null|undefined} expirationTime
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.expirationTime = null;
// 
//         /**
//          * ConsensusUpdateTopicTransactionBody adminKey.
//          * @member {proto.IKey|null|undefined} adminKey
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.adminKey = null;
// 
//         /**
//          * ConsensusUpdateTopicTransactionBody submitKey.
//          * @member {proto.IKey|null|undefined} submitKey
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.submitKey = null;
// 
//         /**
//          * ConsensusUpdateTopicTransactionBody autoRenewPeriod.
//          * @member {proto.IDuration|null|undefined} autoRenewPeriod
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.autoRenewPeriod = null;
// 
//         /**
//          * ConsensusUpdateTopicTransactionBody autoRenewAccount.
//          * @member {proto.IAccountID|null|undefined} autoRenewAccount
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.autoRenewAccount = null;
// 
//         /**
//          * Creates a new ConsensusUpdateTopicTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusUpdateTopicTransactionBody=} [properties] Properties to set
//          * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody instance
//          */
//         ConsensusUpdateTopicTransactionBody.create = function create(properties) {
//             return new ConsensusUpdateTopicTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusUpdateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusUpdateTopicTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusUpdateTopicTransactionBody} message ConsensusUpdateTopicTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusUpdateTopicTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.topicID != null && Object.hasOwnProperty.call(message, "topicID"))
//                 $root.proto.TopicID.encode(message.topicID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 $root.proto.StringValue.encode(message.memo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.adminKey != null && Object.hasOwnProperty.call(message, "adminKey"))
//                 $root.proto.Key.encode(message.adminKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.submitKey != null && Object.hasOwnProperty.call(message, "submitKey"))
//                 $root.proto.Key.encode(message.submitKey, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                 $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.autoRenewAccount != null && Object.hasOwnProperty.call(message, "autoRenewAccount"))
//                 $root.proto.AccountID.encode(message.autoRenewAccount, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusUpdateTopicTransactionBody message, length delimited. Does not implicitly {@link proto.ConsensusUpdateTopicTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {proto.IConsensusUpdateTopicTransactionBody} message ConsensusUpdateTopicTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusUpdateTopicTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusUpdateTopicTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusUpdateTopicTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusUpdateTopicTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.topicID = $root.proto.TopicID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.memo = $root.proto.StringValue.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.adminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.submitKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 9:
//                     message.autoRenewAccount = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusUpdateTopicTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusUpdateTopicTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusUpdateTopicTransactionBody message.
//          * @function verify
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusUpdateTopicTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.topicID != null && message.hasOwnProperty("topicID")) {
//                 let error = $root.proto.TopicID.verify(message.topicID);
//                 if (error)
//                     return "topicID." + error;
//             }
//             if (message.memo != null && message.hasOwnProperty("memo")) {
//                 let error = $root.proto.StringValue.verify(message.memo);
//                 if (error)
//                     return "memo." + error;
//             }
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.Timestamp.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             if (message.adminKey != null && message.hasOwnProperty("adminKey")) {
//                 let error = $root.proto.Key.verify(message.adminKey);
//                 if (error)
//                     return "adminKey." + error;
//             }
//             if (message.submitKey != null && message.hasOwnProperty("submitKey")) {
//                 let error = $root.proto.Key.verify(message.submitKey);
//                 if (error)
//                     return "submitKey." + error;
//             }
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                 let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                 if (error)
//                     return "autoRenewPeriod." + error;
//             }
//             if (message.autoRenewAccount != null && message.hasOwnProperty("autoRenewAccount")) {
//                 let error = $root.proto.AccountID.verify(message.autoRenewAccount);
//                 if (error)
//                     return "autoRenewAccount." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusUpdateTopicTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody
//          */
//         ConsensusUpdateTopicTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusUpdateTopicTransactionBody)
//                 return object;
//             let message = new $root.proto.ConsensusUpdateTopicTransactionBody();
//             if (object.topicID != null) {
//                 if (typeof object.topicID !== "object")
//                     throw TypeError(".proto.ConsensusUpdateTopicTransactionBody.topicID: object expected");
//                 message.topicID = $root.proto.TopicID.fromObject(object.topicID);
//             }
//             if (object.memo != null) {
//                 if (typeof object.memo !== "object")
//                     throw TypeError(".proto.ConsensusUpdateTopicTransactionBody.memo: object expected");
//                 message.memo = $root.proto.StringValue.fromObject(object.memo);
//             }
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.ConsensusUpdateTopicTransactionBody.expirationTime: object expected");
//                 message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//             }
//             if (object.adminKey != null) {
//                 if (typeof object.adminKey !== "object")
//                     throw TypeError(".proto.ConsensusUpdateTopicTransactionBody.adminKey: object expected");
//                 message.adminKey = $root.proto.Key.fromObject(object.adminKey);
//             }
//             if (object.submitKey != null) {
//                 if (typeof object.submitKey !== "object")
//                     throw TypeError(".proto.ConsensusUpdateTopicTransactionBody.submitKey: object expected");
//                 message.submitKey = $root.proto.Key.fromObject(object.submitKey);
//             }
//             if (object.autoRenewPeriod != null) {
//                 if (typeof object.autoRenewPeriod !== "object")
//                     throw TypeError(".proto.ConsensusUpdateTopicTransactionBody.autoRenewPeriod: object expected");
//                 message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//             }
//             if (object.autoRenewAccount != null) {
//                 if (typeof object.autoRenewAccount !== "object")
//                     throw TypeError(".proto.ConsensusUpdateTopicTransactionBody.autoRenewAccount: object expected");
//                 message.autoRenewAccount = $root.proto.AccountID.fromObject(object.autoRenewAccount);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusUpdateTopicTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @static
//          * @param {proto.ConsensusUpdateTopicTransactionBody} message ConsensusUpdateTopicTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusUpdateTopicTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.topicID = null;
//                 object.memo = null;
//                 object.expirationTime = null;
//                 object.adminKey = null;
//                 object.submitKey = null;
//                 object.autoRenewPeriod = null;
//                 object.autoRenewAccount = null;
//             }
//             if (message.topicID != null && message.hasOwnProperty("topicID"))
//                 object.topicID = $root.proto.TopicID.toObject(message.topicID, options);
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = $root.proto.StringValue.toObject(message.memo, options);
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//             if (message.adminKey != null && message.hasOwnProperty("adminKey"))
//                 object.adminKey = $root.proto.Key.toObject(message.adminKey, options);
//             if (message.submitKey != null && message.hasOwnProperty("submitKey"))
//                 object.submitKey = $root.proto.Key.toObject(message.submitKey, options);
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                 object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//             if (message.autoRenewAccount != null && message.hasOwnProperty("autoRenewAccount"))
//                 object.autoRenewAccount = $root.proto.AccountID.toObject(message.autoRenewAccount, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusUpdateTopicTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusUpdateTopicTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusUpdateTopicTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusUpdateTopicTransactionBody;
//     })();
// 
//     proto.ConsensusMessageChunkInfo = (function() {
// 
//         /**
//          * Properties of a ConsensusMessageChunkInfo.
//          * @memberof proto
//          * @interface IConsensusMessageChunkInfo
//          * @property {proto.ITransactionID|null} [initialTransactionID] ConsensusMessageChunkInfo initialTransactionID
//          * @property {number|null} [total] ConsensusMessageChunkInfo total
//          * @property {number|null} [number] ConsensusMessageChunkInfo number
//          */
// 
//         /**
//          * Constructs a new ConsensusMessageChunkInfo.
//          * @memberof proto
//          * @classdesc Represents a ConsensusMessageChunkInfo.
//          * @implements IConsensusMessageChunkInfo
//          * @constructor
//          * @param {proto.IConsensusMessageChunkInfo=} [properties] Properties to set
//          */
//         function ConsensusMessageChunkInfo(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusMessageChunkInfo initialTransactionID.
//          * @member {proto.ITransactionID|null|undefined} initialTransactionID
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @instance
//          */
//         ConsensusMessageChunkInfo.prototype.initialTransactionID = null;
// 
//         /**
//          * ConsensusMessageChunkInfo total.
//          * @member {number} total
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @instance
//          */
//         ConsensusMessageChunkInfo.prototype.total = 0;
// 
//         /**
//          * ConsensusMessageChunkInfo number.
//          * @member {number} number
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @instance
//          */
//         ConsensusMessageChunkInfo.prototype.number = 0;
// 
//         /**
//          * Creates a new ConsensusMessageChunkInfo instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {proto.IConsensusMessageChunkInfo=} [properties] Properties to set
//          * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo instance
//          */
//         ConsensusMessageChunkInfo.create = function create(properties) {
//             return new ConsensusMessageChunkInfo(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusMessageChunkInfo message. Does not implicitly {@link proto.ConsensusMessageChunkInfo.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {proto.IConsensusMessageChunkInfo} message ConsensusMessageChunkInfo message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusMessageChunkInfo.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.initialTransactionID != null && Object.hasOwnProperty.call(message, "initialTransactionID"))
//                 $root.proto.TransactionID.encode(message.initialTransactionID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.total != null && Object.hasOwnProperty.call(message, "total"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.total);
//             if (message.number != null && Object.hasOwnProperty.call(message, "number"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusMessageChunkInfo message, length delimited. Does not implicitly {@link proto.ConsensusMessageChunkInfo.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {proto.IConsensusMessageChunkInfo} message ConsensusMessageChunkInfo message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusMessageChunkInfo.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusMessageChunkInfo message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusMessageChunkInfo.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusMessageChunkInfo();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.initialTransactionID = $root.proto.TransactionID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.total = reader.int32();
//                     break;
//                 case 3:
//                     message.number = reader.int32();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusMessageChunkInfo message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusMessageChunkInfo.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusMessageChunkInfo message.
//          * @function verify
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusMessageChunkInfo.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.initialTransactionID != null && message.hasOwnProperty("initialTransactionID")) {
//                 let error = $root.proto.TransactionID.verify(message.initialTransactionID);
//                 if (error)
//                     return "initialTransactionID." + error;
//             }
//             if (message.total != null && message.hasOwnProperty("total"))
//                 if (!$util.isInteger(message.total))
//                     return "total: integer expected";
//             if (message.number != null && message.hasOwnProperty("number"))
//                 if (!$util.isInteger(message.number))
//                     return "number: integer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusMessageChunkInfo message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo
//          */
//         ConsensusMessageChunkInfo.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusMessageChunkInfo)
//                 return object;
//             let message = new $root.proto.ConsensusMessageChunkInfo();
//             if (object.initialTransactionID != null) {
//                 if (typeof object.initialTransactionID !== "object")
//                     throw TypeError(".proto.ConsensusMessageChunkInfo.initialTransactionID: object expected");
//                 message.initialTransactionID = $root.proto.TransactionID.fromObject(object.initialTransactionID);
//             }
//             if (object.total != null)
//                 message.total = object.total | 0;
//             if (object.number != null)
//                 message.number = object.number | 0;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusMessageChunkInfo message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @static
//          * @param {proto.ConsensusMessageChunkInfo} message ConsensusMessageChunkInfo
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusMessageChunkInfo.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.initialTransactionID = null;
//                 object.total = 0;
//                 object.number = 0;
//             }
//             if (message.initialTransactionID != null && message.hasOwnProperty("initialTransactionID"))
//                 object.initialTransactionID = $root.proto.TransactionID.toObject(message.initialTransactionID, options);
//             if (message.total != null && message.hasOwnProperty("total"))
//                 object.total = message.total;
//             if (message.number != null && message.hasOwnProperty("number"))
//                 object.number = message.number;
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusMessageChunkInfo to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusMessageChunkInfo
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusMessageChunkInfo.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusMessageChunkInfo;
//     })();
// 
//     proto.ConsensusSubmitMessageTransactionBody = (function() {
// 
//         /**
//          * Properties of a ConsensusSubmitMessageTransactionBody.
//          * @memberof proto
//          * @interface IConsensusSubmitMessageTransactionBody
//          * @property {proto.ITopicID|null} [topicID] ConsensusSubmitMessageTransactionBody topicID
//          * @property {Uint8Array|null} [message] ConsensusSubmitMessageTransactionBody message
//          * @property {proto.IConsensusMessageChunkInfo|null} [chunkInfo] ConsensusSubmitMessageTransactionBody chunkInfo
//          */
// 
//         /**
//          * Constructs a new ConsensusSubmitMessageTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a ConsensusSubmitMessageTransactionBody.
//          * @implements IConsensusSubmitMessageTransactionBody
//          * @constructor
//          * @param {proto.IConsensusSubmitMessageTransactionBody=} [properties] Properties to set
//          */
//         function ConsensusSubmitMessageTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusSubmitMessageTransactionBody topicID.
//          * @member {proto.ITopicID|null|undefined} topicID
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @instance
//          */
//         ConsensusSubmitMessageTransactionBody.prototype.topicID = null;
// 
//         /**
//          * ConsensusSubmitMessageTransactionBody message.
//          * @member {Uint8Array} message
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @instance
//          */
//         ConsensusSubmitMessageTransactionBody.prototype.message = $util.newBuffer([]);
// 
//         /**
//          * ConsensusSubmitMessageTransactionBody chunkInfo.
//          * @member {proto.IConsensusMessageChunkInfo|null|undefined} chunkInfo
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @instance
//          */
//         ConsensusSubmitMessageTransactionBody.prototype.chunkInfo = null;
// 
//         /**
//          * Creates a new ConsensusSubmitMessageTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {proto.IConsensusSubmitMessageTransactionBody=} [properties] Properties to set
//          * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody instance
//          */
//         ConsensusSubmitMessageTransactionBody.create = function create(properties) {
//             return new ConsensusSubmitMessageTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusSubmitMessageTransactionBody message. Does not implicitly {@link proto.ConsensusSubmitMessageTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {proto.IConsensusSubmitMessageTransactionBody} message ConsensusSubmitMessageTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusSubmitMessageTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.topicID != null && Object.hasOwnProperty.call(message, "topicID"))
//                 $root.proto.TopicID.encode(message.topicID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.message != null && Object.hasOwnProperty.call(message, "message"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.message);
//             if (message.chunkInfo != null && Object.hasOwnProperty.call(message, "chunkInfo"))
//                 $root.proto.ConsensusMessageChunkInfo.encode(message.chunkInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusSubmitMessageTransactionBody message, length delimited. Does not implicitly {@link proto.ConsensusSubmitMessageTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {proto.IConsensusSubmitMessageTransactionBody} message ConsensusSubmitMessageTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusSubmitMessageTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusSubmitMessageTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusSubmitMessageTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusSubmitMessageTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.topicID = $root.proto.TopicID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.message = reader.bytes();
//                     break;
//                 case 3:
//                     message.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusSubmitMessageTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusSubmitMessageTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusSubmitMessageTransactionBody message.
//          * @function verify
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusSubmitMessageTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.topicID != null && message.hasOwnProperty("topicID")) {
//                 let error = $root.proto.TopicID.verify(message.topicID);
//                 if (error)
//                     return "topicID." + error;
//             }
//             if (message.message != null && message.hasOwnProperty("message"))
//                 if (!(message.message && typeof message.message.length === "number" || $util.isString(message.message)))
//                     return "message: buffer expected";
//             if (message.chunkInfo != null && message.hasOwnProperty("chunkInfo")) {
//                 let error = $root.proto.ConsensusMessageChunkInfo.verify(message.chunkInfo);
//                 if (error)
//                     return "chunkInfo." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusSubmitMessageTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody
//          */
//         ConsensusSubmitMessageTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusSubmitMessageTransactionBody)
//                 return object;
//             let message = new $root.proto.ConsensusSubmitMessageTransactionBody();
//             if (object.topicID != null) {
//                 if (typeof object.topicID !== "object")
//                     throw TypeError(".proto.ConsensusSubmitMessageTransactionBody.topicID: object expected");
//                 message.topicID = $root.proto.TopicID.fromObject(object.topicID);
//             }
//             if (object.message != null)
//                 if (typeof object.message === "string")
//                     $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);
//                 else if (object.message.length)
//                     message.message = object.message;
//             if (object.chunkInfo != null) {
//                 if (typeof object.chunkInfo !== "object")
//                     throw TypeError(".proto.ConsensusSubmitMessageTransactionBody.chunkInfo: object expected");
//                 message.chunkInfo = $root.proto.ConsensusMessageChunkInfo.fromObject(object.chunkInfo);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusSubmitMessageTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @static
//          * @param {proto.ConsensusSubmitMessageTransactionBody} message ConsensusSubmitMessageTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusSubmitMessageTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.topicID = null;
//                 if (options.bytes === String)
//                     object.message = "";
//                 else {
//                     object.message = [];
//                     if (options.bytes !== Array)
//                         object.message = $util.newBuffer(object.message);
//                 }
//                 object.chunkInfo = null;
//             }
//             if (message.topicID != null && message.hasOwnProperty("topicID"))
//                 object.topicID = $root.proto.TopicID.toObject(message.topicID, options);
//             if (message.message != null && message.hasOwnProperty("message"))
//                 object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;
//             if (message.chunkInfo != null && message.hasOwnProperty("chunkInfo"))
//                 object.chunkInfo = $root.proto.ConsensusMessageChunkInfo.toObject(message.chunkInfo, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusSubmitMessageTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusSubmitMessageTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusSubmitMessageTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusSubmitMessageTransactionBody;
//     })();
// 
//     proto.ResponseHeader = (function() {
// 
//         /**
//          * Properties of a ResponseHeader.
//          * @memberof proto
//          * @interface IResponseHeader
//          * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] ResponseHeader nodeTransactionPrecheckCode
//          * @property {proto.ResponseType|null} [responseType] ResponseHeader responseType
//          * @property {number|Long|null} [cost] ResponseHeader cost
//          * @property {Uint8Array|null} [stateProof] ResponseHeader stateProof
//          */
// 
//         /**
//          * Constructs a new ResponseHeader.
//          * @memberof proto
//          * @classdesc Represents a ResponseHeader.
//          * @implements IResponseHeader
//          * @constructor
//          * @param {proto.IResponseHeader=} [properties] Properties to set
//          */
//         function ResponseHeader(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ResponseHeader nodeTransactionPrecheckCode.
//          * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
//          * @memberof proto.ResponseHeader
//          * @instance
//          */
//         ResponseHeader.prototype.nodeTransactionPrecheckCode = 0;
// 
//         /**
//          * ResponseHeader responseType.
//          * @member {proto.ResponseType} responseType
//          * @memberof proto.ResponseHeader
//          * @instance
//          */
//         ResponseHeader.prototype.responseType = 0;
// 
//         /**
//          * ResponseHeader cost.
//          * @member {number|Long} cost
//          * @memberof proto.ResponseHeader
//          * @instance
//          */
//         ResponseHeader.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * ResponseHeader stateProof.
//          * @member {Uint8Array} stateProof
//          * @memberof proto.ResponseHeader
//          * @instance
//          */
//         ResponseHeader.prototype.stateProof = $util.newBuffer([]);
// 
//         /**
//          * Creates a new ResponseHeader instance using the specified properties.
//          * @function create
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {proto.IResponseHeader=} [properties] Properties to set
//          * @returns {proto.ResponseHeader} ResponseHeader instance
//          */
//         ResponseHeader.create = function create(properties) {
//             return new ResponseHeader(properties);
//         };
// 
//         /**
//          * Encodes the specified ResponseHeader message. Does not implicitly {@link proto.ResponseHeader.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {proto.IResponseHeader} message ResponseHeader message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ResponseHeader.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(message, "nodeTransactionPrecheckCode"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nodeTransactionPrecheckCode);
//             if (message.responseType != null && Object.hasOwnProperty.call(message, "responseType"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.responseType);
//             if (message.cost != null && Object.hasOwnProperty.call(message, "cost"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.cost);
//             if (message.stateProof != null && Object.hasOwnProperty.call(message, "stateProof"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.stateProof);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ResponseHeader message, length delimited. Does not implicitly {@link proto.ResponseHeader.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {proto.IResponseHeader} message ResponseHeader message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ResponseHeader.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ResponseHeader message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ResponseHeader} ResponseHeader
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ResponseHeader.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ResponseHeader();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.nodeTransactionPrecheckCode = reader.int32();
//                     break;
//                 case 2:
//                     message.responseType = reader.int32();
//                     break;
//                 case 3:
//                     message.cost = reader.uint64();
//                     break;
//                 case 4:
//                     message.stateProof = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ResponseHeader message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ResponseHeader} ResponseHeader
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ResponseHeader.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ResponseHeader message.
//          * @function verify
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ResponseHeader.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.nodeTransactionPrecheckCode != null && message.hasOwnProperty("nodeTransactionPrecheckCode"))
//                 switch (message.nodeTransactionPrecheckCode) {
//                 default:
//                     return "nodeTransactionPrecheckCode: enum value expected";
//                 case 0:
//                 case 1:
//                 case 2:
//                 case 3:
//                 case 4:
//                 case 5:
//                 case 6:
//                 case 7:
//                 case 8:
//                 case 9:
//                 case 10:
//                 case 11:
//                 case 12:
//                 case 13:
//                 case 14:
//                 case 15:
//                 case 16:
//                 case 17:
//                 case 18:
//                 case 19:
//                 case 20:
//                 case 21:
//                 case 22:
//                 case 23:
//                 case 24:
//                 case 25:
//                 case 26:
//                 case 27:
//                 case 28:
//                 case 29:
//                 case 30:
//                 case 31:
//                 case 32:
//                 case 33:
//                 case 34:
//                 case 35:
//                 case 36:
//                 case 37:
//                 case 38:
//                 case 39:
//                 case 40:
//                 case 41:
//                 case 42:
//                 case 43:
//                 case 44:
//                 case 45:
//                 case 46:
//                 case 47:
//                 case 48:
//                 case 49:
//                 case 50:
//                 case 51:
//                 case 52:
//                 case 53:
//                 case 54:
//                 case 55:
//                 case 56:
//                 case 57:
//                 case 58:
//                 case 59:
//                 case 60:
//                 case 61:
//                 case 62:
//                 case 63:
//                 case 64:
//                 case 65:
//                 case 66:
//                 case 67:
//                 case 68:
//                 case 69:
//                 case 70:
//                 case 71:
//                 case 72:
//                 case 73:
//                 case 74:
//                 case 75:
//                 case 76:
//                 case 77:
//                 case 78:
//                 case 79:
//                 case 80:
//                 case 81:
//                 case 82:
//                 case 83:
//                 case 84:
//                 case 85:
//                 case 86:
//                 case 87:
//                 case 88:
//                 case 89:
//                 case 90:
//                 case 91:
//                 case 92:
//                 case 93:
//                 case 94:
//                 case 95:
//                 case 96:
//                 case 97:
//                 case 98:
//                 case 99:
//                 case 100:
//                 case 101:
//                 case 102:
//                 case 103:
//                 case 104:
//                 case 105:
//                 case 106:
//                 case 107:
//                 case 108:
//                 case 110:
//                 case 111:
//                 case 112:
//                 case 150:
//                 case 155:
//                 case 156:
//                 case 157:
//                 case 158:
//                 case 159:
//                 case 160:
//                 case 162:
//                 case 163:
//                 case 164:
//                     break;
//                 }
//             if (message.responseType != null && message.hasOwnProperty("responseType"))
//                 switch (message.responseType) {
//                 default:
//                     return "responseType: enum value expected";
//                 case 0:
//                 case 1:
//                 case 2:
//                 case 3:
//                     break;
//                 }
//             if (message.cost != null && message.hasOwnProperty("cost"))
//                 if (!$util.isInteger(message.cost) && !(message.cost && $util.isInteger(message.cost.low) && $util.isInteger(message.cost.high)))
//                     return "cost: integer|Long expected";
//             if (message.stateProof != null && message.hasOwnProperty("stateProof"))
//                 if (!(message.stateProof && typeof message.stateProof.length === "number" || $util.isString(message.stateProof)))
//                     return "stateProof: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ResponseHeader message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ResponseHeader} ResponseHeader
//          */
//         ResponseHeader.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ResponseHeader)
//                 return object;
//             let message = new $root.proto.ResponseHeader();
//             switch (object.nodeTransactionPrecheckCode) {
//             case "OK":
//             case 0:
//                 message.nodeTransactionPrecheckCode = 0;
//                 break;
//             case "INVALID_TRANSACTION":
//             case 1:
//                 message.nodeTransactionPrecheckCode = 1;
//                 break;
//             case "PAYER_ACCOUNT_NOT_FOUND":
//             case 2:
//                 message.nodeTransactionPrecheckCode = 2;
//                 break;
//             case "INVALID_NODE_ACCOUNT":
//             case 3:
//                 message.nodeTransactionPrecheckCode = 3;
//                 break;
//             case "TRANSACTION_EXPIRED":
//             case 4:
//                 message.nodeTransactionPrecheckCode = 4;
//                 break;
//             case "INVALID_TRANSACTION_START":
//             case 5:
//                 message.nodeTransactionPrecheckCode = 5;
//                 break;
//             case "INVALID_TRANSACTION_DURATION":
//             case 6:
//                 message.nodeTransactionPrecheckCode = 6;
//                 break;
//             case "INVALID_SIGNATURE":
//             case 7:
//                 message.nodeTransactionPrecheckCode = 7;
//                 break;
//             case "MEMO_TOO_LONG":
//             case 8:
//                 message.nodeTransactionPrecheckCode = 8;
//                 break;
//             case "INSUFFICIENT_TX_FEE":
//             case 9:
//                 message.nodeTransactionPrecheckCode = 9;
//                 break;
//             case "INSUFFICIENT_PAYER_BALANCE":
//             case 10:
//                 message.nodeTransactionPrecheckCode = 10;
//                 break;
//             case "DUPLICATE_TRANSACTION":
//             case 11:
//                 message.nodeTransactionPrecheckCode = 11;
//                 break;
//             case "BUSY":
//             case 12:
//                 message.nodeTransactionPrecheckCode = 12;
//                 break;
//             case "NOT_SUPPORTED":
//             case 13:
//                 message.nodeTransactionPrecheckCode = 13;
//                 break;
//             case "INVALID_FILE_ID":
//             case 14:
//                 message.nodeTransactionPrecheckCode = 14;
//                 break;
//             case "INVALID_ACCOUNT_ID":
//             case 15:
//                 message.nodeTransactionPrecheckCode = 15;
//                 break;
//             case "INVALID_CONTRACT_ID":
//             case 16:
//                 message.nodeTransactionPrecheckCode = 16;
//                 break;
//             case "INVALID_TRANSACTION_ID":
//             case 17:
//                 message.nodeTransactionPrecheckCode = 17;
//                 break;
//             case "RECEIPT_NOT_FOUND":
//             case 18:
//                 message.nodeTransactionPrecheckCode = 18;
//                 break;
//             case "RECORD_NOT_FOUND":
//             case 19:
//                 message.nodeTransactionPrecheckCode = 19;
//                 break;
//             case "INVALID_SOLIDITY_ID":
//             case 20:
//                 message.nodeTransactionPrecheckCode = 20;
//                 break;
//             case "UNKNOWN":
//             case 21:
//                 message.nodeTransactionPrecheckCode = 21;
//                 break;
//             case "SUCCESS":
//             case 22:
//                 message.nodeTransactionPrecheckCode = 22;
//                 break;
//             case "FAIL_INVALID":
//             case 23:
//                 message.nodeTransactionPrecheckCode = 23;
//                 break;
//             case "FAIL_FEE":
//             case 24:
//                 message.nodeTransactionPrecheckCode = 24;
//                 break;
//             case "FAIL_BALANCE":
//             case 25:
//                 message.nodeTransactionPrecheckCode = 25;
//                 break;
//             case "KEY_REQUIRED":
//             case 26:
//                 message.nodeTransactionPrecheckCode = 26;
//                 break;
//             case "BAD_ENCODING":
//             case 27:
//                 message.nodeTransactionPrecheckCode = 27;
//                 break;
//             case "INSUFFICIENT_ACCOUNT_BALANCE":
//             case 28:
//                 message.nodeTransactionPrecheckCode = 28;
//                 break;
//             case "INVALID_SOLIDITY_ADDRESS":
//             case 29:
//                 message.nodeTransactionPrecheckCode = 29;
//                 break;
//             case "INSUFFICIENT_GAS":
//             case 30:
//                 message.nodeTransactionPrecheckCode = 30;
//                 break;
//             case "CONTRACT_SIZE_LIMIT_EXCEEDED":
//             case 31:
//                 message.nodeTransactionPrecheckCode = 31;
//                 break;
//             case "LOCAL_CALL_MODIFICATION_EXCEPTION":
//             case 32:
//                 message.nodeTransactionPrecheckCode = 32;
//                 break;
//             case "CONTRACT_REVERT_EXECUTED":
//             case 33:
//                 message.nodeTransactionPrecheckCode = 33;
//                 break;
//             case "CONTRACT_EXECUTION_EXCEPTION":
//             case 34:
//                 message.nodeTransactionPrecheckCode = 34;
//                 break;
//             case "INVALID_RECEIVING_NODE_ACCOUNT":
//             case 35:
//                 message.nodeTransactionPrecheckCode = 35;
//                 break;
//             case "MISSING_QUERY_HEADER":
//             case 36:
//                 message.nodeTransactionPrecheckCode = 36;
//                 break;
//             case "ACCOUNT_UPDATE_FAILED":
//             case 37:
//                 message.nodeTransactionPrecheckCode = 37;
//                 break;
//             case "INVALID_KEY_ENCODING":
//             case 38:
//                 message.nodeTransactionPrecheckCode = 38;
//                 break;
//             case "NULL_SOLIDITY_ADDRESS":
//             case 39:
//                 message.nodeTransactionPrecheckCode = 39;
//                 break;
//             case "CONTRACT_UPDATE_FAILED":
//             case 40:
//                 message.nodeTransactionPrecheckCode = 40;
//                 break;
//             case "INVALID_QUERY_HEADER":
//             case 41:
//                 message.nodeTransactionPrecheckCode = 41;
//                 break;
//             case "INVALID_FEE_SUBMITTED":
//             case 42:
//                 message.nodeTransactionPrecheckCode = 42;
//                 break;
//             case "INVALID_PAYER_SIGNATURE":
//             case 43:
//                 message.nodeTransactionPrecheckCode = 43;
//                 break;
//             case "KEY_NOT_PROVIDED":
//             case 44:
//                 message.nodeTransactionPrecheckCode = 44;
//                 break;
//             case "INVALID_EXPIRATION_TIME":
//             case 45:
//                 message.nodeTransactionPrecheckCode = 45;
//                 break;
//             case "NO_WACL_KEY":
//             case 46:
//                 message.nodeTransactionPrecheckCode = 46;
//                 break;
//             case "FILE_CONTENT_EMPTY":
//             case 47:
//                 message.nodeTransactionPrecheckCode = 47;
//                 break;
//             case "INVALID_ACCOUNT_AMOUNTS":
//             case 48:
//                 message.nodeTransactionPrecheckCode = 48;
//                 break;
//             case "EMPTY_TRANSACTION_BODY":
//             case 49:
//                 message.nodeTransactionPrecheckCode = 49;
//                 break;
//             case "INVALID_TRANSACTION_BODY":
//             case 50:
//                 message.nodeTransactionPrecheckCode = 50;
//                 break;
//             case "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY":
//             case 51:
//                 message.nodeTransactionPrecheckCode = 51;
//                 break;
//             case "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY":
//             case 52:
//                 message.nodeTransactionPrecheckCode = 52;
//                 break;
//             case "EMPTY_LIVE_HASH_BODY":
//             case 53:
//                 message.nodeTransactionPrecheckCode = 53;
//                 break;
//             case "EMPTY_LIVE_HASH":
//             case 54:
//                 message.nodeTransactionPrecheckCode = 54;
//                 break;
//             case "EMPTY_LIVE_HASH_KEYS":
//             case 55:
//                 message.nodeTransactionPrecheckCode = 55;
//                 break;
//             case "INVALID_LIVE_HASH_SIZE":
//             case 56:
//                 message.nodeTransactionPrecheckCode = 56;
//                 break;
//             case "EMPTY_QUERY_BODY":
//             case 57:
//                 message.nodeTransactionPrecheckCode = 57;
//                 break;
//             case "EMPTY_LIVE_HASH_QUERY":
//             case 58:
//                 message.nodeTransactionPrecheckCode = 58;
//                 break;
//             case "LIVE_HASH_NOT_FOUND":
//             case 59:
//                 message.nodeTransactionPrecheckCode = 59;
//                 break;
//             case "ACCOUNT_ID_DOES_NOT_EXIST":
//             case 60:
//                 message.nodeTransactionPrecheckCode = 60;
//                 break;
//             case "LIVE_HASH_ALREADY_EXISTS":
//             case 61:
//                 message.nodeTransactionPrecheckCode = 61;
//                 break;
//             case "INVALID_FILE_WACL":
//             case 62:
//                 message.nodeTransactionPrecheckCode = 62;
//                 break;
//             case "SERIALIZATION_FAILED":
//             case 63:
//                 message.nodeTransactionPrecheckCode = 63;
//                 break;
//             case "TRANSACTION_OVERSIZE":
//             case 64:
//                 message.nodeTransactionPrecheckCode = 64;
//                 break;
//             case "TRANSACTION_TOO_MANY_LAYERS":
//             case 65:
//                 message.nodeTransactionPrecheckCode = 65;
//                 break;
//             case "CONTRACT_DELETED":
//             case 66:
//                 message.nodeTransactionPrecheckCode = 66;
//                 break;
//             case "PLATFORM_NOT_ACTIVE":
//             case 67:
//                 message.nodeTransactionPrecheckCode = 67;
//                 break;
//             case "KEY_PREFIX_MISMATCH":
//             case 68:
//                 message.nodeTransactionPrecheckCode = 68;
//                 break;
//             case "PLATFORM_TRANSACTION_NOT_CREATED":
//             case 69:
//                 message.nodeTransactionPrecheckCode = 69;
//                 break;
//             case "INVALID_RENEWAL_PERIOD":
//             case 70:
//                 message.nodeTransactionPrecheckCode = 70;
//                 break;
//             case "INVALID_PAYER_ACCOUNT_ID":
//             case 71:
//                 message.nodeTransactionPrecheckCode = 71;
//                 break;
//             case "ACCOUNT_DELETED":
//             case 72:
//                 message.nodeTransactionPrecheckCode = 72;
//                 break;
//             case "FILE_DELETED":
//             case 73:
//                 message.nodeTransactionPrecheckCode = 73;
//                 break;
//             case "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS":
//             case 74:
//                 message.nodeTransactionPrecheckCode = 74;
//                 break;
//             case "SETTING_NEGATIVE_ACCOUNT_BALANCE":
//             case 75:
//                 message.nodeTransactionPrecheckCode = 75;
//                 break;
//             case "OBTAINER_REQUIRED":
//             case 76:
//                 message.nodeTransactionPrecheckCode = 76;
//                 break;
//             case "OBTAINER_SAME_CONTRACT_ID":
//             case 77:
//                 message.nodeTransactionPrecheckCode = 77;
//                 break;
//             case "OBTAINER_DOES_NOT_EXIST":
//             case 78:
//                 message.nodeTransactionPrecheckCode = 78;
//                 break;
//             case "MODIFYING_IMMUTABLE_CONTRACT":
//             case 79:
//                 message.nodeTransactionPrecheckCode = 79;
//                 break;
//             case "FILE_SYSTEM_EXCEPTION":
//             case 80:
//                 message.nodeTransactionPrecheckCode = 80;
//                 break;
//             case "AUTORENEW_DURATION_NOT_IN_RANGE":
//             case 81:
//                 message.nodeTransactionPrecheckCode = 81;
//                 break;
//             case "ERROR_DECODING_BYTESTRING":
//             case 82:
//                 message.nodeTransactionPrecheckCode = 82;
//                 break;
//             case "CONTRACT_FILE_EMPTY":
//             case 83:
//                 message.nodeTransactionPrecheckCode = 83;
//                 break;
//             case "CONTRACT_BYTECODE_EMPTY":
//             case 84:
//                 message.nodeTransactionPrecheckCode = 84;
//                 break;
//             case "INVALID_INITIAL_BALANCE":
//             case 85:
//                 message.nodeTransactionPrecheckCode = 85;
//                 break;
//             case "INVALID_RECEIVE_RECORD_THRESHOLD":
//             case 86:
//                 message.nodeTransactionPrecheckCode = 86;
//                 break;
//             case "INVALID_SEND_RECORD_THRESHOLD":
//             case 87:
//                 message.nodeTransactionPrecheckCode = 87;
//                 break;
//             case "ACCOUNT_IS_NOT_GENESIS_ACCOUNT":
//             case 88:
//                 message.nodeTransactionPrecheckCode = 88;
//                 break;
//             case "PAYER_ACCOUNT_UNAUTHORIZED":
//             case 89:
//                 message.nodeTransactionPrecheckCode = 89;
//                 break;
//             case "INVALID_FREEZE_TRANSACTION_BODY":
//             case 90:
//                 message.nodeTransactionPrecheckCode = 90;
//                 break;
//             case "FREEZE_TRANSACTION_BODY_NOT_FOUND":
//             case 91:
//                 message.nodeTransactionPrecheckCode = 91;
//                 break;
//             case "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED":
//             case 92:
//                 message.nodeTransactionPrecheckCode = 92;
//                 break;
//             case "RESULT_SIZE_LIMIT_EXCEEDED":
//             case 93:
//                 message.nodeTransactionPrecheckCode = 93;
//                 break;
//             case "NOT_SPECIAL_ACCOUNT":
//             case 94:
//                 message.nodeTransactionPrecheckCode = 94;
//                 break;
//             case "CONTRACT_NEGATIVE_GAS":
//             case 95:
//                 message.nodeTransactionPrecheckCode = 95;
//                 break;
//             case "CONTRACT_NEGATIVE_VALUE":
//             case 96:
//                 message.nodeTransactionPrecheckCode = 96;
//                 break;
//             case "INVALID_FEE_FILE":
//             case 97:
//                 message.nodeTransactionPrecheckCode = 97;
//                 break;
//             case "INVALID_EXCHANGE_RATE_FILE":
//             case 98:
//                 message.nodeTransactionPrecheckCode = 98;
//                 break;
//             case "INSUFFICIENT_LOCAL_CALL_GAS":
//             case 99:
//                 message.nodeTransactionPrecheckCode = 99;
//                 break;
//             case "ENTITY_NOT_ALLOWED_TO_DELETE":
//             case 100:
//                 message.nodeTransactionPrecheckCode = 100;
//                 break;
//             case "AUTHORIZATION_FAILED":
//             case 101:
//                 message.nodeTransactionPrecheckCode = 101;
//                 break;
//             case "FILE_UPLOADED_PROTO_INVALID":
//             case 102:
//                 message.nodeTransactionPrecheckCode = 102;
//                 break;
//             case "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK":
//             case 103:
//                 message.nodeTransactionPrecheckCode = 103;
//                 break;
//             case "FEE_SCHEDULE_FILE_PART_UPLOADED":
//             case 104:
//                 message.nodeTransactionPrecheckCode = 104;
//                 break;
//             case "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED":
//             case 105:
//                 message.nodeTransactionPrecheckCode = 105;
//                 break;
//             case "MAX_CONTRACT_STORAGE_EXCEEDED":
//             case 106:
//                 message.nodeTransactionPrecheckCode = 106;
//                 break;
//             case "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT":
//             case 107:
//                 message.nodeTransactionPrecheckCode = 107;
//                 break;
//             case "TOTAL_LEDGER_BALANCE_INVALID":
//             case 108:
//                 message.nodeTransactionPrecheckCode = 108;
//                 break;
//             case "EXPIRATION_REDUCTION_NOT_ALLOWED":
//             case 110:
//                 message.nodeTransactionPrecheckCode = 110;
//                 break;
//             case "MAX_GAS_LIMIT_EXCEEDED":
//             case 111:
//                 message.nodeTransactionPrecheckCode = 111;
//                 break;
//             case "MAX_FILE_SIZE_EXCEEDED":
//             case 112:
//                 message.nodeTransactionPrecheckCode = 112;
//                 break;
//             case "INVALID_TOPIC_ID":
//             case 150:
//                 message.nodeTransactionPrecheckCode = 150;
//                 break;
//             case "INVALID_ADMIN_KEY":
//             case 155:
//                 message.nodeTransactionPrecheckCode = 155;
//                 break;
//             case "INVALID_SUBMIT_KEY":
//             case 156:
//                 message.nodeTransactionPrecheckCode = 156;
//                 break;
//             case "UNAUTHORIZED":
//             case 157:
//                 message.nodeTransactionPrecheckCode = 157;
//                 break;
//             case "INVALID_TOPIC_MESSAGE":
//             case 158:
//                 message.nodeTransactionPrecheckCode = 158;
//                 break;
//             case "INVALID_AUTORENEW_ACCOUNT":
//             case 159:
//                 message.nodeTransactionPrecheckCode = 159;
//                 break;
//             case "AUTORENEW_ACCOUNT_NOT_ALLOWED":
//             case 160:
//                 message.nodeTransactionPrecheckCode = 160;
//                 break;
//             case "TOPIC_EXPIRED":
//             case 162:
//                 message.nodeTransactionPrecheckCode = 162;
//                 break;
//             case "INVALID_CHUNK_NUMBER":
//             case 163:
//                 message.nodeTransactionPrecheckCode = 163;
//                 break;
//             case "INVALID_CHUNK_TRANSACTION_ID":
//             case 164:
//                 message.nodeTransactionPrecheckCode = 164;
//                 break;
//             }
//             switch (object.responseType) {
//             case "ANSWER_ONLY":
//             case 0:
//                 message.responseType = 0;
//                 break;
//             case "ANSWER_STATE_PROOF":
//             case 1:
//                 message.responseType = 1;
//                 break;
//             case "COST_ANSWER":
//             case 2:
//                 message.responseType = 2;
//                 break;
//             case "COST_ANSWER_STATE_PROOF":
//             case 3:
//                 message.responseType = 3;
//                 break;
//             }
//             if (object.cost != null)
//                 if ($util.Long)
//                     (message.cost = $util.Long.fromValue(object.cost)).unsigned = true;
//                 else if (typeof object.cost === "string")
//                     message.cost = parseInt(object.cost, 10);
//                 else if (typeof object.cost === "number")
//                     message.cost = object.cost;
//                 else if (typeof object.cost === "object")
//                     message.cost = new $util.LongBits(object.cost.low >>> 0, object.cost.high >>> 0).toNumber(true);
//             if (object.stateProof != null)
//                 if (typeof object.stateProof === "string")
//                     $util.base64.decode(object.stateProof, message.stateProof = $util.newBuffer($util.base64.length(object.stateProof)), 0);
//                 else if (object.stateProof.length)
//                     message.stateProof = object.stateProof;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ResponseHeader message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ResponseHeader
//          * @static
//          * @param {proto.ResponseHeader} message ResponseHeader
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ResponseHeader.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.nodeTransactionPrecheckCode = options.enums === String ? "OK" : 0;
//                 object.responseType = options.enums === String ? "ANSWER_ONLY" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.cost = options.longs === String ? "0" : 0;
//                 if (options.bytes === String)
//                     object.stateProof = "";
//                 else {
//                     object.stateProof = [];
//                     if (options.bytes !== Array)
//                         object.stateProof = $util.newBuffer(object.stateProof);
//                 }
//             }
//             if (message.nodeTransactionPrecheckCode != null && message.hasOwnProperty("nodeTransactionPrecheckCode"))
//                 object.nodeTransactionPrecheckCode = options.enums === String ? $root.proto.ResponseCodeEnum[message.nodeTransactionPrecheckCode] : message.nodeTransactionPrecheckCode;
//             if (message.responseType != null && message.hasOwnProperty("responseType"))
//                 object.responseType = options.enums === String ? $root.proto.ResponseType[message.responseType] : message.responseType;
//             if (message.cost != null && message.hasOwnProperty("cost"))
//                 if (typeof message.cost === "number")
//                     object.cost = options.longs === String ? String(message.cost) : message.cost;
//                 else
//                     object.cost = options.longs === String ? $util.Long.prototype.toString.call(message.cost) : options.longs === Number ? new $util.LongBits(message.cost.low >>> 0, message.cost.high >>> 0).toNumber(true) : message.cost;
//             if (message.stateProof != null && message.hasOwnProperty("stateProof"))
//                 object.stateProof = options.bytes === String ? $util.base64.encode(message.stateProof, 0, message.stateProof.length) : options.bytes === Array ? Array.prototype.slice.call(message.stateProof) : message.stateProof;
//             return object;
//         };
// 
//         /**
//          * Converts this ResponseHeader to JSON.
//          * @function toJSON
//          * @memberof proto.ResponseHeader
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ResponseHeader.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ResponseHeader;
//     })();
// 
//     proto.TransactionResponse = (function() {
// 
//         /**
//          * Properties of a TransactionResponse.
//          * @memberof proto
//          * @interface ITransactionResponse
//          * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] TransactionResponse nodeTransactionPrecheckCode
//          * @property {number|Long|null} [cost] TransactionResponse cost
//          */
// 
//         /**
//          * Constructs a new TransactionResponse.
//          * @memberof proto
//          * @classdesc Represents a TransactionResponse.
//          * @implements ITransactionResponse
//          * @constructor
//          * @param {proto.ITransactionResponse=} [properties] Properties to set
//          */
//         function TransactionResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionResponse nodeTransactionPrecheckCode.
//          * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
//          * @memberof proto.TransactionResponse
//          * @instance
//          */
//         TransactionResponse.prototype.nodeTransactionPrecheckCode = 0;
// 
//         /**
//          * TransactionResponse cost.
//          * @member {number|Long} cost
//          * @memberof proto.TransactionResponse
//          * @instance
//          */
//         TransactionResponse.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * Creates a new TransactionResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {proto.ITransactionResponse=} [properties] Properties to set
//          * @returns {proto.TransactionResponse} TransactionResponse instance
//          */
//         TransactionResponse.create = function create(properties) {
//             return new TransactionResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionResponse message. Does not implicitly {@link proto.TransactionResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {proto.ITransactionResponse} message TransactionResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(message, "nodeTransactionPrecheckCode"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nodeTransactionPrecheckCode);
//             if (message.cost != null && Object.hasOwnProperty.call(message, "cost"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.cost);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionResponse message, length delimited. Does not implicitly {@link proto.TransactionResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {proto.ITransactionResponse} message TransactionResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionResponse} TransactionResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.nodeTransactionPrecheckCode = reader.int32();
//                     break;
//                 case 2:
//                     message.cost = reader.uint64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionResponse} TransactionResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionResponse message.
//          * @function verify
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.nodeTransactionPrecheckCode != null && message.hasOwnProperty("nodeTransactionPrecheckCode"))
//                 switch (message.nodeTransactionPrecheckCode) {
//                 default:
//                     return "nodeTransactionPrecheckCode: enum value expected";
//                 case 0:
//                 case 1:
//                 case 2:
//                 case 3:
//                 case 4:
//                 case 5:
//                 case 6:
//                 case 7:
//                 case 8:
//                 case 9:
//                 case 10:
//                 case 11:
//                 case 12:
//                 case 13:
//                 case 14:
//                 case 15:
//                 case 16:
//                 case 17:
//                 case 18:
//                 case 19:
//                 case 20:
//                 case 21:
//                 case 22:
//                 case 23:
//                 case 24:
//                 case 25:
//                 case 26:
//                 case 27:
//                 case 28:
//                 case 29:
//                 case 30:
//                 case 31:
//                 case 32:
//                 case 33:
//                 case 34:
//                 case 35:
//                 case 36:
//                 case 37:
//                 case 38:
//                 case 39:
//                 case 40:
//                 case 41:
//                 case 42:
//                 case 43:
//                 case 44:
//                 case 45:
//                 case 46:
//                 case 47:
//                 case 48:
//                 case 49:
//                 case 50:
//                 case 51:
//                 case 52:
//                 case 53:
//                 case 54:
//                 case 55:
//                 case 56:
//                 case 57:
//                 case 58:
//                 case 59:
//                 case 60:
//                 case 61:
//                 case 62:
//                 case 63:
//                 case 64:
//                 case 65:
//                 case 66:
//                 case 67:
//                 case 68:
//                 case 69:
//                 case 70:
//                 case 71:
//                 case 72:
//                 case 73:
//                 case 74:
//                 case 75:
//                 case 76:
//                 case 77:
//                 case 78:
//                 case 79:
//                 case 80:
//                 case 81:
//                 case 82:
//                 case 83:
//                 case 84:
//                 case 85:
//                 case 86:
//                 case 87:
//                 case 88:
//                 case 89:
//                 case 90:
//                 case 91:
//                 case 92:
//                 case 93:
//                 case 94:
//                 case 95:
//                 case 96:
//                 case 97:
//                 case 98:
//                 case 99:
//                 case 100:
//                 case 101:
//                 case 102:
//                 case 103:
//                 case 104:
//                 case 105:
//                 case 106:
//                 case 107:
//                 case 108:
//                 case 110:
//                 case 111:
//                 case 112:
//                 case 150:
//                 case 155:
//                 case 156:
//                 case 157:
//                 case 158:
//                 case 159:
//                 case 160:
//                 case 162:
//                 case 163:
//                 case 164:
//                     break;
//                 }
//             if (message.cost != null && message.hasOwnProperty("cost"))
//                 if (!$util.isInteger(message.cost) && !(message.cost && $util.isInteger(message.cost.low) && $util.isInteger(message.cost.high)))
//                     return "cost: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionResponse} TransactionResponse
//          */
//         TransactionResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionResponse)
//                 return object;
//             let message = new $root.proto.TransactionResponse();
//             switch (object.nodeTransactionPrecheckCode) {
//             case "OK":
//             case 0:
//                 message.nodeTransactionPrecheckCode = 0;
//                 break;
//             case "INVALID_TRANSACTION":
//             case 1:
//                 message.nodeTransactionPrecheckCode = 1;
//                 break;
//             case "PAYER_ACCOUNT_NOT_FOUND":
//             case 2:
//                 message.nodeTransactionPrecheckCode = 2;
//                 break;
//             case "INVALID_NODE_ACCOUNT":
//             case 3:
//                 message.nodeTransactionPrecheckCode = 3;
//                 break;
//             case "TRANSACTION_EXPIRED":
//             case 4:
//                 message.nodeTransactionPrecheckCode = 4;
//                 break;
//             case "INVALID_TRANSACTION_START":
//             case 5:
//                 message.nodeTransactionPrecheckCode = 5;
//                 break;
//             case "INVALID_TRANSACTION_DURATION":
//             case 6:
//                 message.nodeTransactionPrecheckCode = 6;
//                 break;
//             case "INVALID_SIGNATURE":
//             case 7:
//                 message.nodeTransactionPrecheckCode = 7;
//                 break;
//             case "MEMO_TOO_LONG":
//             case 8:
//                 message.nodeTransactionPrecheckCode = 8;
//                 break;
//             case "INSUFFICIENT_TX_FEE":
//             case 9:
//                 message.nodeTransactionPrecheckCode = 9;
//                 break;
//             case "INSUFFICIENT_PAYER_BALANCE":
//             case 10:
//                 message.nodeTransactionPrecheckCode = 10;
//                 break;
//             case "DUPLICATE_TRANSACTION":
//             case 11:
//                 message.nodeTransactionPrecheckCode = 11;
//                 break;
//             case "BUSY":
//             case 12:
//                 message.nodeTransactionPrecheckCode = 12;
//                 break;
//             case "NOT_SUPPORTED":
//             case 13:
//                 message.nodeTransactionPrecheckCode = 13;
//                 break;
//             case "INVALID_FILE_ID":
//             case 14:
//                 message.nodeTransactionPrecheckCode = 14;
//                 break;
//             case "INVALID_ACCOUNT_ID":
//             case 15:
//                 message.nodeTransactionPrecheckCode = 15;
//                 break;
//             case "INVALID_CONTRACT_ID":
//             case 16:
//                 message.nodeTransactionPrecheckCode = 16;
//                 break;
//             case "INVALID_TRANSACTION_ID":
//             case 17:
//                 message.nodeTransactionPrecheckCode = 17;
//                 break;
//             case "RECEIPT_NOT_FOUND":
//             case 18:
//                 message.nodeTransactionPrecheckCode = 18;
//                 break;
//             case "RECORD_NOT_FOUND":
//             case 19:
//                 message.nodeTransactionPrecheckCode = 19;
//                 break;
//             case "INVALID_SOLIDITY_ID":
//             case 20:
//                 message.nodeTransactionPrecheckCode = 20;
//                 break;
//             case "UNKNOWN":
//             case 21:
//                 message.nodeTransactionPrecheckCode = 21;
//                 break;
//             case "SUCCESS":
//             case 22:
//                 message.nodeTransactionPrecheckCode = 22;
//                 break;
//             case "FAIL_INVALID":
//             case 23:
//                 message.nodeTransactionPrecheckCode = 23;
//                 break;
//             case "FAIL_FEE":
//             case 24:
//                 message.nodeTransactionPrecheckCode = 24;
//                 break;
//             case "FAIL_BALANCE":
//             case 25:
//                 message.nodeTransactionPrecheckCode = 25;
//                 break;
//             case "KEY_REQUIRED":
//             case 26:
//                 message.nodeTransactionPrecheckCode = 26;
//                 break;
//             case "BAD_ENCODING":
//             case 27:
//                 message.nodeTransactionPrecheckCode = 27;
//                 break;
//             case "INSUFFICIENT_ACCOUNT_BALANCE":
//             case 28:
//                 message.nodeTransactionPrecheckCode = 28;
//                 break;
//             case "INVALID_SOLIDITY_ADDRESS":
//             case 29:
//                 message.nodeTransactionPrecheckCode = 29;
//                 break;
//             case "INSUFFICIENT_GAS":
//             case 30:
//                 message.nodeTransactionPrecheckCode = 30;
//                 break;
//             case "CONTRACT_SIZE_LIMIT_EXCEEDED":
//             case 31:
//                 message.nodeTransactionPrecheckCode = 31;
//                 break;
//             case "LOCAL_CALL_MODIFICATION_EXCEPTION":
//             case 32:
//                 message.nodeTransactionPrecheckCode = 32;
//                 break;
//             case "CONTRACT_REVERT_EXECUTED":
//             case 33:
//                 message.nodeTransactionPrecheckCode = 33;
//                 break;
//             case "CONTRACT_EXECUTION_EXCEPTION":
//             case 34:
//                 message.nodeTransactionPrecheckCode = 34;
//                 break;
//             case "INVALID_RECEIVING_NODE_ACCOUNT":
//             case 35:
//                 message.nodeTransactionPrecheckCode = 35;
//                 break;
//             case "MISSING_QUERY_HEADER":
//             case 36:
//                 message.nodeTransactionPrecheckCode = 36;
//                 break;
//             case "ACCOUNT_UPDATE_FAILED":
//             case 37:
//                 message.nodeTransactionPrecheckCode = 37;
//                 break;
//             case "INVALID_KEY_ENCODING":
//             case 38:
//                 message.nodeTransactionPrecheckCode = 38;
//                 break;
//             case "NULL_SOLIDITY_ADDRESS":
//             case 39:
//                 message.nodeTransactionPrecheckCode = 39;
//                 break;
//             case "CONTRACT_UPDATE_FAILED":
//             case 40:
//                 message.nodeTransactionPrecheckCode = 40;
//                 break;
//             case "INVALID_QUERY_HEADER":
//             case 41:
//                 message.nodeTransactionPrecheckCode = 41;
//                 break;
//             case "INVALID_FEE_SUBMITTED":
//             case 42:
//                 message.nodeTransactionPrecheckCode = 42;
//                 break;
//             case "INVALID_PAYER_SIGNATURE":
//             case 43:
//                 message.nodeTransactionPrecheckCode = 43;
//                 break;
//             case "KEY_NOT_PROVIDED":
//             case 44:
//                 message.nodeTransactionPrecheckCode = 44;
//                 break;
//             case "INVALID_EXPIRATION_TIME":
//             case 45:
//                 message.nodeTransactionPrecheckCode = 45;
//                 break;
//             case "NO_WACL_KEY":
//             case 46:
//                 message.nodeTransactionPrecheckCode = 46;
//                 break;
//             case "FILE_CONTENT_EMPTY":
//             case 47:
//                 message.nodeTransactionPrecheckCode = 47;
//                 break;
//             case "INVALID_ACCOUNT_AMOUNTS":
//             case 48:
//                 message.nodeTransactionPrecheckCode = 48;
//                 break;
//             case "EMPTY_TRANSACTION_BODY":
//             case 49:
//                 message.nodeTransactionPrecheckCode = 49;
//                 break;
//             case "INVALID_TRANSACTION_BODY":
//             case 50:
//                 message.nodeTransactionPrecheckCode = 50;
//                 break;
//             case "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY":
//             case 51:
//                 message.nodeTransactionPrecheckCode = 51;
//                 break;
//             case "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY":
//             case 52:
//                 message.nodeTransactionPrecheckCode = 52;
//                 break;
//             case "EMPTY_LIVE_HASH_BODY":
//             case 53:
//                 message.nodeTransactionPrecheckCode = 53;
//                 break;
//             case "EMPTY_LIVE_HASH":
//             case 54:
//                 message.nodeTransactionPrecheckCode = 54;
//                 break;
//             case "EMPTY_LIVE_HASH_KEYS":
//             case 55:
//                 message.nodeTransactionPrecheckCode = 55;
//                 break;
//             case "INVALID_LIVE_HASH_SIZE":
//             case 56:
//                 message.nodeTransactionPrecheckCode = 56;
//                 break;
//             case "EMPTY_QUERY_BODY":
//             case 57:
//                 message.nodeTransactionPrecheckCode = 57;
//                 break;
//             case "EMPTY_LIVE_HASH_QUERY":
//             case 58:
//                 message.nodeTransactionPrecheckCode = 58;
//                 break;
//             case "LIVE_HASH_NOT_FOUND":
//             case 59:
//                 message.nodeTransactionPrecheckCode = 59;
//                 break;
//             case "ACCOUNT_ID_DOES_NOT_EXIST":
//             case 60:
//                 message.nodeTransactionPrecheckCode = 60;
//                 break;
//             case "LIVE_HASH_ALREADY_EXISTS":
//             case 61:
//                 message.nodeTransactionPrecheckCode = 61;
//                 break;
//             case "INVALID_FILE_WACL":
//             case 62:
//                 message.nodeTransactionPrecheckCode = 62;
//                 break;
//             case "SERIALIZATION_FAILED":
//             case 63:
//                 message.nodeTransactionPrecheckCode = 63;
//                 break;
//             case "TRANSACTION_OVERSIZE":
//             case 64:
//                 message.nodeTransactionPrecheckCode = 64;
//                 break;
//             case "TRANSACTION_TOO_MANY_LAYERS":
//             case 65:
//                 message.nodeTransactionPrecheckCode = 65;
//                 break;
//             case "CONTRACT_DELETED":
//             case 66:
//                 message.nodeTransactionPrecheckCode = 66;
//                 break;
//             case "PLATFORM_NOT_ACTIVE":
//             case 67:
//                 message.nodeTransactionPrecheckCode = 67;
//                 break;
//             case "KEY_PREFIX_MISMATCH":
//             case 68:
//                 message.nodeTransactionPrecheckCode = 68;
//                 break;
//             case "PLATFORM_TRANSACTION_NOT_CREATED":
//             case 69:
//                 message.nodeTransactionPrecheckCode = 69;
//                 break;
//             case "INVALID_RENEWAL_PERIOD":
//             case 70:
//                 message.nodeTransactionPrecheckCode = 70;
//                 break;
//             case "INVALID_PAYER_ACCOUNT_ID":
//             case 71:
//                 message.nodeTransactionPrecheckCode = 71;
//                 break;
//             case "ACCOUNT_DELETED":
//             case 72:
//                 message.nodeTransactionPrecheckCode = 72;
//                 break;
//             case "FILE_DELETED":
//             case 73:
//                 message.nodeTransactionPrecheckCode = 73;
//                 break;
//             case "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS":
//             case 74:
//                 message.nodeTransactionPrecheckCode = 74;
//                 break;
//             case "SETTING_NEGATIVE_ACCOUNT_BALANCE":
//             case 75:
//                 message.nodeTransactionPrecheckCode = 75;
//                 break;
//             case "OBTAINER_REQUIRED":
//             case 76:
//                 message.nodeTransactionPrecheckCode = 76;
//                 break;
//             case "OBTAINER_SAME_CONTRACT_ID":
//             case 77:
//                 message.nodeTransactionPrecheckCode = 77;
//                 break;
//             case "OBTAINER_DOES_NOT_EXIST":
//             case 78:
//                 message.nodeTransactionPrecheckCode = 78;
//                 break;
//             case "MODIFYING_IMMUTABLE_CONTRACT":
//             case 79:
//                 message.nodeTransactionPrecheckCode = 79;
//                 break;
//             case "FILE_SYSTEM_EXCEPTION":
//             case 80:
//                 message.nodeTransactionPrecheckCode = 80;
//                 break;
//             case "AUTORENEW_DURATION_NOT_IN_RANGE":
//             case 81:
//                 message.nodeTransactionPrecheckCode = 81;
//                 break;
//             case "ERROR_DECODING_BYTESTRING":
//             case 82:
//                 message.nodeTransactionPrecheckCode = 82;
//                 break;
//             case "CONTRACT_FILE_EMPTY":
//             case 83:
//                 message.nodeTransactionPrecheckCode = 83;
//                 break;
//             case "CONTRACT_BYTECODE_EMPTY":
//             case 84:
//                 message.nodeTransactionPrecheckCode = 84;
//                 break;
//             case "INVALID_INITIAL_BALANCE":
//             case 85:
//                 message.nodeTransactionPrecheckCode = 85;
//                 break;
//             case "INVALID_RECEIVE_RECORD_THRESHOLD":
//             case 86:
//                 message.nodeTransactionPrecheckCode = 86;
//                 break;
//             case "INVALID_SEND_RECORD_THRESHOLD":
//             case 87:
//                 message.nodeTransactionPrecheckCode = 87;
//                 break;
//             case "ACCOUNT_IS_NOT_GENESIS_ACCOUNT":
//             case 88:
//                 message.nodeTransactionPrecheckCode = 88;
//                 break;
//             case "PAYER_ACCOUNT_UNAUTHORIZED":
//             case 89:
//                 message.nodeTransactionPrecheckCode = 89;
//                 break;
//             case "INVALID_FREEZE_TRANSACTION_BODY":
//             case 90:
//                 message.nodeTransactionPrecheckCode = 90;
//                 break;
//             case "FREEZE_TRANSACTION_BODY_NOT_FOUND":
//             case 91:
//                 message.nodeTransactionPrecheckCode = 91;
//                 break;
//             case "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED":
//             case 92:
//                 message.nodeTransactionPrecheckCode = 92;
//                 break;
//             case "RESULT_SIZE_LIMIT_EXCEEDED":
//             case 93:
//                 message.nodeTransactionPrecheckCode = 93;
//                 break;
//             case "NOT_SPECIAL_ACCOUNT":
//             case 94:
//                 message.nodeTransactionPrecheckCode = 94;
//                 break;
//             case "CONTRACT_NEGATIVE_GAS":
//             case 95:
//                 message.nodeTransactionPrecheckCode = 95;
//                 break;
//             case "CONTRACT_NEGATIVE_VALUE":
//             case 96:
//                 message.nodeTransactionPrecheckCode = 96;
//                 break;
//             case "INVALID_FEE_FILE":
//             case 97:
//                 message.nodeTransactionPrecheckCode = 97;
//                 break;
//             case "INVALID_EXCHANGE_RATE_FILE":
//             case 98:
//                 message.nodeTransactionPrecheckCode = 98;
//                 break;
//             case "INSUFFICIENT_LOCAL_CALL_GAS":
//             case 99:
//                 message.nodeTransactionPrecheckCode = 99;
//                 break;
//             case "ENTITY_NOT_ALLOWED_TO_DELETE":
//             case 100:
//                 message.nodeTransactionPrecheckCode = 100;
//                 break;
//             case "AUTHORIZATION_FAILED":
//             case 101:
//                 message.nodeTransactionPrecheckCode = 101;
//                 break;
//             case "FILE_UPLOADED_PROTO_INVALID":
//             case 102:
//                 message.nodeTransactionPrecheckCode = 102;
//                 break;
//             case "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK":
//             case 103:
//                 message.nodeTransactionPrecheckCode = 103;
//                 break;
//             case "FEE_SCHEDULE_FILE_PART_UPLOADED":
//             case 104:
//                 message.nodeTransactionPrecheckCode = 104;
//                 break;
//             case "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED":
//             case 105:
//                 message.nodeTransactionPrecheckCode = 105;
//                 break;
//             case "MAX_CONTRACT_STORAGE_EXCEEDED":
//             case 106:
//                 message.nodeTransactionPrecheckCode = 106;
//                 break;
//             case "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT":
//             case 107:
//                 message.nodeTransactionPrecheckCode = 107;
//                 break;
//             case "TOTAL_LEDGER_BALANCE_INVALID":
//             case 108:
//                 message.nodeTransactionPrecheckCode = 108;
//                 break;
//             case "EXPIRATION_REDUCTION_NOT_ALLOWED":
//             case 110:
//                 message.nodeTransactionPrecheckCode = 110;
//                 break;
//             case "MAX_GAS_LIMIT_EXCEEDED":
//             case 111:
//                 message.nodeTransactionPrecheckCode = 111;
//                 break;
//             case "MAX_FILE_SIZE_EXCEEDED":
//             case 112:
//                 message.nodeTransactionPrecheckCode = 112;
//                 break;
//             case "INVALID_TOPIC_ID":
//             case 150:
//                 message.nodeTransactionPrecheckCode = 150;
//                 break;
//             case "INVALID_ADMIN_KEY":
//             case 155:
//                 message.nodeTransactionPrecheckCode = 155;
//                 break;
//             case "INVALID_SUBMIT_KEY":
//             case 156:
//                 message.nodeTransactionPrecheckCode = 156;
//                 break;
//             case "UNAUTHORIZED":
//             case 157:
//                 message.nodeTransactionPrecheckCode = 157;
//                 break;
//             case "INVALID_TOPIC_MESSAGE":
//             case 158:
//                 message.nodeTransactionPrecheckCode = 158;
//                 break;
//             case "INVALID_AUTORENEW_ACCOUNT":
//             case 159:
//                 message.nodeTransactionPrecheckCode = 159;
//                 break;
//             case "AUTORENEW_ACCOUNT_NOT_ALLOWED":
//             case 160:
//                 message.nodeTransactionPrecheckCode = 160;
//                 break;
//             case "TOPIC_EXPIRED":
//             case 162:
//                 message.nodeTransactionPrecheckCode = 162;
//                 break;
//             case "INVALID_CHUNK_NUMBER":
//             case 163:
//                 message.nodeTransactionPrecheckCode = 163;
//                 break;
//             case "INVALID_CHUNK_TRANSACTION_ID":
//             case 164:
//                 message.nodeTransactionPrecheckCode = 164;
//                 break;
//             }
//             if (object.cost != null)
//                 if ($util.Long)
//                     (message.cost = $util.Long.fromValue(object.cost)).unsigned = true;
//                 else if (typeof object.cost === "string")
//                     message.cost = parseInt(object.cost, 10);
//                 else if (typeof object.cost === "number")
//                     message.cost = object.cost;
//                 else if (typeof object.cost === "object")
//                     message.cost = new $util.LongBits(object.cost.low >>> 0, object.cost.high >>> 0).toNumber(true);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionResponse
//          * @static
//          * @param {proto.TransactionResponse} message TransactionResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.nodeTransactionPrecheckCode = options.enums === String ? "OK" : 0;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.cost = options.longs === String ? "0" : 0;
//             }
//             if (message.nodeTransactionPrecheckCode != null && message.hasOwnProperty("nodeTransactionPrecheckCode"))
//                 object.nodeTransactionPrecheckCode = options.enums === String ? $root.proto.ResponseCodeEnum[message.nodeTransactionPrecheckCode] : message.nodeTransactionPrecheckCode;
//             if (message.cost != null && message.hasOwnProperty("cost"))
//                 if (typeof message.cost === "number")
//                     object.cost = options.longs === String ? String(message.cost) : message.cost;
//                 else
//                     object.cost = options.longs === String ? $util.Long.prototype.toString.call(message.cost) : options.longs === Number ? new $util.LongBits(message.cost.low >>> 0, message.cost.high >>> 0).toNumber(true) : message.cost;
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionResponse to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionResponse;
//     })();
// 
//     /**
//      * ResponseCodeEnum enum.
//      * @name proto.ResponseCodeEnum
//      * @enum {number}
//      * @property {number} OK=0 OK value
//      * @property {number} INVALID_TRANSACTION=1 INVALID_TRANSACTION value
//      * @property {number} PAYER_ACCOUNT_NOT_FOUND=2 PAYER_ACCOUNT_NOT_FOUND value
//      * @property {number} INVALID_NODE_ACCOUNT=3 INVALID_NODE_ACCOUNT value
//      * @property {number} TRANSACTION_EXPIRED=4 TRANSACTION_EXPIRED value
//      * @property {number} INVALID_TRANSACTION_START=5 INVALID_TRANSACTION_START value
//      * @property {number} INVALID_TRANSACTION_DURATION=6 INVALID_TRANSACTION_DURATION value
//      * @property {number} INVALID_SIGNATURE=7 INVALID_SIGNATURE value
//      * @property {number} MEMO_TOO_LONG=8 MEMO_TOO_LONG value
//      * @property {number} INSUFFICIENT_TX_FEE=9 INSUFFICIENT_TX_FEE value
//      * @property {number} INSUFFICIENT_PAYER_BALANCE=10 INSUFFICIENT_PAYER_BALANCE value
//      * @property {number} DUPLICATE_TRANSACTION=11 DUPLICATE_TRANSACTION value
//      * @property {number} BUSY=12 BUSY value
//      * @property {number} NOT_SUPPORTED=13 NOT_SUPPORTED value
//      * @property {number} INVALID_FILE_ID=14 INVALID_FILE_ID value
//      * @property {number} INVALID_ACCOUNT_ID=15 INVALID_ACCOUNT_ID value
//      * @property {number} INVALID_CONTRACT_ID=16 INVALID_CONTRACT_ID value
//      * @property {number} INVALID_TRANSACTION_ID=17 INVALID_TRANSACTION_ID value
//      * @property {number} RECEIPT_NOT_FOUND=18 RECEIPT_NOT_FOUND value
//      * @property {number} RECORD_NOT_FOUND=19 RECORD_NOT_FOUND value
//      * @property {number} INVALID_SOLIDITY_ID=20 INVALID_SOLIDITY_ID value
//      * @property {number} UNKNOWN=21 UNKNOWN value
//      * @property {number} SUCCESS=22 SUCCESS value
//      * @property {number} FAIL_INVALID=23 FAIL_INVALID value
//      * @property {number} FAIL_FEE=24 FAIL_FEE value
//      * @property {number} FAIL_BALANCE=25 FAIL_BALANCE value
//      * @property {number} KEY_REQUIRED=26 KEY_REQUIRED value
//      * @property {number} BAD_ENCODING=27 BAD_ENCODING value
//      * @property {number} INSUFFICIENT_ACCOUNT_BALANCE=28 INSUFFICIENT_ACCOUNT_BALANCE value
//      * @property {number} INVALID_SOLIDITY_ADDRESS=29 INVALID_SOLIDITY_ADDRESS value
//      * @property {number} INSUFFICIENT_GAS=30 INSUFFICIENT_GAS value
//      * @property {number} CONTRACT_SIZE_LIMIT_EXCEEDED=31 CONTRACT_SIZE_LIMIT_EXCEEDED value
//      * @property {number} LOCAL_CALL_MODIFICATION_EXCEPTION=32 LOCAL_CALL_MODIFICATION_EXCEPTION value
//      * @property {number} CONTRACT_REVERT_EXECUTED=33 CONTRACT_REVERT_EXECUTED value
//      * @property {number} CONTRACT_EXECUTION_EXCEPTION=34 CONTRACT_EXECUTION_EXCEPTION value
//      * @property {number} INVALID_RECEIVING_NODE_ACCOUNT=35 INVALID_RECEIVING_NODE_ACCOUNT value
//      * @property {number} MISSING_QUERY_HEADER=36 MISSING_QUERY_HEADER value
//      * @property {number} ACCOUNT_UPDATE_FAILED=37 ACCOUNT_UPDATE_FAILED value
//      * @property {number} INVALID_KEY_ENCODING=38 INVALID_KEY_ENCODING value
//      * @property {number} NULL_SOLIDITY_ADDRESS=39 NULL_SOLIDITY_ADDRESS value
//      * @property {number} CONTRACT_UPDATE_FAILED=40 CONTRACT_UPDATE_FAILED value
//      * @property {number} INVALID_QUERY_HEADER=41 INVALID_QUERY_HEADER value
//      * @property {number} INVALID_FEE_SUBMITTED=42 INVALID_FEE_SUBMITTED value
//      * @property {number} INVALID_PAYER_SIGNATURE=43 INVALID_PAYER_SIGNATURE value
//      * @property {number} KEY_NOT_PROVIDED=44 KEY_NOT_PROVIDED value
//      * @property {number} INVALID_EXPIRATION_TIME=45 INVALID_EXPIRATION_TIME value
//      * @property {number} NO_WACL_KEY=46 NO_WACL_KEY value
//      * @property {number} FILE_CONTENT_EMPTY=47 FILE_CONTENT_EMPTY value
//      * @property {number} INVALID_ACCOUNT_AMOUNTS=48 INVALID_ACCOUNT_AMOUNTS value
//      * @property {number} EMPTY_TRANSACTION_BODY=49 EMPTY_TRANSACTION_BODY value
//      * @property {number} INVALID_TRANSACTION_BODY=50 INVALID_TRANSACTION_BODY value
//      * @property {number} INVALID_SIGNATURE_TYPE_MISMATCHING_KEY=51 INVALID_SIGNATURE_TYPE_MISMATCHING_KEY value
//      * @property {number} INVALID_SIGNATURE_COUNT_MISMATCHING_KEY=52 INVALID_SIGNATURE_COUNT_MISMATCHING_KEY value
//      * @property {number} EMPTY_LIVE_HASH_BODY=53 EMPTY_LIVE_HASH_BODY value
//      * @property {number} EMPTY_LIVE_HASH=54 EMPTY_LIVE_HASH value
//      * @property {number} EMPTY_LIVE_HASH_KEYS=55 EMPTY_LIVE_HASH_KEYS value
//      * @property {number} INVALID_LIVE_HASH_SIZE=56 INVALID_LIVE_HASH_SIZE value
//      * @property {number} EMPTY_QUERY_BODY=57 EMPTY_QUERY_BODY value
//      * @property {number} EMPTY_LIVE_HASH_QUERY=58 EMPTY_LIVE_HASH_QUERY value
//      * @property {number} LIVE_HASH_NOT_FOUND=59 LIVE_HASH_NOT_FOUND value
//      * @property {number} ACCOUNT_ID_DOES_NOT_EXIST=60 ACCOUNT_ID_DOES_NOT_EXIST value
//      * @property {number} LIVE_HASH_ALREADY_EXISTS=61 LIVE_HASH_ALREADY_EXISTS value
//      * @property {number} INVALID_FILE_WACL=62 INVALID_FILE_WACL value
//      * @property {number} SERIALIZATION_FAILED=63 SERIALIZATION_FAILED value
//      * @property {number} TRANSACTION_OVERSIZE=64 TRANSACTION_OVERSIZE value
//      * @property {number} TRANSACTION_TOO_MANY_LAYERS=65 TRANSACTION_TOO_MANY_LAYERS value
//      * @property {number} CONTRACT_DELETED=66 CONTRACT_DELETED value
//      * @property {number} PLATFORM_NOT_ACTIVE=67 PLATFORM_NOT_ACTIVE value
//      * @property {number} KEY_PREFIX_MISMATCH=68 KEY_PREFIX_MISMATCH value
//      * @property {number} PLATFORM_TRANSACTION_NOT_CREATED=69 PLATFORM_TRANSACTION_NOT_CREATED value
//      * @property {number} INVALID_RENEWAL_PERIOD=70 INVALID_RENEWAL_PERIOD value
//      * @property {number} INVALID_PAYER_ACCOUNT_ID=71 INVALID_PAYER_ACCOUNT_ID value
//      * @property {number} ACCOUNT_DELETED=72 ACCOUNT_DELETED value
//      * @property {number} FILE_DELETED=73 FILE_DELETED value
//      * @property {number} ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS=74 ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS value
//      * @property {number} SETTING_NEGATIVE_ACCOUNT_BALANCE=75 SETTING_NEGATIVE_ACCOUNT_BALANCE value
//      * @property {number} OBTAINER_REQUIRED=76 OBTAINER_REQUIRED value
//      * @property {number} OBTAINER_SAME_CONTRACT_ID=77 OBTAINER_SAME_CONTRACT_ID value
//      * @property {number} OBTAINER_DOES_NOT_EXIST=78 OBTAINER_DOES_NOT_EXIST value
//      * @property {number} MODIFYING_IMMUTABLE_CONTRACT=79 MODIFYING_IMMUTABLE_CONTRACT value
//      * @property {number} FILE_SYSTEM_EXCEPTION=80 FILE_SYSTEM_EXCEPTION value
//      * @property {number} AUTORENEW_DURATION_NOT_IN_RANGE=81 AUTORENEW_DURATION_NOT_IN_RANGE value
//      * @property {number} ERROR_DECODING_BYTESTRING=82 ERROR_DECODING_BYTESTRING value
//      * @property {number} CONTRACT_FILE_EMPTY=83 CONTRACT_FILE_EMPTY value
//      * @property {number} CONTRACT_BYTECODE_EMPTY=84 CONTRACT_BYTECODE_EMPTY value
//      * @property {number} INVALID_INITIAL_BALANCE=85 INVALID_INITIAL_BALANCE value
//      * @property {number} INVALID_RECEIVE_RECORD_THRESHOLD=86 INVALID_RECEIVE_RECORD_THRESHOLD value
//      * @property {number} INVALID_SEND_RECORD_THRESHOLD=87 INVALID_SEND_RECORD_THRESHOLD value
//      * @property {number} ACCOUNT_IS_NOT_GENESIS_ACCOUNT=88 ACCOUNT_IS_NOT_GENESIS_ACCOUNT value
//      * @property {number} PAYER_ACCOUNT_UNAUTHORIZED=89 PAYER_ACCOUNT_UNAUTHORIZED value
//      * @property {number} INVALID_FREEZE_TRANSACTION_BODY=90 INVALID_FREEZE_TRANSACTION_BODY value
//      * @property {number} FREEZE_TRANSACTION_BODY_NOT_FOUND=91 FREEZE_TRANSACTION_BODY_NOT_FOUND value
//      * @property {number} TRANSFER_LIST_SIZE_LIMIT_EXCEEDED=92 TRANSFER_LIST_SIZE_LIMIT_EXCEEDED value
//      * @property {number} RESULT_SIZE_LIMIT_EXCEEDED=93 RESULT_SIZE_LIMIT_EXCEEDED value
//      * @property {number} NOT_SPECIAL_ACCOUNT=94 NOT_SPECIAL_ACCOUNT value
//      * @property {number} CONTRACT_NEGATIVE_GAS=95 CONTRACT_NEGATIVE_GAS value
//      * @property {number} CONTRACT_NEGATIVE_VALUE=96 CONTRACT_NEGATIVE_VALUE value
//      * @property {number} INVALID_FEE_FILE=97 INVALID_FEE_FILE value
//      * @property {number} INVALID_EXCHANGE_RATE_FILE=98 INVALID_EXCHANGE_RATE_FILE value
//      * @property {number} INSUFFICIENT_LOCAL_CALL_GAS=99 INSUFFICIENT_LOCAL_CALL_GAS value
//      * @property {number} ENTITY_NOT_ALLOWED_TO_DELETE=100 ENTITY_NOT_ALLOWED_TO_DELETE value
//      * @property {number} AUTHORIZATION_FAILED=101 AUTHORIZATION_FAILED value
//      * @property {number} FILE_UPLOADED_PROTO_INVALID=102 FILE_UPLOADED_PROTO_INVALID value
//      * @property {number} FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK=103 FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK value
//      * @property {number} FEE_SCHEDULE_FILE_PART_UPLOADED=104 FEE_SCHEDULE_FILE_PART_UPLOADED value
//      * @property {number} EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED=105 EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED value
//      * @property {number} MAX_CONTRACT_STORAGE_EXCEEDED=106 MAX_CONTRACT_STORAGE_EXCEEDED value
//      * @property {number} TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT=107 TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT value
//      * @property {number} TOTAL_LEDGER_BALANCE_INVALID=108 TOTAL_LEDGER_BALANCE_INVALID value
//      * @property {number} EXPIRATION_REDUCTION_NOT_ALLOWED=110 EXPIRATION_REDUCTION_NOT_ALLOWED value
//      * @property {number} MAX_GAS_LIMIT_EXCEEDED=111 MAX_GAS_LIMIT_EXCEEDED value
//      * @property {number} MAX_FILE_SIZE_EXCEEDED=112 MAX_FILE_SIZE_EXCEEDED value
//      * @property {number} INVALID_TOPIC_ID=150 INVALID_TOPIC_ID value
//      * @property {number} INVALID_ADMIN_KEY=155 INVALID_ADMIN_KEY value
//      * @property {number} INVALID_SUBMIT_KEY=156 INVALID_SUBMIT_KEY value
//      * @property {number} UNAUTHORIZED=157 UNAUTHORIZED value
//      * @property {number} INVALID_TOPIC_MESSAGE=158 INVALID_TOPIC_MESSAGE value
//      * @property {number} INVALID_AUTORENEW_ACCOUNT=159 INVALID_AUTORENEW_ACCOUNT value
//      * @property {number} AUTORENEW_ACCOUNT_NOT_ALLOWED=160 AUTORENEW_ACCOUNT_NOT_ALLOWED value
//      * @property {number} TOPIC_EXPIRED=162 TOPIC_EXPIRED value
//      * @property {number} INVALID_CHUNK_NUMBER=163 INVALID_CHUNK_NUMBER value
//      * @property {number} INVALID_CHUNK_TRANSACTION_ID=164 INVALID_CHUNK_TRANSACTION_ID value
//      */
//     proto.ResponseCodeEnum = (function() {
//         const valuesById = {}, values = Object.create(valuesById);
//         values[valuesById[0] = "OK"] = 0;
//         values[valuesById[1] = "INVALID_TRANSACTION"] = 1;
//         values[valuesById[2] = "PAYER_ACCOUNT_NOT_FOUND"] = 2;
//         values[valuesById[3] = "INVALID_NODE_ACCOUNT"] = 3;
//         values[valuesById[4] = "TRANSACTION_EXPIRED"] = 4;
//         values[valuesById[5] = "INVALID_TRANSACTION_START"] = 5;
//         values[valuesById[6] = "INVALID_TRANSACTION_DURATION"] = 6;
//         values[valuesById[7] = "INVALID_SIGNATURE"] = 7;
//         values[valuesById[8] = "MEMO_TOO_LONG"] = 8;
//         values[valuesById[9] = "INSUFFICIENT_TX_FEE"] = 9;
//         values[valuesById[10] = "INSUFFICIENT_PAYER_BALANCE"] = 10;
//         values[valuesById[11] = "DUPLICATE_TRANSACTION"] = 11;
//         values[valuesById[12] = "BUSY"] = 12;
//         values[valuesById[13] = "NOT_SUPPORTED"] = 13;
//         values[valuesById[14] = "INVALID_FILE_ID"] = 14;
//         values[valuesById[15] = "INVALID_ACCOUNT_ID"] = 15;
//         values[valuesById[16] = "INVALID_CONTRACT_ID"] = 16;
//         values[valuesById[17] = "INVALID_TRANSACTION_ID"] = 17;
//         values[valuesById[18] = "RECEIPT_NOT_FOUND"] = 18;
//         values[valuesById[19] = "RECORD_NOT_FOUND"] = 19;
//         values[valuesById[20] = "INVALID_SOLIDITY_ID"] = 20;
//         values[valuesById[21] = "UNKNOWN"] = 21;
//         values[valuesById[22] = "SUCCESS"] = 22;
//         values[valuesById[23] = "FAIL_INVALID"] = 23;
//         values[valuesById[24] = "FAIL_FEE"] = 24;
//         values[valuesById[25] = "FAIL_BALANCE"] = 25;
//         values[valuesById[26] = "KEY_REQUIRED"] = 26;
//         values[valuesById[27] = "BAD_ENCODING"] = 27;
//         values[valuesById[28] = "INSUFFICIENT_ACCOUNT_BALANCE"] = 28;
//         values[valuesById[29] = "INVALID_SOLIDITY_ADDRESS"] = 29;
//         values[valuesById[30] = "INSUFFICIENT_GAS"] = 30;
//         values[valuesById[31] = "CONTRACT_SIZE_LIMIT_EXCEEDED"] = 31;
//         values[valuesById[32] = "LOCAL_CALL_MODIFICATION_EXCEPTION"] = 32;
//         values[valuesById[33] = "CONTRACT_REVERT_EXECUTED"] = 33;
//         values[valuesById[34] = "CONTRACT_EXECUTION_EXCEPTION"] = 34;
//         values[valuesById[35] = "INVALID_RECEIVING_NODE_ACCOUNT"] = 35;
//         values[valuesById[36] = "MISSING_QUERY_HEADER"] = 36;
//         values[valuesById[37] = "ACCOUNT_UPDATE_FAILED"] = 37;
//         values[valuesById[38] = "INVALID_KEY_ENCODING"] = 38;
//         values[valuesById[39] = "NULL_SOLIDITY_ADDRESS"] = 39;
//         values[valuesById[40] = "CONTRACT_UPDATE_FAILED"] = 40;
//         values[valuesById[41] = "INVALID_QUERY_HEADER"] = 41;
//         values[valuesById[42] = "INVALID_FEE_SUBMITTED"] = 42;
//         values[valuesById[43] = "INVALID_PAYER_SIGNATURE"] = 43;
//         values[valuesById[44] = "KEY_NOT_PROVIDED"] = 44;
//         values[valuesById[45] = "INVALID_EXPIRATION_TIME"] = 45;
//         values[valuesById[46] = "NO_WACL_KEY"] = 46;
//         values[valuesById[47] = "FILE_CONTENT_EMPTY"] = 47;
//         values[valuesById[48] = "INVALID_ACCOUNT_AMOUNTS"] = 48;
//         values[valuesById[49] = "EMPTY_TRANSACTION_BODY"] = 49;
//         values[valuesById[50] = "INVALID_TRANSACTION_BODY"] = 50;
//         values[valuesById[51] = "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"] = 51;
//         values[valuesById[52] = "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"] = 52;
//         values[valuesById[53] = "EMPTY_LIVE_HASH_BODY"] = 53;
//         values[valuesById[54] = "EMPTY_LIVE_HASH"] = 54;
//         values[valuesById[55] = "EMPTY_LIVE_HASH_KEYS"] = 55;
//         values[valuesById[56] = "INVALID_LIVE_HASH_SIZE"] = 56;
//         values[valuesById[57] = "EMPTY_QUERY_BODY"] = 57;
//         values[valuesById[58] = "EMPTY_LIVE_HASH_QUERY"] = 58;
//         values[valuesById[59] = "LIVE_HASH_NOT_FOUND"] = 59;
//         values[valuesById[60] = "ACCOUNT_ID_DOES_NOT_EXIST"] = 60;
//         values[valuesById[61] = "LIVE_HASH_ALREADY_EXISTS"] = 61;
//         values[valuesById[62] = "INVALID_FILE_WACL"] = 62;
//         values[valuesById[63] = "SERIALIZATION_FAILED"] = 63;
//         values[valuesById[64] = "TRANSACTION_OVERSIZE"] = 64;
//         values[valuesById[65] = "TRANSACTION_TOO_MANY_LAYERS"] = 65;
//         values[valuesById[66] = "CONTRACT_DELETED"] = 66;
//         values[valuesById[67] = "PLATFORM_NOT_ACTIVE"] = 67;
//         values[valuesById[68] = "KEY_PREFIX_MISMATCH"] = 68;
//         values[valuesById[69] = "PLATFORM_TRANSACTION_NOT_CREATED"] = 69;
//         values[valuesById[70] = "INVALID_RENEWAL_PERIOD"] = 70;
//         values[valuesById[71] = "INVALID_PAYER_ACCOUNT_ID"] = 71;
//         values[valuesById[72] = "ACCOUNT_DELETED"] = 72;
//         values[valuesById[73] = "FILE_DELETED"] = 73;
//         values[valuesById[74] = "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"] = 74;
//         values[valuesById[75] = "SETTING_NEGATIVE_ACCOUNT_BALANCE"] = 75;
//         values[valuesById[76] = "OBTAINER_REQUIRED"] = 76;
//         values[valuesById[77] = "OBTAINER_SAME_CONTRACT_ID"] = 77;
//         values[valuesById[78] = "OBTAINER_DOES_NOT_EXIST"] = 78;
//         values[valuesById[79] = "MODIFYING_IMMUTABLE_CONTRACT"] = 79;
//         values[valuesById[80] = "FILE_SYSTEM_EXCEPTION"] = 80;
//         values[valuesById[81] = "AUTORENEW_DURATION_NOT_IN_RANGE"] = 81;
//         values[valuesById[82] = "ERROR_DECODING_BYTESTRING"] = 82;
//         values[valuesById[83] = "CONTRACT_FILE_EMPTY"] = 83;
//         values[valuesById[84] = "CONTRACT_BYTECODE_EMPTY"] = 84;
//         values[valuesById[85] = "INVALID_INITIAL_BALANCE"] = 85;
//         values[valuesById[86] = "INVALID_RECEIVE_RECORD_THRESHOLD"] = 86;
//         values[valuesById[87] = "INVALID_SEND_RECORD_THRESHOLD"] = 87;
//         values[valuesById[88] = "ACCOUNT_IS_NOT_GENESIS_ACCOUNT"] = 88;
//         values[valuesById[89] = "PAYER_ACCOUNT_UNAUTHORIZED"] = 89;
//         values[valuesById[90] = "INVALID_FREEZE_TRANSACTION_BODY"] = 90;
//         values[valuesById[91] = "FREEZE_TRANSACTION_BODY_NOT_FOUND"] = 91;
//         values[valuesById[92] = "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 92;
//         values[valuesById[93] = "RESULT_SIZE_LIMIT_EXCEEDED"] = 93;
//         values[valuesById[94] = "NOT_SPECIAL_ACCOUNT"] = 94;
//         values[valuesById[95] = "CONTRACT_NEGATIVE_GAS"] = 95;
//         values[valuesById[96] = "CONTRACT_NEGATIVE_VALUE"] = 96;
//         values[valuesById[97] = "INVALID_FEE_FILE"] = 97;
//         values[valuesById[98] = "INVALID_EXCHANGE_RATE_FILE"] = 98;
//         values[valuesById[99] = "INSUFFICIENT_LOCAL_CALL_GAS"] = 99;
//         values[valuesById[100] = "ENTITY_NOT_ALLOWED_TO_DELETE"] = 100;
//         values[valuesById[101] = "AUTHORIZATION_FAILED"] = 101;
//         values[valuesById[102] = "FILE_UPLOADED_PROTO_INVALID"] = 102;
//         values[valuesById[103] = "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"] = 103;
//         values[valuesById[104] = "FEE_SCHEDULE_FILE_PART_UPLOADED"] = 104;
//         values[valuesById[105] = "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"] = 105;
//         values[valuesById[106] = "MAX_CONTRACT_STORAGE_EXCEEDED"] = 106;
//         values[valuesById[107] = "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"] = 107;
//         values[valuesById[108] = "TOTAL_LEDGER_BALANCE_INVALID"] = 108;
//         values[valuesById[110] = "EXPIRATION_REDUCTION_NOT_ALLOWED"] = 110;
//         values[valuesById[111] = "MAX_GAS_LIMIT_EXCEEDED"] = 111;
//         values[valuesById[112] = "MAX_FILE_SIZE_EXCEEDED"] = 112;
//         values[valuesById[150] = "INVALID_TOPIC_ID"] = 150;
//         values[valuesById[155] = "INVALID_ADMIN_KEY"] = 155;
//         values[valuesById[156] = "INVALID_SUBMIT_KEY"] = 156;
//         values[valuesById[157] = "UNAUTHORIZED"] = 157;
//         values[valuesById[158] = "INVALID_TOPIC_MESSAGE"] = 158;
//         values[valuesById[159] = "INVALID_AUTORENEW_ACCOUNT"] = 159;
//         values[valuesById[160] = "AUTORENEW_ACCOUNT_NOT_ALLOWED"] = 160;
//         values[valuesById[162] = "TOPIC_EXPIRED"] = 162;
//         values[valuesById[163] = "INVALID_CHUNK_NUMBER"] = 163;
//         values[valuesById[164] = "INVALID_CHUNK_TRANSACTION_ID"] = 164;
//         return values;
//     })();
// 
//     proto.ConsensusTopicInfo = (function() {
// 
//         /**
//          * Properties of a ConsensusTopicInfo.
//          * @memberof proto
//          * @interface IConsensusTopicInfo
//          * @property {string|null} [memo] ConsensusTopicInfo memo
//          * @property {Uint8Array|null} [runningHash] ConsensusTopicInfo runningHash
//          * @property {number|Long|null} [sequenceNumber] ConsensusTopicInfo sequenceNumber
//          * @property {proto.ITimestamp|null} [expirationTime] ConsensusTopicInfo expirationTime
//          * @property {proto.IKey|null} [adminKey] ConsensusTopicInfo adminKey
//          * @property {proto.IKey|null} [submitKey] ConsensusTopicInfo submitKey
//          * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusTopicInfo autoRenewPeriod
//          * @property {proto.IAccountID|null} [autoRenewAccount] ConsensusTopicInfo autoRenewAccount
//          */
// 
//         /**
//          * Constructs a new ConsensusTopicInfo.
//          * @memberof proto
//          * @classdesc Represents a ConsensusTopicInfo.
//          * @implements IConsensusTopicInfo
//          * @constructor
//          * @param {proto.IConsensusTopicInfo=} [properties] Properties to set
//          */
//         function ConsensusTopicInfo(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ConsensusTopicInfo memo.
//          * @member {string} memo
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.memo = "";
// 
//         /**
//          * ConsensusTopicInfo runningHash.
//          * @member {Uint8Array} runningHash
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.runningHash = $util.newBuffer([]);
// 
//         /**
//          * ConsensusTopicInfo sequenceNumber.
//          * @member {number|Long} sequenceNumber
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * ConsensusTopicInfo expirationTime.
//          * @member {proto.ITimestamp|null|undefined} expirationTime
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.expirationTime = null;
// 
//         /**
//          * ConsensusTopicInfo adminKey.
//          * @member {proto.IKey|null|undefined} adminKey
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.adminKey = null;
// 
//         /**
//          * ConsensusTopicInfo submitKey.
//          * @member {proto.IKey|null|undefined} submitKey
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.submitKey = null;
// 
//         /**
//          * ConsensusTopicInfo autoRenewPeriod.
//          * @member {proto.IDuration|null|undefined} autoRenewPeriod
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.autoRenewPeriod = null;
// 
//         /**
//          * ConsensusTopicInfo autoRenewAccount.
//          * @member {proto.IAccountID|null|undefined} autoRenewAccount
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          */
//         ConsensusTopicInfo.prototype.autoRenewAccount = null;
// 
//         /**
//          * Creates a new ConsensusTopicInfo instance using the specified properties.
//          * @function create
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {proto.IConsensusTopicInfo=} [properties] Properties to set
//          * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo instance
//          */
//         ConsensusTopicInfo.create = function create(properties) {
//             return new ConsensusTopicInfo(properties);
//         };
// 
//         /**
//          * Encodes the specified ConsensusTopicInfo message. Does not implicitly {@link proto.ConsensusTopicInfo.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {proto.IConsensusTopicInfo} message ConsensusTopicInfo message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusTopicInfo.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 writer.uint32(/* id 1, wireType 2 =*/10).string(message.memo);
//             if (message.runningHash != null && Object.hasOwnProperty.call(message, "runningHash"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.runningHash);
//             if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sequenceNumber);
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.adminKey != null && Object.hasOwnProperty.call(message, "adminKey"))
//                 $root.proto.Key.encode(message.adminKey, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             if (message.submitKey != null && Object.hasOwnProperty.call(message, "submitKey"))
//                 $root.proto.Key.encode(message.submitKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                 $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             if (message.autoRenewAccount != null && Object.hasOwnProperty.call(message, "autoRenewAccount"))
//                 $root.proto.AccountID.encode(message.autoRenewAccount, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ConsensusTopicInfo message, length delimited. Does not implicitly {@link proto.ConsensusTopicInfo.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {proto.IConsensusTopicInfo} message ConsensusTopicInfo message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ConsensusTopicInfo.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ConsensusTopicInfo message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusTopicInfo.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConsensusTopicInfo();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.memo = reader.string();
//                     break;
//                 case 2:
//                     message.runningHash = reader.bytes();
//                     break;
//                 case 3:
//                     message.sequenceNumber = reader.uint64();
//                     break;
//                 case 4:
//                     message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.adminKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.submitKey = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.autoRenewAccount = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ConsensusTopicInfo message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ConsensusTopicInfo.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ConsensusTopicInfo message.
//          * @function verify
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ConsensusTopicInfo.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 if (!$util.isString(message.memo))
//                     return "memo: string expected";
//             if (message.runningHash != null && message.hasOwnProperty("runningHash"))
//                 if (!(message.runningHash && typeof message.runningHash.length === "number" || $util.isString(message.runningHash)))
//                     return "runningHash: buffer expected";
//             if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
//                 if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
//                     return "sequenceNumber: integer|Long expected";
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.Timestamp.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             if (message.adminKey != null && message.hasOwnProperty("adminKey")) {
//                 let error = $root.proto.Key.verify(message.adminKey);
//                 if (error)
//                     return "adminKey." + error;
//             }
//             if (message.submitKey != null && message.hasOwnProperty("submitKey")) {
//                 let error = $root.proto.Key.verify(message.submitKey);
//                 if (error)
//                     return "submitKey." + error;
//             }
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                 let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                 if (error)
//                     return "autoRenewPeriod." + error;
//             }
//             if (message.autoRenewAccount != null && message.hasOwnProperty("autoRenewAccount")) {
//                 let error = $root.proto.AccountID.verify(message.autoRenewAccount);
//                 if (error)
//                     return "autoRenewAccount." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ConsensusTopicInfo message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo
//          */
//         ConsensusTopicInfo.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ConsensusTopicInfo)
//                 return object;
//             let message = new $root.proto.ConsensusTopicInfo();
//             if (object.memo != null)
//                 message.memo = String(object.memo);
//             if (object.runningHash != null)
//                 if (typeof object.runningHash === "string")
//                     $util.base64.decode(object.runningHash, message.runningHash = $util.newBuffer($util.base64.length(object.runningHash)), 0);
//                 else if (object.runningHash.length)
//                     message.runningHash = object.runningHash;
//             if (object.sequenceNumber != null)
//                 if ($util.Long)
//                     (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = true;
//                 else if (typeof object.sequenceNumber === "string")
//                     message.sequenceNumber = parseInt(object.sequenceNumber, 10);
//                 else if (typeof object.sequenceNumber === "number")
//                     message.sequenceNumber = object.sequenceNumber;
//                 else if (typeof object.sequenceNumber === "object")
//                     message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber(true);
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.ConsensusTopicInfo.expirationTime: object expected");
//                 message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//             }
//             if (object.adminKey != null) {
//                 if (typeof object.adminKey !== "object")
//                     throw TypeError(".proto.ConsensusTopicInfo.adminKey: object expected");
//                 message.adminKey = $root.proto.Key.fromObject(object.adminKey);
//             }
//             if (object.submitKey != null) {
//                 if (typeof object.submitKey !== "object")
//                     throw TypeError(".proto.ConsensusTopicInfo.submitKey: object expected");
//                 message.submitKey = $root.proto.Key.fromObject(object.submitKey);
//             }
//             if (object.autoRenewPeriod != null) {
//                 if (typeof object.autoRenewPeriod !== "object")
//                     throw TypeError(".proto.ConsensusTopicInfo.autoRenewPeriod: object expected");
//                 message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//             }
//             if (object.autoRenewAccount != null) {
//                 if (typeof object.autoRenewAccount !== "object")
//                     throw TypeError(".proto.ConsensusTopicInfo.autoRenewAccount: object expected");
//                 message.autoRenewAccount = $root.proto.AccountID.fromObject(object.autoRenewAccount);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ConsensusTopicInfo message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ConsensusTopicInfo
//          * @static
//          * @param {proto.ConsensusTopicInfo} message ConsensusTopicInfo
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ConsensusTopicInfo.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.memo = "";
//                 if (options.bytes === String)
//                     object.runningHash = "";
//                 else {
//                     object.runningHash = [];
//                     if (options.bytes !== Array)
//                         object.runningHash = $util.newBuffer(object.runningHash);
//                 }
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.sequenceNumber = options.longs === String ? "0" : 0;
//                 object.expirationTime = null;
//                 object.adminKey = null;
//                 object.submitKey = null;
//                 object.autoRenewPeriod = null;
//                 object.autoRenewAccount = null;
//             }
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = message.memo;
//             if (message.runningHash != null && message.hasOwnProperty("runningHash"))
//                 object.runningHash = options.bytes === String ? $util.base64.encode(message.runningHash, 0, message.runningHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.runningHash) : message.runningHash;
//             if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
//                 if (typeof message.sequenceNumber === "number")
//                     object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
//                 else
//                     object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber(true) : message.sequenceNumber;
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//             if (message.adminKey != null && message.hasOwnProperty("adminKey"))
//                 object.adminKey = $root.proto.Key.toObject(message.adminKey, options);
//             if (message.submitKey != null && message.hasOwnProperty("submitKey"))
//                 object.submitKey = $root.proto.Key.toObject(message.submitKey, options);
//             if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                 object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//             if (message.autoRenewAccount != null && message.hasOwnProperty("autoRenewAccount"))
//                 object.autoRenewAccount = $root.proto.AccountID.toObject(message.autoRenewAccount, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ConsensusTopicInfo to JSON.
//          * @function toJSON
//          * @memberof proto.ConsensusTopicInfo
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ConsensusTopicInfo.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ConsensusTopicInfo;
//     })();
// 
//     proto.ConsensusService = (function() {
// 
//         /**
//          * Constructs a new ConsensusService service.
//          * @memberof proto
//          * @classdesc Represents a ConsensusService
//          * @extends $protobuf.rpc.Service
//          * @constructor
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          */
//         function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
//             $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
//         }
// 
//         (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConsensusService;
// 
//         /**
//          * Creates new ConsensusService service using the specified rpc implementation.
//          * @function create
//          * @memberof proto.ConsensusService
//          * @static
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          * @returns {ConsensusService} RPC service. Useful where requests and/or responses are streamed.
//          */
//         ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
//             return new this(rpcImpl, requestDelimited, responseDelimited);
//         };
// 
//         /**
//          * Callback as used by {@link proto.ConsensusService#createTopic}.
//          * @memberof proto.ConsensusService
//          * @typedef createTopicCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls createTopic.
//          * @function createTopic
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.ConsensusService.createTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(ConsensusService.prototype.createTopic = function createTopic(request, callback) {
//             return this.rpcCall(createTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "createTopic" });
// 
//         /**
//          * Calls createTopic.
//          * @function createTopic
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.ConsensusService#updateTopic}.
//          * @memberof proto.ConsensusService
//          * @typedef updateTopicCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls updateTopic.
//          * @function updateTopic
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.ConsensusService.updateTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(ConsensusService.prototype.updateTopic = function updateTopic(request, callback) {
//             return this.rpcCall(updateTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "updateTopic" });
// 
//         /**
//          * Calls updateTopic.
//          * @function updateTopic
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.ConsensusService#deleteTopic}.
//          * @memberof proto.ConsensusService
//          * @typedef deleteTopicCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls deleteTopic.
//          * @function deleteTopic
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.ConsensusService.deleteTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(ConsensusService.prototype.deleteTopic = function deleteTopic(request, callback) {
//             return this.rpcCall(deleteTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "deleteTopic" });
// 
//         /**
//          * Calls deleteTopic.
//          * @function deleteTopic
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.ConsensusService#getTopicInfo}.
//          * @memberof proto.ConsensusService
//          * @typedef getTopicInfoCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getTopicInfo.
//          * @function getTopicInfo
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.ConsensusService.getTopicInfoCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(ConsensusService.prototype.getTopicInfo = function getTopicInfo(request, callback) {
//             return this.rpcCall(getTopicInfo, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getTopicInfo" });
// 
//         /**
//          * Calls getTopicInfo.
//          * @function getTopicInfo
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.ConsensusService#submitMessage}.
//          * @memberof proto.ConsensusService
//          * @typedef submitMessageCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls submitMessage.
//          * @function submitMessage
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.ConsensusService.submitMessageCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(ConsensusService.prototype.submitMessage = function submitMessage(request, callback) {
//             return this.rpcCall(submitMessage, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "submitMessage" });
// 
//         /**
//          * Calls submitMessage.
//          * @function submitMessage
//          * @memberof proto.ConsensusService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         return ConsensusService;
//     })();
// 
//     proto.Query = (function() {
// 
//         /**
//          * Properties of a Query.
//          * @memberof proto
//          * @interface IQuery
//          * @property {proto.IGetByKeyQuery|null} [getByKey] Query getByKey
//          * @property {proto.IGetBySolidityIDQuery|null} [getBySolidityID] Query getBySolidityID
//          * @property {proto.IContractCallLocalQuery|null} [contractCallLocal] Query contractCallLocal
//          * @property {proto.IContractGetInfoQuery|null} [contractGetInfo] Query contractGetInfo
//          * @property {proto.IContractGetBytecodeQuery|null} [contractGetBytecode] Query contractGetBytecode
//          * @property {proto.IContractGetRecordsQuery|null} [ContractGetRecords] Query ContractGetRecords
//          * @property {proto.ICryptoGetAccountBalanceQuery|null} [cryptogetAccountBalance] Query cryptogetAccountBalance
//          * @property {proto.ICryptoGetAccountRecordsQuery|null} [cryptoGetAccountRecords] Query cryptoGetAccountRecords
//          * @property {proto.ICryptoGetInfoQuery|null} [cryptoGetInfo] Query cryptoGetInfo
//          * @property {proto.ICryptoGetLiveHashQuery|null} [cryptoGetLiveHash] Query cryptoGetLiveHash
//          * @property {proto.ICryptoGetStakersQuery|null} [cryptoGetProxyStakers] Query cryptoGetProxyStakers
//          * @property {proto.IFileGetContentsQuery|null} [fileGetContents] Query fileGetContents
//          * @property {proto.IFileGetInfoQuery|null} [fileGetInfo] Query fileGetInfo
//          * @property {proto.ITransactionGetReceiptQuery|null} [transactionGetReceipt] Query transactionGetReceipt
//          * @property {proto.ITransactionGetRecordQuery|null} [transactionGetRecord] Query transactionGetRecord
//          * @property {proto.ITransactionGetFastRecordQuery|null} [transactionGetFastRecord] Query transactionGetFastRecord
//          * @property {proto.IConsensusGetTopicInfoQuery|null} [consensusGetTopicInfo] Query consensusGetTopicInfo
//          * @property {proto.INetworkGetVersionInfoQuery|null} [networkGetVersionInfo] Query networkGetVersionInfo
//          */
// 
//         /**
//          * Constructs a new Query.
//          * @memberof proto
//          * @classdesc Represents a Query.
//          * @implements IQuery
//          * @constructor
//          * @param {proto.IQuery=} [properties] Properties to set
//          */
//         function Query(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Query getByKey.
//          * @member {proto.IGetByKeyQuery|null|undefined} getByKey
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.getByKey = null;
// 
//         /**
//          * Query getBySolidityID.
//          * @member {proto.IGetBySolidityIDQuery|null|undefined} getBySolidityID
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.getBySolidityID = null;
// 
//         /**
//          * Query contractCallLocal.
//          * @member {proto.IContractCallLocalQuery|null|undefined} contractCallLocal
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.contractCallLocal = null;
// 
//         /**
//          * Query contractGetInfo.
//          * @member {proto.IContractGetInfoQuery|null|undefined} contractGetInfo
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.contractGetInfo = null;
// 
//         /**
//          * Query contractGetBytecode.
//          * @member {proto.IContractGetBytecodeQuery|null|undefined} contractGetBytecode
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.contractGetBytecode = null;
// 
//         /**
//          * Query ContractGetRecords.
//          * @member {proto.IContractGetRecordsQuery|null|undefined} ContractGetRecords
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.ContractGetRecords = null;
// 
//         /**
//          * Query cryptogetAccountBalance.
//          * @member {proto.ICryptoGetAccountBalanceQuery|null|undefined} cryptogetAccountBalance
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.cryptogetAccountBalance = null;
// 
//         /**
//          * Query cryptoGetAccountRecords.
//          * @member {proto.ICryptoGetAccountRecordsQuery|null|undefined} cryptoGetAccountRecords
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.cryptoGetAccountRecords = null;
// 
//         /**
//          * Query cryptoGetInfo.
//          * @member {proto.ICryptoGetInfoQuery|null|undefined} cryptoGetInfo
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.cryptoGetInfo = null;
// 
//         /**
//          * Query cryptoGetLiveHash.
//          * @member {proto.ICryptoGetLiveHashQuery|null|undefined} cryptoGetLiveHash
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.cryptoGetLiveHash = null;
// 
//         /**
//          * Query cryptoGetProxyStakers.
//          * @member {proto.ICryptoGetStakersQuery|null|undefined} cryptoGetProxyStakers
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.cryptoGetProxyStakers = null;
// 
//         /**
//          * Query fileGetContents.
//          * @member {proto.IFileGetContentsQuery|null|undefined} fileGetContents
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.fileGetContents = null;
// 
//         /**
//          * Query fileGetInfo.
//          * @member {proto.IFileGetInfoQuery|null|undefined} fileGetInfo
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.fileGetInfo = null;
// 
//         /**
//          * Query transactionGetReceipt.
//          * @member {proto.ITransactionGetReceiptQuery|null|undefined} transactionGetReceipt
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.transactionGetReceipt = null;
// 
//         /**
//          * Query transactionGetRecord.
//          * @member {proto.ITransactionGetRecordQuery|null|undefined} transactionGetRecord
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.transactionGetRecord = null;
// 
//         /**
//          * Query transactionGetFastRecord.
//          * @member {proto.ITransactionGetFastRecordQuery|null|undefined} transactionGetFastRecord
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.transactionGetFastRecord = null;
// 
//         /**
//          * Query consensusGetTopicInfo.
//          * @member {proto.IConsensusGetTopicInfoQuery|null|undefined} consensusGetTopicInfo
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.consensusGetTopicInfo = null;
// 
//         /**
//          * Query networkGetVersionInfo.
//          * @member {proto.INetworkGetVersionInfoQuery|null|undefined} networkGetVersionInfo
//          * @memberof proto.Query
//          * @instance
//          */
//         Query.prototype.networkGetVersionInfo = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * Query query.
//          * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetInfo"|"contractGetBytecode"|"ContractGetRecords"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|undefined} query
//          * @memberof proto.Query
//          * @instance
//          */
//         Object.defineProperty(Query.prototype, "query", {
//             get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetInfo", "contractGetBytecode", "ContractGetRecords", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new Query instance using the specified properties.
//          * @function create
//          * @memberof proto.Query
//          * @static
//          * @param {proto.IQuery=} [properties] Properties to set
//          * @returns {proto.Query} Query instance
//          */
//         Query.create = function create(properties) {
//             return new Query(properties);
//         };
// 
//         /**
//          * Encodes the specified Query message. Does not implicitly {@link proto.Query.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Query
//          * @static
//          * @param {proto.IQuery} message Query message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Query.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.getByKey != null && Object.hasOwnProperty.call(message, "getByKey"))
//                 $root.proto.GetByKeyQuery.encode(message.getByKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.getBySolidityID != null && Object.hasOwnProperty.call(message, "getBySolidityID"))
//                 $root.proto.GetBySolidityIDQuery.encode(message.getBySolidityID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.contractCallLocal != null && Object.hasOwnProperty.call(message, "contractCallLocal"))
//                 $root.proto.ContractCallLocalQuery.encode(message.contractCallLocal, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.contractGetInfo != null && Object.hasOwnProperty.call(message, "contractGetInfo"))
//                 $root.proto.ContractGetInfoQuery.encode(message.contractGetInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.contractGetBytecode != null && Object.hasOwnProperty.call(message, "contractGetBytecode"))
//                 $root.proto.ContractGetBytecodeQuery.encode(message.contractGetBytecode, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             if (message.ContractGetRecords != null && Object.hasOwnProperty.call(message, "ContractGetRecords"))
//                 $root.proto.ContractGetRecordsQuery.encode(message.ContractGetRecords, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.cryptogetAccountBalance != null && Object.hasOwnProperty.call(message, "cryptogetAccountBalance"))
//                 $root.proto.CryptoGetAccountBalanceQuery.encode(message.cryptogetAccountBalance, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             if (message.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(message, "cryptoGetAccountRecords"))
//                 $root.proto.CryptoGetAccountRecordsQuery.encode(message.cryptoGetAccountRecords, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.cryptoGetInfo != null && Object.hasOwnProperty.call(message, "cryptoGetInfo"))
//                 $root.proto.CryptoGetInfoQuery.encode(message.cryptoGetInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
//             if (message.cryptoGetLiveHash != null && Object.hasOwnProperty.call(message, "cryptoGetLiveHash"))
//                 $root.proto.CryptoGetLiveHashQuery.encode(message.cryptoGetLiveHash, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
//             if (message.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(message, "cryptoGetProxyStakers"))
//                 $root.proto.CryptoGetStakersQuery.encode(message.cryptoGetProxyStakers, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
//             if (message.fileGetContents != null && Object.hasOwnProperty.call(message, "fileGetContents"))
//                 $root.proto.FileGetContentsQuery.encode(message.fileGetContents, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
//             if (message.fileGetInfo != null && Object.hasOwnProperty.call(message, "fileGetInfo"))
//                 $root.proto.FileGetInfoQuery.encode(message.fileGetInfo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
//             if (message.transactionGetReceipt != null && Object.hasOwnProperty.call(message, "transactionGetReceipt"))
//                 $root.proto.TransactionGetReceiptQuery.encode(message.transactionGetReceipt, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
//             if (message.transactionGetRecord != null && Object.hasOwnProperty.call(message, "transactionGetRecord"))
//                 $root.proto.TransactionGetRecordQuery.encode(message.transactionGetRecord, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
//             if (message.transactionGetFastRecord != null && Object.hasOwnProperty.call(message, "transactionGetFastRecord"))
//                 $root.proto.TransactionGetFastRecordQuery.encode(message.transactionGetFastRecord, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
//             if (message.consensusGetTopicInfo != null && Object.hasOwnProperty.call(message, "consensusGetTopicInfo"))
//                 $root.proto.ConsensusGetTopicInfoQuery.encode(message.consensusGetTopicInfo, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
//             if (message.networkGetVersionInfo != null && Object.hasOwnProperty.call(message, "networkGetVersionInfo"))
//                 $root.proto.NetworkGetVersionInfoQuery.encode(message.networkGetVersionInfo, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Query message, length delimited. Does not implicitly {@link proto.Query.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Query
//          * @static
//          * @param {proto.IQuery} message Query message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Query.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Query message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Query
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Query} Query
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Query.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Query();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.getByKey = $root.proto.GetByKeyQuery.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.getBySolidityID = $root.proto.GetBySolidityIDQuery.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.contractCallLocal = $root.proto.ContractCallLocalQuery.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contractGetInfo = $root.proto.ContractGetInfoQuery.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.ContractGetRecords = $root.proto.ContractGetRecordsQuery.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.decode(reader, reader.uint32());
//                     break;
//                 case 9:
//                     message.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.decode(reader, reader.uint32());
//                     break;
//                 case 10:
//                     message.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.decode(reader, reader.uint32());
//                     break;
//                 case 11:
//                     message.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.decode(reader, reader.uint32());
//                     break;
//                 case 12:
//                     message.fileGetContents = $root.proto.FileGetContentsQuery.decode(reader, reader.uint32());
//                     break;
//                 case 13:
//                     message.fileGetInfo = $root.proto.FileGetInfoQuery.decode(reader, reader.uint32());
//                     break;
//                 case 14:
//                     message.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.decode(reader, reader.uint32());
//                     break;
//                 case 15:
//                     message.transactionGetRecord = $root.proto.TransactionGetRecordQuery.decode(reader, reader.uint32());
//                     break;
//                 case 16:
//                     message.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.decode(reader, reader.uint32());
//                     break;
//                 case 50:
//                     message.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.decode(reader, reader.uint32());
//                     break;
//                 case 51:
//                     message.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Query message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Query
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Query} Query
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Query.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Query message.
//          * @function verify
//          * @memberof proto.Query
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Query.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.getByKey != null && message.hasOwnProperty("getByKey")) {
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.GetByKeyQuery.verify(message.getByKey);
//                     if (error)
//                         return "getByKey." + error;
//                 }
//             }
//             if (message.getBySolidityID != null && message.hasOwnProperty("getBySolidityID")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.GetBySolidityIDQuery.verify(message.getBySolidityID);
//                     if (error)
//                         return "getBySolidityID." + error;
//                 }
//             }
//             if (message.contractCallLocal != null && message.hasOwnProperty("contractCallLocal")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.ContractCallLocalQuery.verify(message.contractCallLocal);
//                     if (error)
//                         return "contractCallLocal." + error;
//                 }
//             }
//             if (message.contractGetInfo != null && message.hasOwnProperty("contractGetInfo")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.ContractGetInfoQuery.verify(message.contractGetInfo);
//                     if (error)
//                         return "contractGetInfo." + error;
//                 }
//             }
//             if (message.contractGetBytecode != null && message.hasOwnProperty("contractGetBytecode")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.ContractGetBytecodeQuery.verify(message.contractGetBytecode);
//                     if (error)
//                         return "contractGetBytecode." + error;
//                 }
//             }
//             if (message.ContractGetRecords != null && message.hasOwnProperty("ContractGetRecords")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.ContractGetRecordsQuery.verify(message.ContractGetRecords);
//                     if (error)
//                         return "ContractGetRecords." + error;
//                 }
//             }
//             if (message.cryptogetAccountBalance != null && message.hasOwnProperty("cryptogetAccountBalance")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.CryptoGetAccountBalanceQuery.verify(message.cryptogetAccountBalance);
//                     if (error)
//                         return "cryptogetAccountBalance." + error;
//                 }
//             }
//             if (message.cryptoGetAccountRecords != null && message.hasOwnProperty("cryptoGetAccountRecords")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.CryptoGetAccountRecordsQuery.verify(message.cryptoGetAccountRecords);
//                     if (error)
//                         return "cryptoGetAccountRecords." + error;
//                 }
//             }
//             if (message.cryptoGetInfo != null && message.hasOwnProperty("cryptoGetInfo")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.CryptoGetInfoQuery.verify(message.cryptoGetInfo);
//                     if (error)
//                         return "cryptoGetInfo." + error;
//                 }
//             }
//             if (message.cryptoGetLiveHash != null && message.hasOwnProperty("cryptoGetLiveHash")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.CryptoGetLiveHashQuery.verify(message.cryptoGetLiveHash);
//                     if (error)
//                         return "cryptoGetLiveHash." + error;
//                 }
//             }
//             if (message.cryptoGetProxyStakers != null && message.hasOwnProperty("cryptoGetProxyStakers")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.CryptoGetStakersQuery.verify(message.cryptoGetProxyStakers);
//                     if (error)
//                         return "cryptoGetProxyStakers." + error;
//                 }
//             }
//             if (message.fileGetContents != null && message.hasOwnProperty("fileGetContents")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.FileGetContentsQuery.verify(message.fileGetContents);
//                     if (error)
//                         return "fileGetContents." + error;
//                 }
//             }
//             if (message.fileGetInfo != null && message.hasOwnProperty("fileGetInfo")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.FileGetInfoQuery.verify(message.fileGetInfo);
//                     if (error)
//                         return "fileGetInfo." + error;
//                 }
//             }
//             if (message.transactionGetReceipt != null && message.hasOwnProperty("transactionGetReceipt")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.TransactionGetReceiptQuery.verify(message.transactionGetReceipt);
//                     if (error)
//                         return "transactionGetReceipt." + error;
//                 }
//             }
//             if (message.transactionGetRecord != null && message.hasOwnProperty("transactionGetRecord")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.TransactionGetRecordQuery.verify(message.transactionGetRecord);
//                     if (error)
//                         return "transactionGetRecord." + error;
//                 }
//             }
//             if (message.transactionGetFastRecord != null && message.hasOwnProperty("transactionGetFastRecord")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.TransactionGetFastRecordQuery.verify(message.transactionGetFastRecord);
//                     if (error)
//                         return "transactionGetFastRecord." + error;
//                 }
//             }
//             if (message.consensusGetTopicInfo != null && message.hasOwnProperty("consensusGetTopicInfo")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.ConsensusGetTopicInfoQuery.verify(message.consensusGetTopicInfo);
//                     if (error)
//                         return "consensusGetTopicInfo." + error;
//                 }
//             }
//             if (message.networkGetVersionInfo != null && message.hasOwnProperty("networkGetVersionInfo")) {
//                 if (properties.query === 1)
//                     return "query: multiple values";
//                 properties.query = 1;
//                 {
//                     let error = $root.proto.NetworkGetVersionInfoQuery.verify(message.networkGetVersionInfo);
//                     if (error)
//                         return "networkGetVersionInfo." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a Query message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Query
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Query} Query
//          */
//         Query.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Query)
//                 return object;
//             let message = new $root.proto.Query();
//             if (object.getByKey != null) {
//                 if (typeof object.getByKey !== "object")
//                     throw TypeError(".proto.Query.getByKey: object expected");
//                 message.getByKey = $root.proto.GetByKeyQuery.fromObject(object.getByKey);
//             }
//             if (object.getBySolidityID != null) {
//                 if (typeof object.getBySolidityID !== "object")
//                     throw TypeError(".proto.Query.getBySolidityID: object expected");
//                 message.getBySolidityID = $root.proto.GetBySolidityIDQuery.fromObject(object.getBySolidityID);
//             }
//             if (object.contractCallLocal != null) {
//                 if (typeof object.contractCallLocal !== "object")
//                     throw TypeError(".proto.Query.contractCallLocal: object expected");
//                 message.contractCallLocal = $root.proto.ContractCallLocalQuery.fromObject(object.contractCallLocal);
//             }
//             if (object.contractGetInfo != null) {
//                 if (typeof object.contractGetInfo !== "object")
//                     throw TypeError(".proto.Query.contractGetInfo: object expected");
//                 message.contractGetInfo = $root.proto.ContractGetInfoQuery.fromObject(object.contractGetInfo);
//             }
//             if (object.contractGetBytecode != null) {
//                 if (typeof object.contractGetBytecode !== "object")
//                     throw TypeError(".proto.Query.contractGetBytecode: object expected");
//                 message.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.fromObject(object.contractGetBytecode);
//             }
//             if (object.ContractGetRecords != null) {
//                 if (typeof object.ContractGetRecords !== "object")
//                     throw TypeError(".proto.Query.ContractGetRecords: object expected");
//                 message.ContractGetRecords = $root.proto.ContractGetRecordsQuery.fromObject(object.ContractGetRecords);
//             }
//             if (object.cryptogetAccountBalance != null) {
//                 if (typeof object.cryptogetAccountBalance !== "object")
//                     throw TypeError(".proto.Query.cryptogetAccountBalance: object expected");
//                 message.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.fromObject(object.cryptogetAccountBalance);
//             }
//             if (object.cryptoGetAccountRecords != null) {
//                 if (typeof object.cryptoGetAccountRecords !== "object")
//                     throw TypeError(".proto.Query.cryptoGetAccountRecords: object expected");
//                 message.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.fromObject(object.cryptoGetAccountRecords);
//             }
//             if (object.cryptoGetInfo != null) {
//                 if (typeof object.cryptoGetInfo !== "object")
//                     throw TypeError(".proto.Query.cryptoGetInfo: object expected");
//                 message.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.fromObject(object.cryptoGetInfo);
//             }
//             if (object.cryptoGetLiveHash != null) {
//                 if (typeof object.cryptoGetLiveHash !== "object")
//                     throw TypeError(".proto.Query.cryptoGetLiveHash: object expected");
//                 message.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.fromObject(object.cryptoGetLiveHash);
//             }
//             if (object.cryptoGetProxyStakers != null) {
//                 if (typeof object.cryptoGetProxyStakers !== "object")
//                     throw TypeError(".proto.Query.cryptoGetProxyStakers: object expected");
//                 message.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.fromObject(object.cryptoGetProxyStakers);
//             }
//             if (object.fileGetContents != null) {
//                 if (typeof object.fileGetContents !== "object")
//                     throw TypeError(".proto.Query.fileGetContents: object expected");
//                 message.fileGetContents = $root.proto.FileGetContentsQuery.fromObject(object.fileGetContents);
//             }
//             if (object.fileGetInfo != null) {
//                 if (typeof object.fileGetInfo !== "object")
//                     throw TypeError(".proto.Query.fileGetInfo: object expected");
//                 message.fileGetInfo = $root.proto.FileGetInfoQuery.fromObject(object.fileGetInfo);
//             }
//             if (object.transactionGetReceipt != null) {
//                 if (typeof object.transactionGetReceipt !== "object")
//                     throw TypeError(".proto.Query.transactionGetReceipt: object expected");
//                 message.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.fromObject(object.transactionGetReceipt);
//             }
//             if (object.transactionGetRecord != null) {
//                 if (typeof object.transactionGetRecord !== "object")
//                     throw TypeError(".proto.Query.transactionGetRecord: object expected");
//                 message.transactionGetRecord = $root.proto.TransactionGetRecordQuery.fromObject(object.transactionGetRecord);
//             }
//             if (object.transactionGetFastRecord != null) {
//                 if (typeof object.transactionGetFastRecord !== "object")
//                     throw TypeError(".proto.Query.transactionGetFastRecord: object expected");
//                 message.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.fromObject(object.transactionGetFastRecord);
//             }
//             if (object.consensusGetTopicInfo != null) {
//                 if (typeof object.consensusGetTopicInfo !== "object")
//                     throw TypeError(".proto.Query.consensusGetTopicInfo: object expected");
//                 message.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.fromObject(object.consensusGetTopicInfo);
//             }
//             if (object.networkGetVersionInfo != null) {
//                 if (typeof object.networkGetVersionInfo !== "object")
//                     throw TypeError(".proto.Query.networkGetVersionInfo: object expected");
//                 message.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.fromObject(object.networkGetVersionInfo);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Query message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Query
//          * @static
//          * @param {proto.Query} message Query
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Query.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (message.getByKey != null && message.hasOwnProperty("getByKey")) {
//                 object.getByKey = $root.proto.GetByKeyQuery.toObject(message.getByKey, options);
//                 if (options.oneofs)
//                     object.query = "getByKey";
//             }
//             if (message.getBySolidityID != null && message.hasOwnProperty("getBySolidityID")) {
//                 object.getBySolidityID = $root.proto.GetBySolidityIDQuery.toObject(message.getBySolidityID, options);
//                 if (options.oneofs)
//                     object.query = "getBySolidityID";
//             }
//             if (message.contractCallLocal != null && message.hasOwnProperty("contractCallLocal")) {
//                 object.contractCallLocal = $root.proto.ContractCallLocalQuery.toObject(message.contractCallLocal, options);
//                 if (options.oneofs)
//                     object.query = "contractCallLocal";
//             }
//             if (message.contractGetInfo != null && message.hasOwnProperty("contractGetInfo")) {
//                 object.contractGetInfo = $root.proto.ContractGetInfoQuery.toObject(message.contractGetInfo, options);
//                 if (options.oneofs)
//                     object.query = "contractGetInfo";
//             }
//             if (message.contractGetBytecode != null && message.hasOwnProperty("contractGetBytecode")) {
//                 object.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.toObject(message.contractGetBytecode, options);
//                 if (options.oneofs)
//                     object.query = "contractGetBytecode";
//             }
//             if (message.ContractGetRecords != null && message.hasOwnProperty("ContractGetRecords")) {
//                 object.ContractGetRecords = $root.proto.ContractGetRecordsQuery.toObject(message.ContractGetRecords, options);
//                 if (options.oneofs)
//                     object.query = "ContractGetRecords";
//             }
//             if (message.cryptogetAccountBalance != null && message.hasOwnProperty("cryptogetAccountBalance")) {
//                 object.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.toObject(message.cryptogetAccountBalance, options);
//                 if (options.oneofs)
//                     object.query = "cryptogetAccountBalance";
//             }
//             if (message.cryptoGetAccountRecords != null && message.hasOwnProperty("cryptoGetAccountRecords")) {
//                 object.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.toObject(message.cryptoGetAccountRecords, options);
//                 if (options.oneofs)
//                     object.query = "cryptoGetAccountRecords";
//             }
//             if (message.cryptoGetInfo != null && message.hasOwnProperty("cryptoGetInfo")) {
//                 object.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.toObject(message.cryptoGetInfo, options);
//                 if (options.oneofs)
//                     object.query = "cryptoGetInfo";
//             }
//             if (message.cryptoGetLiveHash != null && message.hasOwnProperty("cryptoGetLiveHash")) {
//                 object.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.toObject(message.cryptoGetLiveHash, options);
//                 if (options.oneofs)
//                     object.query = "cryptoGetLiveHash";
//             }
//             if (message.cryptoGetProxyStakers != null && message.hasOwnProperty("cryptoGetProxyStakers")) {
//                 object.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.toObject(message.cryptoGetProxyStakers, options);
//                 if (options.oneofs)
//                     object.query = "cryptoGetProxyStakers";
//             }
//             if (message.fileGetContents != null && message.hasOwnProperty("fileGetContents")) {
//                 object.fileGetContents = $root.proto.FileGetContentsQuery.toObject(message.fileGetContents, options);
//                 if (options.oneofs)
//                     object.query = "fileGetContents";
//             }
//             if (message.fileGetInfo != null && message.hasOwnProperty("fileGetInfo")) {
//                 object.fileGetInfo = $root.proto.FileGetInfoQuery.toObject(message.fileGetInfo, options);
//                 if (options.oneofs)
//                     object.query = "fileGetInfo";
//             }
//             if (message.transactionGetReceipt != null && message.hasOwnProperty("transactionGetReceipt")) {
//                 object.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.toObject(message.transactionGetReceipt, options);
//                 if (options.oneofs)
//                     object.query = "transactionGetReceipt";
//             }
//             if (message.transactionGetRecord != null && message.hasOwnProperty("transactionGetRecord")) {
//                 object.transactionGetRecord = $root.proto.TransactionGetRecordQuery.toObject(message.transactionGetRecord, options);
//                 if (options.oneofs)
//                     object.query = "transactionGetRecord";
//             }
//             if (message.transactionGetFastRecord != null && message.hasOwnProperty("transactionGetFastRecord")) {
//                 object.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.toObject(message.transactionGetFastRecord, options);
//                 if (options.oneofs)
//                     object.query = "transactionGetFastRecord";
//             }
//             if (message.consensusGetTopicInfo != null && message.hasOwnProperty("consensusGetTopicInfo")) {
//                 object.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.toObject(message.consensusGetTopicInfo, options);
//                 if (options.oneofs)
//                     object.query = "consensusGetTopicInfo";
//             }
//             if (message.networkGetVersionInfo != null && message.hasOwnProperty("networkGetVersionInfo")) {
//                 object.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.toObject(message.networkGetVersionInfo, options);
//                 if (options.oneofs)
//                     object.query = "networkGetVersionInfo";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this Query to JSON.
//          * @function toJSON
//          * @memberof proto.Query
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Query.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Query;
//     })();
// 
//     proto.GetByKeyQuery = (function() {
// 
//         /**
//          * Properties of a GetByKeyQuery.
//          * @memberof proto
//          * @interface IGetByKeyQuery
//          * @property {proto.IQueryHeader|null} [header] GetByKeyQuery header
//          * @property {proto.IKey|null} [key] GetByKeyQuery key
//          */
// 
//         /**
//          * Constructs a new GetByKeyQuery.
//          * @memberof proto
//          * @classdesc Represents a GetByKeyQuery.
//          * @implements IGetByKeyQuery
//          * @constructor
//          * @param {proto.IGetByKeyQuery=} [properties] Properties to set
//          */
//         function GetByKeyQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * GetByKeyQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.GetByKeyQuery
//          * @instance
//          */
//         GetByKeyQuery.prototype.header = null;
// 
//         /**
//          * GetByKeyQuery key.
//          * @member {proto.IKey|null|undefined} key
//          * @memberof proto.GetByKeyQuery
//          * @instance
//          */
//         GetByKeyQuery.prototype.key = null;
// 
//         /**
//          * Creates a new GetByKeyQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {proto.IGetByKeyQuery=} [properties] Properties to set
//          * @returns {proto.GetByKeyQuery} GetByKeyQuery instance
//          */
//         GetByKeyQuery.create = function create(properties) {
//             return new GetByKeyQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified GetByKeyQuery message. Does not implicitly {@link proto.GetByKeyQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {proto.IGetByKeyQuery} message GetByKeyQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetByKeyQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.key != null && Object.hasOwnProperty.call(message, "key"))
//                 $root.proto.Key.encode(message.key, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified GetByKeyQuery message, length delimited. Does not implicitly {@link proto.GetByKeyQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {proto.IGetByKeyQuery} message GetByKeyQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetByKeyQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a GetByKeyQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.GetByKeyQuery} GetByKeyQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetByKeyQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GetByKeyQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.key = $root.proto.Key.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a GetByKeyQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.GetByKeyQuery} GetByKeyQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetByKeyQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a GetByKeyQuery message.
//          * @function verify
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         GetByKeyQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.key != null && message.hasOwnProperty("key")) {
//                 let error = $root.proto.Key.verify(message.key);
//                 if (error)
//                     return "key." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a GetByKeyQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.GetByKeyQuery} GetByKeyQuery
//          */
//         GetByKeyQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.GetByKeyQuery)
//                 return object;
//             let message = new $root.proto.GetByKeyQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.GetByKeyQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.key != null) {
//                 if (typeof object.key !== "object")
//                     throw TypeError(".proto.GetByKeyQuery.key: object expected");
//                 message.key = $root.proto.Key.fromObject(object.key);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a GetByKeyQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.GetByKeyQuery
//          * @static
//          * @param {proto.GetByKeyQuery} message GetByKeyQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         GetByKeyQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.key = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.key != null && message.hasOwnProperty("key"))
//                 object.key = $root.proto.Key.toObject(message.key, options);
//             return object;
//         };
// 
//         /**
//          * Converts this GetByKeyQuery to JSON.
//          * @function toJSON
//          * @memberof proto.GetByKeyQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         GetByKeyQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return GetByKeyQuery;
//     })();
// 
//     proto.EntityID = (function() {
// 
//         /**
//          * Properties of an EntityID.
//          * @memberof proto
//          * @interface IEntityID
//          * @property {proto.IAccountID|null} [accountID] EntityID accountID
//          * @property {proto.ILiveHash|null} [liveHash] EntityID liveHash
//          * @property {proto.IFileID|null} [fileID] EntityID fileID
//          * @property {proto.IContractID|null} [contractID] EntityID contractID
//          */
// 
//         /**
//          * Constructs a new EntityID.
//          * @memberof proto
//          * @classdesc Represents an EntityID.
//          * @implements IEntityID
//          * @constructor
//          * @param {proto.IEntityID=} [properties] Properties to set
//          */
//         function EntityID(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * EntityID accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.EntityID
//          * @instance
//          */
//         EntityID.prototype.accountID = null;
// 
//         /**
//          * EntityID liveHash.
//          * @member {proto.ILiveHash|null|undefined} liveHash
//          * @memberof proto.EntityID
//          * @instance
//          */
//         EntityID.prototype.liveHash = null;
// 
//         /**
//          * EntityID fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.EntityID
//          * @instance
//          */
//         EntityID.prototype.fileID = null;
// 
//         /**
//          * EntityID contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.EntityID
//          * @instance
//          */
//         EntityID.prototype.contractID = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * EntityID entity.
//          * @member {"accountID"|"liveHash"|"fileID"|"contractID"|undefined} entity
//          * @memberof proto.EntityID
//          * @instance
//          */
//         Object.defineProperty(EntityID.prototype, "entity", {
//             get: $util.oneOfGetter($oneOfFields = ["accountID", "liveHash", "fileID", "contractID"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new EntityID instance using the specified properties.
//          * @function create
//          * @memberof proto.EntityID
//          * @static
//          * @param {proto.IEntityID=} [properties] Properties to set
//          * @returns {proto.EntityID} EntityID instance
//          */
//         EntityID.create = function create(properties) {
//             return new EntityID(properties);
//         };
// 
//         /**
//          * Encodes the specified EntityID message. Does not implicitly {@link proto.EntityID.verify|verify} messages.
//          * @function encode
//          * @memberof proto.EntityID
//          * @static
//          * @param {proto.IEntityID} message EntityID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         EntityID.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.liveHash != null && Object.hasOwnProperty.call(message, "liveHash"))
//                 $root.proto.LiveHash.encode(message.liveHash, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified EntityID message, length delimited. Does not implicitly {@link proto.EntityID.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.EntityID
//          * @static
//          * @param {proto.IEntityID} message EntityID message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         EntityID.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an EntityID message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.EntityID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.EntityID} EntityID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         EntityID.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.EntityID();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.liveHash = $root.proto.LiveHash.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an EntityID message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.EntityID
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.EntityID} EntityID
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         EntityID.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an EntityID message.
//          * @function verify
//          * @memberof proto.EntityID
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         EntityID.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 properties.entity = 1;
//                 {
//                     let error = $root.proto.AccountID.verify(message.accountID);
//                     if (error)
//                         return "accountID." + error;
//                 }
//             }
//             if (message.liveHash != null && message.hasOwnProperty("liveHash")) {
//                 if (properties.entity === 1)
//                     return "entity: multiple values";
//                 properties.entity = 1;
//                 {
//                     let error = $root.proto.LiveHash.verify(message.liveHash);
//                     if (error)
//                         return "liveHash." + error;
//                 }
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 if (properties.entity === 1)
//                     return "entity: multiple values";
//                 properties.entity = 1;
//                 {
//                     let error = $root.proto.FileID.verify(message.fileID);
//                     if (error)
//                         return "fileID." + error;
//                 }
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 if (properties.entity === 1)
//                     return "entity: multiple values";
//                 properties.entity = 1;
//                 {
//                     let error = $root.proto.ContractID.verify(message.contractID);
//                     if (error)
//                         return "contractID." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates an EntityID message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.EntityID
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.EntityID} EntityID
//          */
//         EntityID.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.EntityID)
//                 return object;
//             let message = new $root.proto.EntityID();
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.EntityID.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.liveHash != null) {
//                 if (typeof object.liveHash !== "object")
//                     throw TypeError(".proto.EntityID.liveHash: object expected");
//                 message.liveHash = $root.proto.LiveHash.fromObject(object.liveHash);
//             }
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.EntityID.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.EntityID.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an EntityID message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.EntityID
//          * @static
//          * @param {proto.EntityID} message EntityID
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         EntityID.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//                 if (options.oneofs)
//                     object.entity = "accountID";
//             }
//             if (message.liveHash != null && message.hasOwnProperty("liveHash")) {
//                 object.liveHash = $root.proto.LiveHash.toObject(message.liveHash, options);
//                 if (options.oneofs)
//                     object.entity = "liveHash";
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//                 if (options.oneofs)
//                     object.entity = "fileID";
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//                 if (options.oneofs)
//                     object.entity = "contractID";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this EntityID to JSON.
//          * @function toJSON
//          * @memberof proto.EntityID
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         EntityID.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return EntityID;
//     })();
// 
//     proto.GetByKeyResponse = (function() {
// 
//         /**
//          * Properties of a GetByKeyResponse.
//          * @memberof proto
//          * @interface IGetByKeyResponse
//          * @property {proto.IResponseHeader|null} [header] GetByKeyResponse header
//          * @property {Array.<proto.IEntityID>|null} [entities] GetByKeyResponse entities
//          */
// 
//         /**
//          * Constructs a new GetByKeyResponse.
//          * @memberof proto
//          * @classdesc Represents a GetByKeyResponse.
//          * @implements IGetByKeyResponse
//          * @constructor
//          * @param {proto.IGetByKeyResponse=} [properties] Properties to set
//          */
//         function GetByKeyResponse(properties) {
//             this.entities = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * GetByKeyResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.GetByKeyResponse
//          * @instance
//          */
//         GetByKeyResponse.prototype.header = null;
// 
//         /**
//          * GetByKeyResponse entities.
//          * @member {Array.<proto.IEntityID>} entities
//          * @memberof proto.GetByKeyResponse
//          * @instance
//          */
//         GetByKeyResponse.prototype.entities = $util.emptyArray;
// 
//         /**
//          * Creates a new GetByKeyResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {proto.IGetByKeyResponse=} [properties] Properties to set
//          * @returns {proto.GetByKeyResponse} GetByKeyResponse instance
//          */
//         GetByKeyResponse.create = function create(properties) {
//             return new GetByKeyResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified GetByKeyResponse message. Does not implicitly {@link proto.GetByKeyResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {proto.IGetByKeyResponse} message GetByKeyResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetByKeyResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.entities != null && message.entities.length)
//                 for (let i = 0; i < message.entities.length; ++i)
//                     $root.proto.EntityID.encode(message.entities[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified GetByKeyResponse message, length delimited. Does not implicitly {@link proto.GetByKeyResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {proto.IGetByKeyResponse} message GetByKeyResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetByKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a GetByKeyResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.GetByKeyResponse} GetByKeyResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetByKeyResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GetByKeyResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     if (!(message.entities && message.entities.length))
//                         message.entities = [];
//                     message.entities.push($root.proto.EntityID.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a GetByKeyResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.GetByKeyResponse} GetByKeyResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetByKeyResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a GetByKeyResponse message.
//          * @function verify
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         GetByKeyResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.entities != null && message.hasOwnProperty("entities")) {
//                 if (!Array.isArray(message.entities))
//                     return "entities: array expected";
//                 for (let i = 0; i < message.entities.length; ++i) {
//                     let error = $root.proto.EntityID.verify(message.entities[i]);
//                     if (error)
//                         return "entities." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a GetByKeyResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.GetByKeyResponse} GetByKeyResponse
//          */
//         GetByKeyResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.GetByKeyResponse)
//                 return object;
//             let message = new $root.proto.GetByKeyResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.GetByKeyResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.entities) {
//                 if (!Array.isArray(object.entities))
//                     throw TypeError(".proto.GetByKeyResponse.entities: array expected");
//                 message.entities = [];
//                 for (let i = 0; i < object.entities.length; ++i) {
//                     if (typeof object.entities[i] !== "object")
//                         throw TypeError(".proto.GetByKeyResponse.entities: object expected");
//                     message.entities[i] = $root.proto.EntityID.fromObject(object.entities[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a GetByKeyResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.GetByKeyResponse
//          * @static
//          * @param {proto.GetByKeyResponse} message GetByKeyResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         GetByKeyResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.entities = [];
//             if (options.defaults)
//                 object.header = null;
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.entities && message.entities.length) {
//                 object.entities = [];
//                 for (let j = 0; j < message.entities.length; ++j)
//                     object.entities[j] = $root.proto.EntityID.toObject(message.entities[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this GetByKeyResponse to JSON.
//          * @function toJSON
//          * @memberof proto.GetByKeyResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         GetByKeyResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return GetByKeyResponse;
//     })();
// 
//     proto.GetBySolidityIDQuery = (function() {
// 
//         /**
//          * Properties of a GetBySolidityIDQuery.
//          * @memberof proto
//          * @interface IGetBySolidityIDQuery
//          * @property {proto.IQueryHeader|null} [header] GetBySolidityIDQuery header
//          * @property {string|null} [solidityID] GetBySolidityIDQuery solidityID
//          */
// 
//         /**
//          * Constructs a new GetBySolidityIDQuery.
//          * @memberof proto
//          * @classdesc Represents a GetBySolidityIDQuery.
//          * @implements IGetBySolidityIDQuery
//          * @constructor
//          * @param {proto.IGetBySolidityIDQuery=} [properties] Properties to set
//          */
//         function GetBySolidityIDQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * GetBySolidityIDQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.GetBySolidityIDQuery
//          * @instance
//          */
//         GetBySolidityIDQuery.prototype.header = null;
// 
//         /**
//          * GetBySolidityIDQuery solidityID.
//          * @member {string} solidityID
//          * @memberof proto.GetBySolidityIDQuery
//          * @instance
//          */
//         GetBySolidityIDQuery.prototype.solidityID = "";
// 
//         /**
//          * Creates a new GetBySolidityIDQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {proto.IGetBySolidityIDQuery=} [properties] Properties to set
//          * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery instance
//          */
//         GetBySolidityIDQuery.create = function create(properties) {
//             return new GetBySolidityIDQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified GetBySolidityIDQuery message. Does not implicitly {@link proto.GetBySolidityIDQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {proto.IGetBySolidityIDQuery} message GetBySolidityIDQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetBySolidityIDQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.solidityID != null && Object.hasOwnProperty.call(message, "solidityID"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).string(message.solidityID);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified GetBySolidityIDQuery message, length delimited. Does not implicitly {@link proto.GetBySolidityIDQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {proto.IGetBySolidityIDQuery} message GetBySolidityIDQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetBySolidityIDQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a GetBySolidityIDQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetBySolidityIDQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GetBySolidityIDQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.solidityID = reader.string();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a GetBySolidityIDQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetBySolidityIDQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a GetBySolidityIDQuery message.
//          * @function verify
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         GetBySolidityIDQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.solidityID != null && message.hasOwnProperty("solidityID"))
//                 if (!$util.isString(message.solidityID))
//                     return "solidityID: string expected";
//             return null;
//         };
// 
//         /**
//          * Creates a GetBySolidityIDQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery
//          */
//         GetBySolidityIDQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.GetBySolidityIDQuery)
//                 return object;
//             let message = new $root.proto.GetBySolidityIDQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.GetBySolidityIDQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.solidityID != null)
//                 message.solidityID = String(object.solidityID);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a GetBySolidityIDQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.GetBySolidityIDQuery
//          * @static
//          * @param {proto.GetBySolidityIDQuery} message GetBySolidityIDQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         GetBySolidityIDQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.solidityID = "";
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.solidityID != null && message.hasOwnProperty("solidityID"))
//                 object.solidityID = message.solidityID;
//             return object;
//         };
// 
//         /**
//          * Converts this GetBySolidityIDQuery to JSON.
//          * @function toJSON
//          * @memberof proto.GetBySolidityIDQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         GetBySolidityIDQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return GetBySolidityIDQuery;
//     })();
// 
//     proto.GetBySolidityIDResponse = (function() {
// 
//         /**
//          * Properties of a GetBySolidityIDResponse.
//          * @memberof proto
//          * @interface IGetBySolidityIDResponse
//          * @property {proto.IResponseHeader|null} [header] GetBySolidityIDResponse header
//          * @property {proto.IAccountID|null} [accountID] GetBySolidityIDResponse accountID
//          * @property {proto.IFileID|null} [fileID] GetBySolidityIDResponse fileID
//          * @property {proto.IContractID|null} [contractID] GetBySolidityIDResponse contractID
//          */
// 
//         /**
//          * Constructs a new GetBySolidityIDResponse.
//          * @memberof proto
//          * @classdesc Represents a GetBySolidityIDResponse.
//          * @implements IGetBySolidityIDResponse
//          * @constructor
//          * @param {proto.IGetBySolidityIDResponse=} [properties] Properties to set
//          */
//         function GetBySolidityIDResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * GetBySolidityIDResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.GetBySolidityIDResponse
//          * @instance
//          */
//         GetBySolidityIDResponse.prototype.header = null;
// 
//         /**
//          * GetBySolidityIDResponse accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.GetBySolidityIDResponse
//          * @instance
//          */
//         GetBySolidityIDResponse.prototype.accountID = null;
// 
//         /**
//          * GetBySolidityIDResponse fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.GetBySolidityIDResponse
//          * @instance
//          */
//         GetBySolidityIDResponse.prototype.fileID = null;
// 
//         /**
//          * GetBySolidityIDResponse contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.GetBySolidityIDResponse
//          * @instance
//          */
//         GetBySolidityIDResponse.prototype.contractID = null;
// 
//         /**
//          * Creates a new GetBySolidityIDResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {proto.IGetBySolidityIDResponse=} [properties] Properties to set
//          * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse instance
//          */
//         GetBySolidityIDResponse.create = function create(properties) {
//             return new GetBySolidityIDResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified GetBySolidityIDResponse message. Does not implicitly {@link proto.GetBySolidityIDResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {proto.IGetBySolidityIDResponse} message GetBySolidityIDResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetBySolidityIDResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified GetBySolidityIDResponse message, length delimited. Does not implicitly {@link proto.GetBySolidityIDResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {proto.IGetBySolidityIDResponse} message GetBySolidityIDResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         GetBySolidityIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a GetBySolidityIDResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetBySolidityIDResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GetBySolidityIDResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a GetBySolidityIDResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         GetBySolidityIDResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a GetBySolidityIDResponse message.
//          * @function verify
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         GetBySolidityIDResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a GetBySolidityIDResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse
//          */
//         GetBySolidityIDResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.GetBySolidityIDResponse)
//                 return object;
//             let message = new $root.proto.GetBySolidityIDResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.GetBySolidityIDResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.GetBySolidityIDResponse.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.GetBySolidityIDResponse.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.GetBySolidityIDResponse.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a GetBySolidityIDResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.GetBySolidityIDResponse
//          * @static
//          * @param {proto.GetBySolidityIDResponse} message GetBySolidityIDResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         GetBySolidityIDResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//                 object.fileID = null;
//                 object.contractID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this GetBySolidityIDResponse to JSON.
//          * @function toJSON
//          * @memberof proto.GetBySolidityIDResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         GetBySolidityIDResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return GetBySolidityIDResponse;
//     })();
// 
//     proto.ContractLoginfo = (function() {
// 
//         /**
//          * Properties of a ContractLoginfo.
//          * @memberof proto
//          * @interface IContractLoginfo
//          * @property {proto.IContractID|null} [contractID] ContractLoginfo contractID
//          * @property {Uint8Array|null} [bloom] ContractLoginfo bloom
//          * @property {Array.<Uint8Array>|null} [topic] ContractLoginfo topic
//          * @property {Uint8Array|null} [data] ContractLoginfo data
//          */
// 
//         /**
//          * Constructs a new ContractLoginfo.
//          * @memberof proto
//          * @classdesc Represents a ContractLoginfo.
//          * @implements IContractLoginfo
//          * @constructor
//          * @param {proto.IContractLoginfo=} [properties] Properties to set
//          */
//         function ContractLoginfo(properties) {
//             this.topic = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractLoginfo contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractLoginfo
//          * @instance
//          */
//         ContractLoginfo.prototype.contractID = null;
// 
//         /**
//          * ContractLoginfo bloom.
//          * @member {Uint8Array} bloom
//          * @memberof proto.ContractLoginfo
//          * @instance
//          */
//         ContractLoginfo.prototype.bloom = $util.newBuffer([]);
// 
//         /**
//          * ContractLoginfo topic.
//          * @member {Array.<Uint8Array>} topic
//          * @memberof proto.ContractLoginfo
//          * @instance
//          */
//         ContractLoginfo.prototype.topic = $util.emptyArray;
// 
//         /**
//          * ContractLoginfo data.
//          * @member {Uint8Array} data
//          * @memberof proto.ContractLoginfo
//          * @instance
//          */
//         ContractLoginfo.prototype.data = $util.newBuffer([]);
// 
//         /**
//          * Creates a new ContractLoginfo instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {proto.IContractLoginfo=} [properties] Properties to set
//          * @returns {proto.ContractLoginfo} ContractLoginfo instance
//          */
//         ContractLoginfo.create = function create(properties) {
//             return new ContractLoginfo(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractLoginfo message. Does not implicitly {@link proto.ContractLoginfo.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {proto.IContractLoginfo} message ContractLoginfo message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractLoginfo.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.bloom != null && Object.hasOwnProperty.call(message, "bloom"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bloom);
//             if (message.topic != null && message.topic.length)
//                 for (let i = 0; i < message.topic.length; ++i)
//                     writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.topic[i]);
//             if (message.data != null && Object.hasOwnProperty.call(message, "data"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractLoginfo message, length delimited. Does not implicitly {@link proto.ContractLoginfo.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {proto.IContractLoginfo} message ContractLoginfo message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractLoginfo.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractLoginfo message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractLoginfo} ContractLoginfo
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractLoginfo.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractLoginfo();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.bloom = reader.bytes();
//                     break;
//                 case 3:
//                     if (!(message.topic && message.topic.length))
//                         message.topic = [];
//                     message.topic.push(reader.bytes());
//                     break;
//                 case 4:
//                     message.data = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractLoginfo message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractLoginfo} ContractLoginfo
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractLoginfo.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractLoginfo message.
//          * @function verify
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractLoginfo.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.bloom != null && message.hasOwnProperty("bloom"))
//                 if (!(message.bloom && typeof message.bloom.length === "number" || $util.isString(message.bloom)))
//                     return "bloom: buffer expected";
//             if (message.topic != null && message.hasOwnProperty("topic")) {
//                 if (!Array.isArray(message.topic))
//                     return "topic: array expected";
//                 for (let i = 0; i < message.topic.length; ++i)
//                     if (!(message.topic[i] && typeof message.topic[i].length === "number" || $util.isString(message.topic[i])))
//                         return "topic: buffer[] expected";
//             }
//             if (message.data != null && message.hasOwnProperty("data"))
//                 if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
//                     return "data: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ContractLoginfo message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractLoginfo} ContractLoginfo
//          */
//         ContractLoginfo.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractLoginfo)
//                 return object;
//             let message = new $root.proto.ContractLoginfo();
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractLoginfo.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.bloom != null)
//                 if (typeof object.bloom === "string")
//                     $util.base64.decode(object.bloom, message.bloom = $util.newBuffer($util.base64.length(object.bloom)), 0);
//                 else if (object.bloom.length)
//                     message.bloom = object.bloom;
//             if (object.topic) {
//                 if (!Array.isArray(object.topic))
//                     throw TypeError(".proto.ContractLoginfo.topic: array expected");
//                 message.topic = [];
//                 for (let i = 0; i < object.topic.length; ++i)
//                     if (typeof object.topic[i] === "string")
//                         $util.base64.decode(object.topic[i], message.topic[i] = $util.newBuffer($util.base64.length(object.topic[i])), 0);
//                     else if (object.topic[i].length)
//                         message.topic[i] = object.topic[i];
//             }
//             if (object.data != null)
//                 if (typeof object.data === "string")
//                     $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
//                 else if (object.data.length)
//                     message.data = object.data;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractLoginfo message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractLoginfo
//          * @static
//          * @param {proto.ContractLoginfo} message ContractLoginfo
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractLoginfo.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.topic = [];
//             if (options.defaults) {
//                 object.contractID = null;
//                 if (options.bytes === String)
//                     object.bloom = "";
//                 else {
//                     object.bloom = [];
//                     if (options.bytes !== Array)
//                         object.bloom = $util.newBuffer(object.bloom);
//                 }
//                 if (options.bytes === String)
//                     object.data = "";
//                 else {
//                     object.data = [];
//                     if (options.bytes !== Array)
//                         object.data = $util.newBuffer(object.data);
//                 }
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.bloom != null && message.hasOwnProperty("bloom"))
//                 object.bloom = options.bytes === String ? $util.base64.encode(message.bloom, 0, message.bloom.length) : options.bytes === Array ? Array.prototype.slice.call(message.bloom) : message.bloom;
//             if (message.topic && message.topic.length) {
//                 object.topic = [];
//                 for (let j = 0; j < message.topic.length; ++j)
//                     object.topic[j] = options.bytes === String ? $util.base64.encode(message.topic[j], 0, message.topic[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.topic[j]) : message.topic[j];
//             }
//             if (message.data != null && message.hasOwnProperty("data"))
//                 object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
//             return object;
//         };
// 
//         /**
//          * Converts this ContractLoginfo to JSON.
//          * @function toJSON
//          * @memberof proto.ContractLoginfo
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractLoginfo.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractLoginfo;
//     })();
// 
//     proto.ContractFunctionResult = (function() {
// 
//         /**
//          * Properties of a ContractFunctionResult.
//          * @memberof proto
//          * @interface IContractFunctionResult
//          * @property {proto.IContractID|null} [contractID] ContractFunctionResult contractID
//          * @property {Uint8Array|null} [contractCallResult] ContractFunctionResult contractCallResult
//          * @property {string|null} [errorMessage] ContractFunctionResult errorMessage
//          * @property {Uint8Array|null} [bloom] ContractFunctionResult bloom
//          * @property {number|Long|null} [gasUsed] ContractFunctionResult gasUsed
//          * @property {Array.<proto.IContractLoginfo>|null} [logInfo] ContractFunctionResult logInfo
//          * @property {Array.<proto.IContractID>|null} [createdContractIDs] ContractFunctionResult createdContractIDs
//          */
// 
//         /**
//          * Constructs a new ContractFunctionResult.
//          * @memberof proto
//          * @classdesc Represents a ContractFunctionResult.
//          * @implements IContractFunctionResult
//          * @constructor
//          * @param {proto.IContractFunctionResult=} [properties] Properties to set
//          */
//         function ContractFunctionResult(properties) {
//             this.logInfo = [];
//             this.createdContractIDs = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractFunctionResult contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          */
//         ContractFunctionResult.prototype.contractID = null;
// 
//         /**
//          * ContractFunctionResult contractCallResult.
//          * @member {Uint8Array} contractCallResult
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          */
//         ContractFunctionResult.prototype.contractCallResult = $util.newBuffer([]);
// 
//         /**
//          * ContractFunctionResult errorMessage.
//          * @member {string} errorMessage
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          */
//         ContractFunctionResult.prototype.errorMessage = "";
// 
//         /**
//          * ContractFunctionResult bloom.
//          * @member {Uint8Array} bloom
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          */
//         ContractFunctionResult.prototype.bloom = $util.newBuffer([]);
// 
//         /**
//          * ContractFunctionResult gasUsed.
//          * @member {number|Long} gasUsed
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          */
//         ContractFunctionResult.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * ContractFunctionResult logInfo.
//          * @member {Array.<proto.IContractLoginfo>} logInfo
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          */
//         ContractFunctionResult.prototype.logInfo = $util.emptyArray;
// 
//         /**
//          * ContractFunctionResult createdContractIDs.
//          * @member {Array.<proto.IContractID>} createdContractIDs
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          */
//         ContractFunctionResult.prototype.createdContractIDs = $util.emptyArray;
// 
//         /**
//          * Creates a new ContractFunctionResult instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {proto.IContractFunctionResult=} [properties] Properties to set
//          * @returns {proto.ContractFunctionResult} ContractFunctionResult instance
//          */
//         ContractFunctionResult.create = function create(properties) {
//             return new ContractFunctionResult(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractFunctionResult message. Does not implicitly {@link proto.ContractFunctionResult.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {proto.IContractFunctionResult} message ContractFunctionResult message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractFunctionResult.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractCallResult != null && Object.hasOwnProperty.call(message, "contractCallResult"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractCallResult);
//             if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMessage);
//             if (message.bloom != null && Object.hasOwnProperty.call(message, "bloom"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bloom);
//             if (message.gasUsed != null && Object.hasOwnProperty.call(message, "gasUsed"))
//                 writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.gasUsed);
//             if (message.logInfo != null && message.logInfo.length)
//                 for (let i = 0; i < message.logInfo.length; ++i)
//                     $root.proto.ContractLoginfo.encode(message.logInfo[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.createdContractIDs != null && message.createdContractIDs.length)
//                 for (let i = 0; i < message.createdContractIDs.length; ++i)
//                     $root.proto.ContractID.encode(message.createdContractIDs[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractFunctionResult message, length delimited. Does not implicitly {@link proto.ContractFunctionResult.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {proto.IContractFunctionResult} message ContractFunctionResult message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractFunctionResult.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractFunctionResult message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractFunctionResult} ContractFunctionResult
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractFunctionResult.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractFunctionResult();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractCallResult = reader.bytes();
//                     break;
//                 case 3:
//                     message.errorMessage = reader.string();
//                     break;
//                 case 4:
//                     message.bloom = reader.bytes();
//                     break;
//                 case 5:
//                     message.gasUsed = reader.uint64();
//                     break;
//                 case 6:
//                     if (!(message.logInfo && message.logInfo.length))
//                         message.logInfo = [];
//                     message.logInfo.push($root.proto.ContractLoginfo.decode(reader, reader.uint32()));
//                     break;
//                 case 7:
//                     if (!(message.createdContractIDs && message.createdContractIDs.length))
//                         message.createdContractIDs = [];
//                     message.createdContractIDs.push($root.proto.ContractID.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractFunctionResult message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractFunctionResult} ContractFunctionResult
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractFunctionResult.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractFunctionResult message.
//          * @function verify
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractFunctionResult.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.contractCallResult != null && message.hasOwnProperty("contractCallResult"))
//                 if (!(message.contractCallResult && typeof message.contractCallResult.length === "number" || $util.isString(message.contractCallResult)))
//                     return "contractCallResult: buffer expected";
//             if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
//                 if (!$util.isString(message.errorMessage))
//                     return "errorMessage: string expected";
//             if (message.bloom != null && message.hasOwnProperty("bloom"))
//                 if (!(message.bloom && typeof message.bloom.length === "number" || $util.isString(message.bloom)))
//                     return "bloom: buffer expected";
//             if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
//                 if (!$util.isInteger(message.gasUsed) && !(message.gasUsed && $util.isInteger(message.gasUsed.low) && $util.isInteger(message.gasUsed.high)))
//                     return "gasUsed: integer|Long expected";
//             if (message.logInfo != null && message.hasOwnProperty("logInfo")) {
//                 if (!Array.isArray(message.logInfo))
//                     return "logInfo: array expected";
//                 for (let i = 0; i < message.logInfo.length; ++i) {
//                     let error = $root.proto.ContractLoginfo.verify(message.logInfo[i]);
//                     if (error)
//                         return "logInfo." + error;
//                 }
//             }
//             if (message.createdContractIDs != null && message.hasOwnProperty("createdContractIDs")) {
//                 if (!Array.isArray(message.createdContractIDs))
//                     return "createdContractIDs: array expected";
//                 for (let i = 0; i < message.createdContractIDs.length; ++i) {
//                     let error = $root.proto.ContractID.verify(message.createdContractIDs[i]);
//                     if (error)
//                         return "createdContractIDs." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractFunctionResult message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractFunctionResult} ContractFunctionResult
//          */
//         ContractFunctionResult.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractFunctionResult)
//                 return object;
//             let message = new $root.proto.ContractFunctionResult();
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractFunctionResult.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.contractCallResult != null)
//                 if (typeof object.contractCallResult === "string")
//                     $util.base64.decode(object.contractCallResult, message.contractCallResult = $util.newBuffer($util.base64.length(object.contractCallResult)), 0);
//                 else if (object.contractCallResult.length)
//                     message.contractCallResult = object.contractCallResult;
//             if (object.errorMessage != null)
//                 message.errorMessage = String(object.errorMessage);
//             if (object.bloom != null)
//                 if (typeof object.bloom === "string")
//                     $util.base64.decode(object.bloom, message.bloom = $util.newBuffer($util.base64.length(object.bloom)), 0);
//                 else if (object.bloom.length)
//                     message.bloom = object.bloom;
//             if (object.gasUsed != null)
//                 if ($util.Long)
//                     (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = true;
//                 else if (typeof object.gasUsed === "string")
//                     message.gasUsed = parseInt(object.gasUsed, 10);
//                 else if (typeof object.gasUsed === "number")
//                     message.gasUsed = object.gasUsed;
//                 else if (typeof object.gasUsed === "object")
//                     message.gasUsed = new $util.LongBits(object.gasUsed.low >>> 0, object.gasUsed.high >>> 0).toNumber(true);
//             if (object.logInfo) {
//                 if (!Array.isArray(object.logInfo))
//                     throw TypeError(".proto.ContractFunctionResult.logInfo: array expected");
//                 message.logInfo = [];
//                 for (let i = 0; i < object.logInfo.length; ++i) {
//                     if (typeof object.logInfo[i] !== "object")
//                         throw TypeError(".proto.ContractFunctionResult.logInfo: object expected");
//                     message.logInfo[i] = $root.proto.ContractLoginfo.fromObject(object.logInfo[i]);
//                 }
//             }
//             if (object.createdContractIDs) {
//                 if (!Array.isArray(object.createdContractIDs))
//                     throw TypeError(".proto.ContractFunctionResult.createdContractIDs: array expected");
//                 message.createdContractIDs = [];
//                 for (let i = 0; i < object.createdContractIDs.length; ++i) {
//                     if (typeof object.createdContractIDs[i] !== "object")
//                         throw TypeError(".proto.ContractFunctionResult.createdContractIDs: object expected");
//                     message.createdContractIDs[i] = $root.proto.ContractID.fromObject(object.createdContractIDs[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractFunctionResult message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractFunctionResult
//          * @static
//          * @param {proto.ContractFunctionResult} message ContractFunctionResult
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractFunctionResult.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults) {
//                 object.logInfo = [];
//                 object.createdContractIDs = [];
//             }
//             if (options.defaults) {
//                 object.contractID = null;
//                 if (options.bytes === String)
//                     object.contractCallResult = "";
//                 else {
//                     object.contractCallResult = [];
//                     if (options.bytes !== Array)
//                         object.contractCallResult = $util.newBuffer(object.contractCallResult);
//                 }
//                 object.errorMessage = "";
//                 if (options.bytes === String)
//                     object.bloom = "";
//                 else {
//                     object.bloom = [];
//                     if (options.bytes !== Array)
//                         object.bloom = $util.newBuffer(object.bloom);
//                 }
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.gasUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.gasUsed = options.longs === String ? "0" : 0;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.contractCallResult != null && message.hasOwnProperty("contractCallResult"))
//                 object.contractCallResult = options.bytes === String ? $util.base64.encode(message.contractCallResult, 0, message.contractCallResult.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractCallResult) : message.contractCallResult;
//             if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
//                 object.errorMessage = message.errorMessage;
//             if (message.bloom != null && message.hasOwnProperty("bloom"))
//                 object.bloom = options.bytes === String ? $util.base64.encode(message.bloom, 0, message.bloom.length) : options.bytes === Array ? Array.prototype.slice.call(message.bloom) : message.bloom;
//             if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
//                 if (typeof message.gasUsed === "number")
//                     object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;
//                 else
//                     object.gasUsed = options.longs === String ? $util.Long.prototype.toString.call(message.gasUsed) : options.longs === Number ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber(true) : message.gasUsed;
//             if (message.logInfo && message.logInfo.length) {
//                 object.logInfo = [];
//                 for (let j = 0; j < message.logInfo.length; ++j)
//                     object.logInfo[j] = $root.proto.ContractLoginfo.toObject(message.logInfo[j], options);
//             }
//             if (message.createdContractIDs && message.createdContractIDs.length) {
//                 object.createdContractIDs = [];
//                 for (let j = 0; j < message.createdContractIDs.length; ++j)
//                     object.createdContractIDs[j] = $root.proto.ContractID.toObject(message.createdContractIDs[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this ContractFunctionResult to JSON.
//          * @function toJSON
//          * @memberof proto.ContractFunctionResult
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractFunctionResult.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractFunctionResult;
//     })();
// 
//     proto.ContractCallLocalQuery = (function() {
// 
//         /**
//          * Properties of a ContractCallLocalQuery.
//          * @memberof proto
//          * @interface IContractCallLocalQuery
//          * @property {proto.IQueryHeader|null} [header] ContractCallLocalQuery header
//          * @property {proto.IContractID|null} [contractID] ContractCallLocalQuery contractID
//          * @property {number|Long|null} [gas] ContractCallLocalQuery gas
//          * @property {Uint8Array|null} [functionParameters] ContractCallLocalQuery functionParameters
//          * @property {number|Long|null} [maxResultSize] ContractCallLocalQuery maxResultSize
//          */
// 
//         /**
//          * Constructs a new ContractCallLocalQuery.
//          * @memberof proto
//          * @classdesc Represents a ContractCallLocalQuery.
//          * @implements IContractCallLocalQuery
//          * @constructor
//          * @param {proto.IContractCallLocalQuery=} [properties] Properties to set
//          */
//         function ContractCallLocalQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractCallLocalQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.ContractCallLocalQuery
//          * @instance
//          */
//         ContractCallLocalQuery.prototype.header = null;
// 
//         /**
//          * ContractCallLocalQuery contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractCallLocalQuery
//          * @instance
//          */
//         ContractCallLocalQuery.prototype.contractID = null;
// 
//         /**
//          * ContractCallLocalQuery gas.
//          * @member {number|Long} gas
//          * @memberof proto.ContractCallLocalQuery
//          * @instance
//          */
//         ContractCallLocalQuery.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * ContractCallLocalQuery functionParameters.
//          * @member {Uint8Array} functionParameters
//          * @memberof proto.ContractCallLocalQuery
//          * @instance
//          */
//         ContractCallLocalQuery.prototype.functionParameters = $util.newBuffer([]);
// 
//         /**
//          * ContractCallLocalQuery maxResultSize.
//          * @member {number|Long} maxResultSize
//          * @memberof proto.ContractCallLocalQuery
//          * @instance
//          */
//         ContractCallLocalQuery.prototype.maxResultSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new ContractCallLocalQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {proto.IContractCallLocalQuery=} [properties] Properties to set
//          * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery instance
//          */
//         ContractCallLocalQuery.create = function create(properties) {
//             return new ContractCallLocalQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractCallLocalQuery message. Does not implicitly {@link proto.ContractCallLocalQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {proto.IContractCallLocalQuery} message ContractCallLocalQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCallLocalQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).int64(message.gas);
//             if (message.functionParameters != null && Object.hasOwnProperty.call(message, "functionParameters"))
//                 writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.functionParameters);
//             if (message.maxResultSize != null && Object.hasOwnProperty.call(message, "maxResultSize"))
//                 writer.uint32(/* id 5, wireType 0 =*/40).int64(message.maxResultSize);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractCallLocalQuery message, length delimited. Does not implicitly {@link proto.ContractCallLocalQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {proto.IContractCallLocalQuery} message ContractCallLocalQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCallLocalQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractCallLocalQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCallLocalQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractCallLocalQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.gas = reader.int64();
//                     break;
//                 case 4:
//                     message.functionParameters = reader.bytes();
//                     break;
//                 case 5:
//                     message.maxResultSize = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractCallLocalQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCallLocalQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractCallLocalQuery message.
//          * @function verify
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractCallLocalQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
//                     return "gas: integer|Long expected";
//             if (message.functionParameters != null && message.hasOwnProperty("functionParameters"))
//                 if (!(message.functionParameters && typeof message.functionParameters.length === "number" || $util.isString(message.functionParameters)))
//                     return "functionParameters: buffer expected";
//             if (message.maxResultSize != null && message.hasOwnProperty("maxResultSize"))
//                 if (!$util.isInteger(message.maxResultSize) && !(message.maxResultSize && $util.isInteger(message.maxResultSize.low) && $util.isInteger(message.maxResultSize.high)))
//                     return "maxResultSize: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ContractCallLocalQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery
//          */
//         ContractCallLocalQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractCallLocalQuery)
//                 return object;
//             let message = new $root.proto.ContractCallLocalQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractCallLocalQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractCallLocalQuery.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.gas != null)
//                 if ($util.Long)
//                     (message.gas = $util.Long.fromValue(object.gas)).unsigned = false;
//                 else if (typeof object.gas === "string")
//                     message.gas = parseInt(object.gas, 10);
//                 else if (typeof object.gas === "number")
//                     message.gas = object.gas;
//                 else if (typeof object.gas === "object")
//                     message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber();
//             if (object.functionParameters != null)
//                 if (typeof object.functionParameters === "string")
//                     $util.base64.decode(object.functionParameters, message.functionParameters = $util.newBuffer($util.base64.length(object.functionParameters)), 0);
//                 else if (object.functionParameters.length)
//                     message.functionParameters = object.functionParameters;
//             if (object.maxResultSize != null)
//                 if ($util.Long)
//                     (message.maxResultSize = $util.Long.fromValue(object.maxResultSize)).unsigned = false;
//                 else if (typeof object.maxResultSize === "string")
//                     message.maxResultSize = parseInt(object.maxResultSize, 10);
//                 else if (typeof object.maxResultSize === "number")
//                     message.maxResultSize = object.maxResultSize;
//                 else if (typeof object.maxResultSize === "object")
//                     message.maxResultSize = new $util.LongBits(object.maxResultSize.low >>> 0, object.maxResultSize.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractCallLocalQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractCallLocalQuery
//          * @static
//          * @param {proto.ContractCallLocalQuery} message ContractCallLocalQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractCallLocalQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.contractID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.gas = options.longs === String ? "0" : 0;
//                 if (options.bytes === String)
//                     object.functionParameters = "";
//                 else {
//                     object.functionParameters = [];
//                     if (options.bytes !== Array)
//                         object.functionParameters = $util.newBuffer(object.functionParameters);
//                 }
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.maxResultSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.maxResultSize = options.longs === String ? "0" : 0;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.gas != null && message.hasOwnProperty("gas"))
//                 if (typeof message.gas === "number")
//                     object.gas = options.longs === String ? String(message.gas) : message.gas;
//                 else
//                     object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber() : message.gas;
//             if (message.functionParameters != null && message.hasOwnProperty("functionParameters"))
//                 object.functionParameters = options.bytes === String ? $util.base64.encode(message.functionParameters, 0, message.functionParameters.length) : options.bytes === Array ? Array.prototype.slice.call(message.functionParameters) : message.functionParameters;
//             if (message.maxResultSize != null && message.hasOwnProperty("maxResultSize"))
//                 if (typeof message.maxResultSize === "number")
//                     object.maxResultSize = options.longs === String ? String(message.maxResultSize) : message.maxResultSize;
//                 else
//                     object.maxResultSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxResultSize) : options.longs === Number ? new $util.LongBits(message.maxResultSize.low >>> 0, message.maxResultSize.high >>> 0).toNumber() : message.maxResultSize;
//             return object;
//         };
// 
//         /**
//          * Converts this ContractCallLocalQuery to JSON.
//          * @function toJSON
//          * @memberof proto.ContractCallLocalQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractCallLocalQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractCallLocalQuery;
//     })();
// 
//     proto.ContractCallLocalResponse = (function() {
// 
//         /**
//          * Properties of a ContractCallLocalResponse.
//          * @memberof proto
//          * @interface IContractCallLocalResponse
//          * @property {proto.IResponseHeader|null} [header] ContractCallLocalResponse header
//          * @property {proto.IContractFunctionResult|null} [functionResult] ContractCallLocalResponse functionResult
//          */
// 
//         /**
//          * Constructs a new ContractCallLocalResponse.
//          * @memberof proto
//          * @classdesc Represents a ContractCallLocalResponse.
//          * @implements IContractCallLocalResponse
//          * @constructor
//          * @param {proto.IContractCallLocalResponse=} [properties] Properties to set
//          */
//         function ContractCallLocalResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractCallLocalResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.ContractCallLocalResponse
//          * @instance
//          */
//         ContractCallLocalResponse.prototype.header = null;
// 
//         /**
//          * ContractCallLocalResponse functionResult.
//          * @member {proto.IContractFunctionResult|null|undefined} functionResult
//          * @memberof proto.ContractCallLocalResponse
//          * @instance
//          */
//         ContractCallLocalResponse.prototype.functionResult = null;
// 
//         /**
//          * Creates a new ContractCallLocalResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {proto.IContractCallLocalResponse=} [properties] Properties to set
//          * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse instance
//          */
//         ContractCallLocalResponse.create = function create(properties) {
//             return new ContractCallLocalResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractCallLocalResponse message. Does not implicitly {@link proto.ContractCallLocalResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {proto.IContractCallLocalResponse} message ContractCallLocalResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCallLocalResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.functionResult != null && Object.hasOwnProperty.call(message, "functionResult"))
//                 $root.proto.ContractFunctionResult.encode(message.functionResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractCallLocalResponse message, length delimited. Does not implicitly {@link proto.ContractCallLocalResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {proto.IContractCallLocalResponse} message ContractCallLocalResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractCallLocalResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractCallLocalResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCallLocalResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractCallLocalResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.functionResult = $root.proto.ContractFunctionResult.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractCallLocalResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractCallLocalResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractCallLocalResponse message.
//          * @function verify
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractCallLocalResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.functionResult != null && message.hasOwnProperty("functionResult")) {
//                 let error = $root.proto.ContractFunctionResult.verify(message.functionResult);
//                 if (error)
//                     return "functionResult." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractCallLocalResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse
//          */
//         ContractCallLocalResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractCallLocalResponse)
//                 return object;
//             let message = new $root.proto.ContractCallLocalResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractCallLocalResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.functionResult != null) {
//                 if (typeof object.functionResult !== "object")
//                     throw TypeError(".proto.ContractCallLocalResponse.functionResult: object expected");
//                 message.functionResult = $root.proto.ContractFunctionResult.fromObject(object.functionResult);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractCallLocalResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractCallLocalResponse
//          * @static
//          * @param {proto.ContractCallLocalResponse} message ContractCallLocalResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractCallLocalResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.functionResult = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.functionResult != null && message.hasOwnProperty("functionResult"))
//                 object.functionResult = $root.proto.ContractFunctionResult.toObject(message.functionResult, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ContractCallLocalResponse to JSON.
//          * @function toJSON
//          * @memberof proto.ContractCallLocalResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractCallLocalResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractCallLocalResponse;
//     })();
// 
//     proto.ContractGetInfoQuery = (function() {
// 
//         /**
//          * Properties of a ContractGetInfoQuery.
//          * @memberof proto
//          * @interface IContractGetInfoQuery
//          * @property {proto.IQueryHeader|null} [header] ContractGetInfoQuery header
//          * @property {proto.IContractID|null} [contractID] ContractGetInfoQuery contractID
//          */
// 
//         /**
//          * Constructs a new ContractGetInfoQuery.
//          * @memberof proto
//          * @classdesc Represents a ContractGetInfoQuery.
//          * @implements IContractGetInfoQuery
//          * @constructor
//          * @param {proto.IContractGetInfoQuery=} [properties] Properties to set
//          */
//         function ContractGetInfoQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractGetInfoQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.ContractGetInfoQuery
//          * @instance
//          */
//         ContractGetInfoQuery.prototype.header = null;
// 
//         /**
//          * ContractGetInfoQuery contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractGetInfoQuery
//          * @instance
//          */
//         ContractGetInfoQuery.prototype.contractID = null;
// 
//         /**
//          * Creates a new ContractGetInfoQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {proto.IContractGetInfoQuery=} [properties] Properties to set
//          * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery instance
//          */
//         ContractGetInfoQuery.create = function create(properties) {
//             return new ContractGetInfoQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractGetInfoQuery message. Does not implicitly {@link proto.ContractGetInfoQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {proto.IContractGetInfoQuery} message ContractGetInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetInfoQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractGetInfoQuery message, length delimited. Does not implicitly {@link proto.ContractGetInfoQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {proto.IContractGetInfoQuery} message ContractGetInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetInfoQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractGetInfoQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetInfoQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractGetInfoQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractGetInfoQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetInfoQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractGetInfoQuery message.
//          * @function verify
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractGetInfoQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractGetInfoQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery
//          */
//         ContractGetInfoQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractGetInfoQuery)
//                 return object;
//             let message = new $root.proto.ContractGetInfoQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractGetInfoQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractGetInfoQuery.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractGetInfoQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractGetInfoQuery
//          * @static
//          * @param {proto.ContractGetInfoQuery} message ContractGetInfoQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractGetInfoQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.contractID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ContractGetInfoQuery to JSON.
//          * @function toJSON
//          * @memberof proto.ContractGetInfoQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractGetInfoQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractGetInfoQuery;
//     })();
// 
//     proto.ContractGetInfoResponse = (function() {
// 
//         /**
//          * Properties of a ContractGetInfoResponse.
//          * @memberof proto
//          * @interface IContractGetInfoResponse
//          * @property {proto.IResponseHeader|null} [header] ContractGetInfoResponse header
//          * @property {proto.ContractGetInfoResponse.IContractInfo|null} [contractInfo] ContractGetInfoResponse contractInfo
//          */
// 
//         /**
//          * Constructs a new ContractGetInfoResponse.
//          * @memberof proto
//          * @classdesc Represents a ContractGetInfoResponse.
//          * @implements IContractGetInfoResponse
//          * @constructor
//          * @param {proto.IContractGetInfoResponse=} [properties] Properties to set
//          */
//         function ContractGetInfoResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractGetInfoResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.ContractGetInfoResponse
//          * @instance
//          */
//         ContractGetInfoResponse.prototype.header = null;
// 
//         /**
//          * ContractGetInfoResponse contractInfo.
//          * @member {proto.ContractGetInfoResponse.IContractInfo|null|undefined} contractInfo
//          * @memberof proto.ContractGetInfoResponse
//          * @instance
//          */
//         ContractGetInfoResponse.prototype.contractInfo = null;
// 
//         /**
//          * Creates a new ContractGetInfoResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {proto.IContractGetInfoResponse=} [properties] Properties to set
//          * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse instance
//          */
//         ContractGetInfoResponse.create = function create(properties) {
//             return new ContractGetInfoResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractGetInfoResponse message. Does not implicitly {@link proto.ContractGetInfoResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {proto.IContractGetInfoResponse} message ContractGetInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetInfoResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractInfo != null && Object.hasOwnProperty.call(message, "contractInfo"))
//                 $root.proto.ContractGetInfoResponse.ContractInfo.encode(message.contractInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractGetInfoResponse message, length delimited. Does not implicitly {@link proto.ContractGetInfoResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {proto.IContractGetInfoResponse} message ContractGetInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractGetInfoResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetInfoResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractGetInfoResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractGetInfoResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetInfoResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractGetInfoResponse message.
//          * @function verify
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractGetInfoResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.contractInfo != null && message.hasOwnProperty("contractInfo")) {
//                 let error = $root.proto.ContractGetInfoResponse.ContractInfo.verify(message.contractInfo);
//                 if (error)
//                     return "contractInfo." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractGetInfoResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse
//          */
//         ContractGetInfoResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractGetInfoResponse)
//                 return object;
//             let message = new $root.proto.ContractGetInfoResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractGetInfoResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.contractInfo != null) {
//                 if (typeof object.contractInfo !== "object")
//                     throw TypeError(".proto.ContractGetInfoResponse.contractInfo: object expected");
//                 message.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.fromObject(object.contractInfo);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractGetInfoResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractGetInfoResponse
//          * @static
//          * @param {proto.ContractGetInfoResponse} message ContractGetInfoResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractGetInfoResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.contractInfo = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.contractInfo != null && message.hasOwnProperty("contractInfo"))
//                 object.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.toObject(message.contractInfo, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ContractGetInfoResponse to JSON.
//          * @function toJSON
//          * @memberof proto.ContractGetInfoResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractGetInfoResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         ContractGetInfoResponse.ContractInfo = (function() {
// 
//             /**
//              * Properties of a ContractInfo.
//              * @memberof proto.ContractGetInfoResponse
//              * @interface IContractInfo
//              * @property {proto.IContractID|null} [contractID] ContractInfo contractID
//              * @property {proto.IAccountID|null} [accountID] ContractInfo accountID
//              * @property {string|null} [contractAccountID] ContractInfo contractAccountID
//              * @property {proto.IKey|null} [adminKey] ContractInfo adminKey
//              * @property {proto.ITimestamp|null} [expirationTime] ContractInfo expirationTime
//              * @property {proto.IDuration|null} [autoRenewPeriod] ContractInfo autoRenewPeriod
//              * @property {number|Long|null} [storage] ContractInfo storage
//              * @property {string|null} [memo] ContractInfo memo
//              * @property {number|Long|null} [balance] ContractInfo balance
//              */
// 
//             /**
//              * Constructs a new ContractInfo.
//              * @memberof proto.ContractGetInfoResponse
//              * @classdesc Represents a ContractInfo.
//              * @implements IContractInfo
//              * @constructor
//              * @param {proto.ContractGetInfoResponse.IContractInfo=} [properties] Properties to set
//              */
//             function ContractInfo(properties) {
//                 if (properties)
//                     for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                         if (properties[keys[i]] != null)
//                             this[keys[i]] = properties[keys[i]];
//             }
// 
//             /**
//              * ContractInfo contractID.
//              * @member {proto.IContractID|null|undefined} contractID
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.contractID = null;
// 
//             /**
//              * ContractInfo accountID.
//              * @member {proto.IAccountID|null|undefined} accountID
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.accountID = null;
// 
//             /**
//              * ContractInfo contractAccountID.
//              * @member {string} contractAccountID
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.contractAccountID = "";
// 
//             /**
//              * ContractInfo adminKey.
//              * @member {proto.IKey|null|undefined} adminKey
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.adminKey = null;
// 
//             /**
//              * ContractInfo expirationTime.
//              * @member {proto.ITimestamp|null|undefined} expirationTime
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.expirationTime = null;
// 
//             /**
//              * ContractInfo autoRenewPeriod.
//              * @member {proto.IDuration|null|undefined} autoRenewPeriod
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.autoRenewPeriod = null;
// 
//             /**
//              * ContractInfo storage.
//              * @member {number|Long} storage
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.storage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//             /**
//              * ContractInfo memo.
//              * @member {string} memo
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.memo = "";
// 
//             /**
//              * ContractInfo balance.
//              * @member {number|Long} balance
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              */
//             ContractInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//             /**
//              * Creates a new ContractInfo instance using the specified properties.
//              * @function create
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {proto.ContractGetInfoResponse.IContractInfo=} [properties] Properties to set
//              * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo instance
//              */
//             ContractInfo.create = function create(properties) {
//                 return new ContractInfo(properties);
//             };
// 
//             /**
//              * Encodes the specified ContractInfo message. Does not implicitly {@link proto.ContractGetInfoResponse.ContractInfo.verify|verify} messages.
//              * @function encode
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {proto.ContractGetInfoResponse.IContractInfo} message ContractInfo message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             ContractInfo.encode = function encode(message, writer) {
//                 if (!writer)
//                     writer = $Writer.create();
//                 if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                     $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//                 if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                     $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//                 if (message.contractAccountID != null && Object.hasOwnProperty.call(message, "contractAccountID"))
//                     writer.uint32(/* id 3, wireType 2 =*/26).string(message.contractAccountID);
//                 if (message.adminKey != null && Object.hasOwnProperty.call(message, "adminKey"))
//                     $root.proto.Key.encode(message.adminKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//                 if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                     $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//                 if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                     $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//                 if (message.storage != null && Object.hasOwnProperty.call(message, "storage"))
//                     writer.uint32(/* id 7, wireType 0 =*/56).int64(message.storage);
//                 if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                     writer.uint32(/* id 8, wireType 2 =*/66).string(message.memo);
//                 if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
//                     writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.balance);
//                 return writer;
//             };
// 
//             /**
//              * Encodes the specified ContractInfo message, length delimited. Does not implicitly {@link proto.ContractGetInfoResponse.ContractInfo.verify|verify} messages.
//              * @function encodeDelimited
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {proto.ContractGetInfoResponse.IContractInfo} message ContractInfo message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             ContractInfo.encodeDelimited = function encodeDelimited(message, writer) {
//                 return this.encode(message, writer).ldelim();
//             };
// 
//             /**
//              * Decodes a ContractInfo message from the specified reader or buffer.
//              * @function decode
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @param {number} [length] Message length if known beforehand
//              * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             ContractInfo.decode = function decode(reader, length) {
//                 if (!(reader instanceof $Reader))
//                     reader = $Reader.create(reader);
//                 let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractGetInfoResponse.ContractInfo();
//                 while (reader.pos < end) {
//                     let tag = reader.uint32();
//                     switch (tag >>> 3) {
//                     case 1:
//                         message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                         break;
//                     case 2:
//                         message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                         break;
//                     case 3:
//                         message.contractAccountID = reader.string();
//                         break;
//                     case 4:
//                         message.adminKey = $root.proto.Key.decode(reader, reader.uint32());
//                         break;
//                     case 5:
//                         message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                         break;
//                     case 6:
//                         message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                         break;
//                     case 7:
//                         message.storage = reader.int64();
//                         break;
//                     case 8:
//                         message.memo = reader.string();
//                         break;
//                     case 9:
//                         message.balance = reader.uint64();
//                         break;
//                     default:
//                         reader.skipType(tag & 7);
//                         break;
//                     }
//                 }
//                 return message;
//             };
// 
//             /**
//              * Decodes a ContractInfo message from the specified reader or buffer, length delimited.
//              * @function decodeDelimited
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             ContractInfo.decodeDelimited = function decodeDelimited(reader) {
//                 if (!(reader instanceof $Reader))
//                     reader = new $Reader(reader);
//                 return this.decode(reader, reader.uint32());
//             };
// 
//             /**
//              * Verifies a ContractInfo message.
//              * @function verify
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {Object.<string,*>} message Plain object to verify
//              * @returns {string|null} `null` if valid, otherwise the reason why it is not
//              */
//             ContractInfo.verify = function verify(message) {
//                 if (typeof message !== "object" || message === null)
//                     return "object expected";
//                 if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                     let error = $root.proto.ContractID.verify(message.contractID);
//                     if (error)
//                         return "contractID." + error;
//                 }
//                 if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                     let error = $root.proto.AccountID.verify(message.accountID);
//                     if (error)
//                         return "accountID." + error;
//                 }
//                 if (message.contractAccountID != null && message.hasOwnProperty("contractAccountID"))
//                     if (!$util.isString(message.contractAccountID))
//                         return "contractAccountID: string expected";
//                 if (message.adminKey != null && message.hasOwnProperty("adminKey")) {
//                     let error = $root.proto.Key.verify(message.adminKey);
//                     if (error)
//                         return "adminKey." + error;
//                 }
//                 if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                     let error = $root.proto.Timestamp.verify(message.expirationTime);
//                     if (error)
//                         return "expirationTime." + error;
//                 }
//                 if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                     let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                     if (error)
//                         return "autoRenewPeriod." + error;
//                 }
//                 if (message.storage != null && message.hasOwnProperty("storage"))
//                     if (!$util.isInteger(message.storage) && !(message.storage && $util.isInteger(message.storage.low) && $util.isInteger(message.storage.high)))
//                         return "storage: integer|Long expected";
//                 if (message.memo != null && message.hasOwnProperty("memo"))
//                     if (!$util.isString(message.memo))
//                         return "memo: string expected";
//                 if (message.balance != null && message.hasOwnProperty("balance"))
//                     if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
//                         return "balance: integer|Long expected";
//                 return null;
//             };
// 
//             /**
//              * Creates a ContractInfo message from a plain object. Also converts values to their respective internal types.
//              * @function fromObject
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {Object.<string,*>} object Plain object
//              * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo
//              */
//             ContractInfo.fromObject = function fromObject(object) {
//                 if (object instanceof $root.proto.ContractGetInfoResponse.ContractInfo)
//                     return object;
//                 let message = new $root.proto.ContractGetInfoResponse.ContractInfo();
//                 if (object.contractID != null) {
//                     if (typeof object.contractID !== "object")
//                         throw TypeError(".proto.ContractGetInfoResponse.ContractInfo.contractID: object expected");
//                     message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//                 }
//                 if (object.accountID != null) {
//                     if (typeof object.accountID !== "object")
//                         throw TypeError(".proto.ContractGetInfoResponse.ContractInfo.accountID: object expected");
//                     message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//                 }
//                 if (object.contractAccountID != null)
//                     message.contractAccountID = String(object.contractAccountID);
//                 if (object.adminKey != null) {
//                     if (typeof object.adminKey !== "object")
//                         throw TypeError(".proto.ContractGetInfoResponse.ContractInfo.adminKey: object expected");
//                     message.adminKey = $root.proto.Key.fromObject(object.adminKey);
//                 }
//                 if (object.expirationTime != null) {
//                     if (typeof object.expirationTime !== "object")
//                         throw TypeError(".proto.ContractGetInfoResponse.ContractInfo.expirationTime: object expected");
//                     message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//                 }
//                 if (object.autoRenewPeriod != null) {
//                     if (typeof object.autoRenewPeriod !== "object")
//                         throw TypeError(".proto.ContractGetInfoResponse.ContractInfo.autoRenewPeriod: object expected");
//                     message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//                 }
//                 if (object.storage != null)
//                     if ($util.Long)
//                         (message.storage = $util.Long.fromValue(object.storage)).unsigned = false;
//                     else if (typeof object.storage === "string")
//                         message.storage = parseInt(object.storage, 10);
//                     else if (typeof object.storage === "number")
//                         message.storage = object.storage;
//                     else if (typeof object.storage === "object")
//                         message.storage = new $util.LongBits(object.storage.low >>> 0, object.storage.high >>> 0).toNumber();
//                 if (object.memo != null)
//                     message.memo = String(object.memo);
//                 if (object.balance != null)
//                     if ($util.Long)
//                         (message.balance = $util.Long.fromValue(object.balance)).unsigned = true;
//                     else if (typeof object.balance === "string")
//                         message.balance = parseInt(object.balance, 10);
//                     else if (typeof object.balance === "number")
//                         message.balance = object.balance;
//                     else if (typeof object.balance === "object")
//                         message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber(true);
//                 return message;
//             };
// 
//             /**
//              * Creates a plain object from a ContractInfo message. Also converts values to other types if specified.
//              * @function toObject
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @static
//              * @param {proto.ContractGetInfoResponse.ContractInfo} message ContractInfo
//              * @param {$protobuf.IConversionOptions} [options] Conversion options
//              * @returns {Object.<string,*>} Plain object
//              */
//             ContractInfo.toObject = function toObject(message, options) {
//                 if (!options)
//                     options = {};
//                 let object = {};
//                 if (options.defaults) {
//                     object.contractID = null;
//                     object.accountID = null;
//                     object.contractAccountID = "";
//                     object.adminKey = null;
//                     object.expirationTime = null;
//                     object.autoRenewPeriod = null;
//                     if ($util.Long) {
//                         let long = new $util.Long(0, 0, false);
//                         object.storage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                     } else
//                         object.storage = options.longs === String ? "0" : 0;
//                     object.memo = "";
//                     if ($util.Long) {
//                         let long = new $util.Long(0, 0, true);
//                         object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                     } else
//                         object.balance = options.longs === String ? "0" : 0;
//                 }
//                 if (message.contractID != null && message.hasOwnProperty("contractID"))
//                     object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//                 if (message.accountID != null && message.hasOwnProperty("accountID"))
//                     object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//                 if (message.contractAccountID != null && message.hasOwnProperty("contractAccountID"))
//                     object.contractAccountID = message.contractAccountID;
//                 if (message.adminKey != null && message.hasOwnProperty("adminKey"))
//                     object.adminKey = $root.proto.Key.toObject(message.adminKey, options);
//                 if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                     object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//                 if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                     object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//                 if (message.storage != null && message.hasOwnProperty("storage"))
//                     if (typeof message.storage === "number")
//                         object.storage = options.longs === String ? String(message.storage) : message.storage;
//                     else
//                         object.storage = options.longs === String ? $util.Long.prototype.toString.call(message.storage) : options.longs === Number ? new $util.LongBits(message.storage.low >>> 0, message.storage.high >>> 0).toNumber() : message.storage;
//                 if (message.memo != null && message.hasOwnProperty("memo"))
//                     object.memo = message.memo;
//                 if (message.balance != null && message.hasOwnProperty("balance"))
//                     if (typeof message.balance === "number")
//                         object.balance = options.longs === String ? String(message.balance) : message.balance;
//                     else
//                         object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber(true) : message.balance;
//                 return object;
//             };
// 
//             /**
//              * Converts this ContractInfo to JSON.
//              * @function toJSON
//              * @memberof proto.ContractGetInfoResponse.ContractInfo
//              * @instance
//              * @returns {Object.<string,*>} JSON object
//              */
//             ContractInfo.prototype.toJSON = function toJSON() {
//                 return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//             };
// 
//             return ContractInfo;
//         })();
// 
//         return ContractGetInfoResponse;
//     })();
// 
//     proto.ContractGetBytecodeQuery = (function() {
// 
//         /**
//          * Properties of a ContractGetBytecodeQuery.
//          * @memberof proto
//          * @interface IContractGetBytecodeQuery
//          * @property {proto.IQueryHeader|null} [header] ContractGetBytecodeQuery header
//          * @property {proto.IContractID|null} [contractID] ContractGetBytecodeQuery contractID
//          */
// 
//         /**
//          * Constructs a new ContractGetBytecodeQuery.
//          * @memberof proto
//          * @classdesc Represents a ContractGetBytecodeQuery.
//          * @implements IContractGetBytecodeQuery
//          * @constructor
//          * @param {proto.IContractGetBytecodeQuery=} [properties] Properties to set
//          */
//         function ContractGetBytecodeQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractGetBytecodeQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.ContractGetBytecodeQuery
//          * @instance
//          */
//         ContractGetBytecodeQuery.prototype.header = null;
// 
//         /**
//          * ContractGetBytecodeQuery contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractGetBytecodeQuery
//          * @instance
//          */
//         ContractGetBytecodeQuery.prototype.contractID = null;
// 
//         /**
//          * Creates a new ContractGetBytecodeQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {proto.IContractGetBytecodeQuery=} [properties] Properties to set
//          * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery instance
//          */
//         ContractGetBytecodeQuery.create = function create(properties) {
//             return new ContractGetBytecodeQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractGetBytecodeQuery message. Does not implicitly {@link proto.ContractGetBytecodeQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {proto.IContractGetBytecodeQuery} message ContractGetBytecodeQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetBytecodeQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractGetBytecodeQuery message, length delimited. Does not implicitly {@link proto.ContractGetBytecodeQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {proto.IContractGetBytecodeQuery} message ContractGetBytecodeQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetBytecodeQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractGetBytecodeQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetBytecodeQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractGetBytecodeQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractGetBytecodeQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetBytecodeQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractGetBytecodeQuery message.
//          * @function verify
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractGetBytecodeQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractGetBytecodeQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery
//          */
//         ContractGetBytecodeQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractGetBytecodeQuery)
//                 return object;
//             let message = new $root.proto.ContractGetBytecodeQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractGetBytecodeQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractGetBytecodeQuery.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractGetBytecodeQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractGetBytecodeQuery
//          * @static
//          * @param {proto.ContractGetBytecodeQuery} message ContractGetBytecodeQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractGetBytecodeQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.contractID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ContractGetBytecodeQuery to JSON.
//          * @function toJSON
//          * @memberof proto.ContractGetBytecodeQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractGetBytecodeQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractGetBytecodeQuery;
//     })();
// 
//     proto.ContractGetBytecodeResponse = (function() {
// 
//         /**
//          * Properties of a ContractGetBytecodeResponse.
//          * @memberof proto
//          * @interface IContractGetBytecodeResponse
//          * @property {proto.IResponseHeader|null} [header] ContractGetBytecodeResponse header
//          * @property {Uint8Array|null} [bytecode] ContractGetBytecodeResponse bytecode
//          */
// 
//         /**
//          * Constructs a new ContractGetBytecodeResponse.
//          * @memberof proto
//          * @classdesc Represents a ContractGetBytecodeResponse.
//          * @implements IContractGetBytecodeResponse
//          * @constructor
//          * @param {proto.IContractGetBytecodeResponse=} [properties] Properties to set
//          */
//         function ContractGetBytecodeResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractGetBytecodeResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.ContractGetBytecodeResponse
//          * @instance
//          */
//         ContractGetBytecodeResponse.prototype.header = null;
// 
//         /**
//          * ContractGetBytecodeResponse bytecode.
//          * @member {Uint8Array} bytecode
//          * @memberof proto.ContractGetBytecodeResponse
//          * @instance
//          */
//         ContractGetBytecodeResponse.prototype.bytecode = $util.newBuffer([]);
// 
//         /**
//          * Creates a new ContractGetBytecodeResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {proto.IContractGetBytecodeResponse=} [properties] Properties to set
//          * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse instance
//          */
//         ContractGetBytecodeResponse.create = function create(properties) {
//             return new ContractGetBytecodeResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractGetBytecodeResponse message. Does not implicitly {@link proto.ContractGetBytecodeResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {proto.IContractGetBytecodeResponse} message ContractGetBytecodeResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetBytecodeResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.bytecode != null && Object.hasOwnProperty.call(message, "bytecode"))
//                 writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.bytecode);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractGetBytecodeResponse message, length delimited. Does not implicitly {@link proto.ContractGetBytecodeResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {proto.IContractGetBytecodeResponse} message ContractGetBytecodeResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetBytecodeResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractGetBytecodeResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetBytecodeResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractGetBytecodeResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.bytecode = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractGetBytecodeResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetBytecodeResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractGetBytecodeResponse message.
//          * @function verify
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractGetBytecodeResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.bytecode != null && message.hasOwnProperty("bytecode"))
//                 if (!(message.bytecode && typeof message.bytecode.length === "number" || $util.isString(message.bytecode)))
//                     return "bytecode: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ContractGetBytecodeResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse
//          */
//         ContractGetBytecodeResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractGetBytecodeResponse)
//                 return object;
//             let message = new $root.proto.ContractGetBytecodeResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractGetBytecodeResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.bytecode != null)
//                 if (typeof object.bytecode === "string")
//                     $util.base64.decode(object.bytecode, message.bytecode = $util.newBuffer($util.base64.length(object.bytecode)), 0);
//                 else if (object.bytecode.length)
//                     message.bytecode = object.bytecode;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractGetBytecodeResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractGetBytecodeResponse
//          * @static
//          * @param {proto.ContractGetBytecodeResponse} message ContractGetBytecodeResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractGetBytecodeResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 if (options.bytes === String)
//                     object.bytecode = "";
//                 else {
//                     object.bytecode = [];
//                     if (options.bytes !== Array)
//                         object.bytecode = $util.newBuffer(object.bytecode);
//                 }
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.bytecode != null && message.hasOwnProperty("bytecode"))
//                 object.bytecode = options.bytes === String ? $util.base64.encode(message.bytecode, 0, message.bytecode.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytecode) : message.bytecode;
//             return object;
//         };
// 
//         /**
//          * Converts this ContractGetBytecodeResponse to JSON.
//          * @function toJSON
//          * @memberof proto.ContractGetBytecodeResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractGetBytecodeResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractGetBytecodeResponse;
//     })();
// 
//     proto.ContractGetRecordsQuery = (function() {
// 
//         /**
//          * Properties of a ContractGetRecordsQuery.
//          * @memberof proto
//          * @interface IContractGetRecordsQuery
//          * @property {proto.IQueryHeader|null} [header] ContractGetRecordsQuery header
//          * @property {proto.IContractID|null} [contractID] ContractGetRecordsQuery contractID
//          */
// 
//         /**
//          * Constructs a new ContractGetRecordsQuery.
//          * @memberof proto
//          * @classdesc Represents a ContractGetRecordsQuery.
//          * @implements IContractGetRecordsQuery
//          * @constructor
//          * @param {proto.IContractGetRecordsQuery=} [properties] Properties to set
//          */
//         function ContractGetRecordsQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractGetRecordsQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.ContractGetRecordsQuery
//          * @instance
//          */
//         ContractGetRecordsQuery.prototype.header = null;
// 
//         /**
//          * ContractGetRecordsQuery contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractGetRecordsQuery
//          * @instance
//          */
//         ContractGetRecordsQuery.prototype.contractID = null;
// 
//         /**
//          * Creates a new ContractGetRecordsQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {proto.IContractGetRecordsQuery=} [properties] Properties to set
//          * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery instance
//          */
//         ContractGetRecordsQuery.create = function create(properties) {
//             return new ContractGetRecordsQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractGetRecordsQuery message. Does not implicitly {@link proto.ContractGetRecordsQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {proto.IContractGetRecordsQuery} message ContractGetRecordsQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetRecordsQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractGetRecordsQuery message, length delimited. Does not implicitly {@link proto.ContractGetRecordsQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {proto.IContractGetRecordsQuery} message ContractGetRecordsQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetRecordsQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractGetRecordsQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetRecordsQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractGetRecordsQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractGetRecordsQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetRecordsQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractGetRecordsQuery message.
//          * @function verify
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractGetRecordsQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractGetRecordsQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery
//          */
//         ContractGetRecordsQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractGetRecordsQuery)
//                 return object;
//             let message = new $root.proto.ContractGetRecordsQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractGetRecordsQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractGetRecordsQuery.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractGetRecordsQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractGetRecordsQuery
//          * @static
//          * @param {proto.ContractGetRecordsQuery} message ContractGetRecordsQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractGetRecordsQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.contractID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ContractGetRecordsQuery to JSON.
//          * @function toJSON
//          * @memberof proto.ContractGetRecordsQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractGetRecordsQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractGetRecordsQuery;
//     })();
// 
//     proto.ContractGetRecordsResponse = (function() {
// 
//         /**
//          * Properties of a ContractGetRecordsResponse.
//          * @memberof proto
//          * @interface IContractGetRecordsResponse
//          * @property {proto.IResponseHeader|null} [header] ContractGetRecordsResponse header
//          * @property {proto.IContractID|null} [contractID] ContractGetRecordsResponse contractID
//          * @property {Array.<proto.ITransactionRecord>|null} [records] ContractGetRecordsResponse records
//          */
// 
//         /**
//          * Constructs a new ContractGetRecordsResponse.
//          * @memberof proto
//          * @classdesc Represents a ContractGetRecordsResponse.
//          * @implements IContractGetRecordsResponse
//          * @constructor
//          * @param {proto.IContractGetRecordsResponse=} [properties] Properties to set
//          */
//         function ContractGetRecordsResponse(properties) {
//             this.records = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ContractGetRecordsResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.ContractGetRecordsResponse
//          * @instance
//          */
//         ContractGetRecordsResponse.prototype.header = null;
// 
//         /**
//          * ContractGetRecordsResponse contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.ContractGetRecordsResponse
//          * @instance
//          */
//         ContractGetRecordsResponse.prototype.contractID = null;
// 
//         /**
//          * ContractGetRecordsResponse records.
//          * @member {Array.<proto.ITransactionRecord>} records
//          * @memberof proto.ContractGetRecordsResponse
//          * @instance
//          */
//         ContractGetRecordsResponse.prototype.records = $util.emptyArray;
// 
//         /**
//          * Creates a new ContractGetRecordsResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {proto.IContractGetRecordsResponse=} [properties] Properties to set
//          * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse instance
//          */
//         ContractGetRecordsResponse.create = function create(properties) {
//             return new ContractGetRecordsResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified ContractGetRecordsResponse message. Does not implicitly {@link proto.ContractGetRecordsResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {proto.IContractGetRecordsResponse} message ContractGetRecordsResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetRecordsResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.records != null && message.records.length)
//                 for (let i = 0; i < message.records.length; ++i)
//                     $root.proto.TransactionRecord.encode(message.records[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ContractGetRecordsResponse message, length delimited. Does not implicitly {@link proto.ContractGetRecordsResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {proto.IContractGetRecordsResponse} message ContractGetRecordsResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ContractGetRecordsResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ContractGetRecordsResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetRecordsResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractGetRecordsResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     if (!(message.records && message.records.length))
//                         message.records = [];
//                     message.records.push($root.proto.TransactionRecord.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ContractGetRecordsResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ContractGetRecordsResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ContractGetRecordsResponse message.
//          * @function verify
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ContractGetRecordsResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.records != null && message.hasOwnProperty("records")) {
//                 if (!Array.isArray(message.records))
//                     return "records: array expected";
//                 for (let i = 0; i < message.records.length; ++i) {
//                     let error = $root.proto.TransactionRecord.verify(message.records[i]);
//                     if (error)
//                         return "records." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a ContractGetRecordsResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse
//          */
//         ContractGetRecordsResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ContractGetRecordsResponse)
//                 return object;
//             let message = new $root.proto.ContractGetRecordsResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.ContractGetRecordsResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.ContractGetRecordsResponse.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.records) {
//                 if (!Array.isArray(object.records))
//                     throw TypeError(".proto.ContractGetRecordsResponse.records: array expected");
//                 message.records = [];
//                 for (let i = 0; i < object.records.length; ++i) {
//                     if (typeof object.records[i] !== "object")
//                         throw TypeError(".proto.ContractGetRecordsResponse.records: object expected");
//                     message.records[i] = $root.proto.TransactionRecord.fromObject(object.records[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ContractGetRecordsResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ContractGetRecordsResponse
//          * @static
//          * @param {proto.ContractGetRecordsResponse} message ContractGetRecordsResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ContractGetRecordsResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.records = [];
//             if (options.defaults) {
//                 object.header = null;
//                 object.contractID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.records && message.records.length) {
//                 object.records = [];
//                 for (let j = 0; j < message.records.length; ++j)
//                     object.records[j] = $root.proto.TransactionRecord.toObject(message.records[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this ContractGetRecordsResponse to JSON.
//          * @function toJSON
//          * @memberof proto.ContractGetRecordsResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ContractGetRecordsResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ContractGetRecordsResponse;
//     })();
// 
//     proto.TransactionRecord = (function() {
// 
//         /**
//          * Properties of a TransactionRecord.
//          * @memberof proto
//          * @interface ITransactionRecord
//          * @property {proto.ITransactionReceipt|null} [receipt] TransactionRecord receipt
//          * @property {Uint8Array|null} [transactionHash] TransactionRecord transactionHash
//          * @property {proto.ITimestamp|null} [consensusTimestamp] TransactionRecord consensusTimestamp
//          * @property {proto.ITransactionID|null} [transactionID] TransactionRecord transactionID
//          * @property {string|null} [memo] TransactionRecord memo
//          * @property {number|Long|null} [transactionFee] TransactionRecord transactionFee
//          * @property {proto.IContractFunctionResult|null} [contractCallResult] TransactionRecord contractCallResult
//          * @property {proto.IContractFunctionResult|null} [contractCreateResult] TransactionRecord contractCreateResult
//          * @property {proto.ITransferList|null} [transferList] TransactionRecord transferList
//          */
// 
//         /**
//          * Constructs a new TransactionRecord.
//          * @memberof proto
//          * @classdesc Represents a TransactionRecord.
//          * @implements ITransactionRecord
//          * @constructor
//          * @param {proto.ITransactionRecord=} [properties] Properties to set
//          */
//         function TransactionRecord(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionRecord receipt.
//          * @member {proto.ITransactionReceipt|null|undefined} receipt
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.receipt = null;
// 
//         /**
//          * TransactionRecord transactionHash.
//          * @member {Uint8Array} transactionHash
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.transactionHash = $util.newBuffer([]);
// 
//         /**
//          * TransactionRecord consensusTimestamp.
//          * @member {proto.ITimestamp|null|undefined} consensusTimestamp
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.consensusTimestamp = null;
// 
//         /**
//          * TransactionRecord transactionID.
//          * @member {proto.ITransactionID|null|undefined} transactionID
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.transactionID = null;
// 
//         /**
//          * TransactionRecord memo.
//          * @member {string} memo
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.memo = "";
// 
//         /**
//          * TransactionRecord transactionFee.
//          * @member {number|Long} transactionFee
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * TransactionRecord contractCallResult.
//          * @member {proto.IContractFunctionResult|null|undefined} contractCallResult
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.contractCallResult = null;
// 
//         /**
//          * TransactionRecord contractCreateResult.
//          * @member {proto.IContractFunctionResult|null|undefined} contractCreateResult
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.contractCreateResult = null;
// 
//         /**
//          * TransactionRecord transferList.
//          * @member {proto.ITransferList|null|undefined} transferList
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         TransactionRecord.prototype.transferList = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * TransactionRecord body.
//          * @member {"contractCallResult"|"contractCreateResult"|undefined} body
//          * @memberof proto.TransactionRecord
//          * @instance
//          */
//         Object.defineProperty(TransactionRecord.prototype, "body", {
//             get: $util.oneOfGetter($oneOfFields = ["contractCallResult", "contractCreateResult"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new TransactionRecord instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {proto.ITransactionRecord=} [properties] Properties to set
//          * @returns {proto.TransactionRecord} TransactionRecord instance
//          */
//         TransactionRecord.create = function create(properties) {
//             return new TransactionRecord(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionRecord message. Does not implicitly {@link proto.TransactionRecord.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {proto.ITransactionRecord} message TransactionRecord message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionRecord.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
//                 $root.proto.TransactionReceipt.encode(message.receipt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.transactionHash != null && Object.hasOwnProperty.call(message, "transactionHash"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.transactionHash);
//             if (message.consensusTimestamp != null && Object.hasOwnProperty.call(message, "consensusTimestamp"))
//                 $root.proto.Timestamp.encode(message.consensusTimestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.transactionID != null && Object.hasOwnProperty.call(message, "transactionID"))
//                 $root.proto.TransactionID.encode(message.transactionID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
//                 writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
//             if (message.transactionFee != null && Object.hasOwnProperty.call(message, "transactionFee"))
//                 writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.transactionFee);
//             if (message.contractCallResult != null && Object.hasOwnProperty.call(message, "contractCallResult"))
//                 $root.proto.ContractFunctionResult.encode(message.contractCallResult, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             if (message.contractCreateResult != null && Object.hasOwnProperty.call(message, "contractCreateResult"))
//                 $root.proto.ContractFunctionResult.encode(message.contractCreateResult, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.transferList != null && Object.hasOwnProperty.call(message, "transferList"))
//                 $root.proto.TransferList.encode(message.transferList, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionRecord message, length delimited. Does not implicitly {@link proto.TransactionRecord.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {proto.ITransactionRecord} message TransactionRecord message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionRecord.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionRecord message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionRecord} TransactionRecord
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionRecord.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionRecord();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.receipt = $root.proto.TransactionReceipt.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.transactionHash = reader.bytes();
//                     break;
//                 case 3:
//                     message.consensusTimestamp = $root.proto.Timestamp.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.transactionID = $root.proto.TransactionID.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.memo = reader.string();
//                     break;
//                 case 6:
//                     message.transactionFee = reader.uint64();
//                     break;
//                 case 7:
//                     message.contractCallResult = $root.proto.ContractFunctionResult.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.contractCreateResult = $root.proto.ContractFunctionResult.decode(reader, reader.uint32());
//                     break;
//                 case 10:
//                     message.transferList = $root.proto.TransferList.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionRecord message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionRecord} TransactionRecord
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionRecord.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionRecord message.
//          * @function verify
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionRecord.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.receipt != null && message.hasOwnProperty("receipt")) {
//                 let error = $root.proto.TransactionReceipt.verify(message.receipt);
//                 if (error)
//                     return "receipt." + error;
//             }
//             if (message.transactionHash != null && message.hasOwnProperty("transactionHash"))
//                 if (!(message.transactionHash && typeof message.transactionHash.length === "number" || $util.isString(message.transactionHash)))
//                     return "transactionHash: buffer expected";
//             if (message.consensusTimestamp != null && message.hasOwnProperty("consensusTimestamp")) {
//                 let error = $root.proto.Timestamp.verify(message.consensusTimestamp);
//                 if (error)
//                     return "consensusTimestamp." + error;
//             }
//             if (message.transactionID != null && message.hasOwnProperty("transactionID")) {
//                 let error = $root.proto.TransactionID.verify(message.transactionID);
//                 if (error)
//                     return "transactionID." + error;
//             }
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 if (!$util.isString(message.memo))
//                     return "memo: string expected";
//             if (message.transactionFee != null && message.hasOwnProperty("transactionFee"))
//                 if (!$util.isInteger(message.transactionFee) && !(message.transactionFee && $util.isInteger(message.transactionFee.low) && $util.isInteger(message.transactionFee.high)))
//                     return "transactionFee: integer|Long expected";
//             if (message.contractCallResult != null && message.hasOwnProperty("contractCallResult")) {
//                 properties.body = 1;
//                 {
//                     let error = $root.proto.ContractFunctionResult.verify(message.contractCallResult);
//                     if (error)
//                         return "contractCallResult." + error;
//                 }
//             }
//             if (message.contractCreateResult != null && message.hasOwnProperty("contractCreateResult")) {
//                 if (properties.body === 1)
//                     return "body: multiple values";
//                 properties.body = 1;
//                 {
//                     let error = $root.proto.ContractFunctionResult.verify(message.contractCreateResult);
//                     if (error)
//                         return "contractCreateResult." + error;
//                 }
//             }
//             if (message.transferList != null && message.hasOwnProperty("transferList")) {
//                 let error = $root.proto.TransferList.verify(message.transferList);
//                 if (error)
//                     return "transferList." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionRecord message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionRecord} TransactionRecord
//          */
//         TransactionRecord.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionRecord)
//                 return object;
//             let message = new $root.proto.TransactionRecord();
//             if (object.receipt != null) {
//                 if (typeof object.receipt !== "object")
//                     throw TypeError(".proto.TransactionRecord.receipt: object expected");
//                 message.receipt = $root.proto.TransactionReceipt.fromObject(object.receipt);
//             }
//             if (object.transactionHash != null)
//                 if (typeof object.transactionHash === "string")
//                     $util.base64.decode(object.transactionHash, message.transactionHash = $util.newBuffer($util.base64.length(object.transactionHash)), 0);
//                 else if (object.transactionHash.length)
//                     message.transactionHash = object.transactionHash;
//             if (object.consensusTimestamp != null) {
//                 if (typeof object.consensusTimestamp !== "object")
//                     throw TypeError(".proto.TransactionRecord.consensusTimestamp: object expected");
//                 message.consensusTimestamp = $root.proto.Timestamp.fromObject(object.consensusTimestamp);
//             }
//             if (object.transactionID != null) {
//                 if (typeof object.transactionID !== "object")
//                     throw TypeError(".proto.TransactionRecord.transactionID: object expected");
//                 message.transactionID = $root.proto.TransactionID.fromObject(object.transactionID);
//             }
//             if (object.memo != null)
//                 message.memo = String(object.memo);
//             if (object.transactionFee != null)
//                 if ($util.Long)
//                     (message.transactionFee = $util.Long.fromValue(object.transactionFee)).unsigned = true;
//                 else if (typeof object.transactionFee === "string")
//                     message.transactionFee = parseInt(object.transactionFee, 10);
//                 else if (typeof object.transactionFee === "number")
//                     message.transactionFee = object.transactionFee;
//                 else if (typeof object.transactionFee === "object")
//                     message.transactionFee = new $util.LongBits(object.transactionFee.low >>> 0, object.transactionFee.high >>> 0).toNumber(true);
//             if (object.contractCallResult != null) {
//                 if (typeof object.contractCallResult !== "object")
//                     throw TypeError(".proto.TransactionRecord.contractCallResult: object expected");
//                 message.contractCallResult = $root.proto.ContractFunctionResult.fromObject(object.contractCallResult);
//             }
//             if (object.contractCreateResult != null) {
//                 if (typeof object.contractCreateResult !== "object")
//                     throw TypeError(".proto.TransactionRecord.contractCreateResult: object expected");
//                 message.contractCreateResult = $root.proto.ContractFunctionResult.fromObject(object.contractCreateResult);
//             }
//             if (object.transferList != null) {
//                 if (typeof object.transferList !== "object")
//                     throw TypeError(".proto.TransactionRecord.transferList: object expected");
//                 message.transferList = $root.proto.TransferList.fromObject(object.transferList);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionRecord message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionRecord
//          * @static
//          * @param {proto.TransactionRecord} message TransactionRecord
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionRecord.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.receipt = null;
//                 if (options.bytes === String)
//                     object.transactionHash = "";
//                 else {
//                     object.transactionHash = [];
//                     if (options.bytes !== Array)
//                         object.transactionHash = $util.newBuffer(object.transactionHash);
//                 }
//                 object.consensusTimestamp = null;
//                 object.transactionID = null;
//                 object.memo = "";
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.transactionFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.transactionFee = options.longs === String ? "0" : 0;
//                 object.transferList = null;
//             }
//             if (message.receipt != null && message.hasOwnProperty("receipt"))
//                 object.receipt = $root.proto.TransactionReceipt.toObject(message.receipt, options);
//             if (message.transactionHash != null && message.hasOwnProperty("transactionHash"))
//                 object.transactionHash = options.bytes === String ? $util.base64.encode(message.transactionHash, 0, message.transactionHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.transactionHash) : message.transactionHash;
//             if (message.consensusTimestamp != null && message.hasOwnProperty("consensusTimestamp"))
//                 object.consensusTimestamp = $root.proto.Timestamp.toObject(message.consensusTimestamp, options);
//             if (message.transactionID != null && message.hasOwnProperty("transactionID"))
//                 object.transactionID = $root.proto.TransactionID.toObject(message.transactionID, options);
//             if (message.memo != null && message.hasOwnProperty("memo"))
//                 object.memo = message.memo;
//             if (message.transactionFee != null && message.hasOwnProperty("transactionFee"))
//                 if (typeof message.transactionFee === "number")
//                     object.transactionFee = options.longs === String ? String(message.transactionFee) : message.transactionFee;
//                 else
//                     object.transactionFee = options.longs === String ? $util.Long.prototype.toString.call(message.transactionFee) : options.longs === Number ? new $util.LongBits(message.transactionFee.low >>> 0, message.transactionFee.high >>> 0).toNumber(true) : message.transactionFee;
//             if (message.contractCallResult != null && message.hasOwnProperty("contractCallResult")) {
//                 object.contractCallResult = $root.proto.ContractFunctionResult.toObject(message.contractCallResult, options);
//                 if (options.oneofs)
//                     object.body = "contractCallResult";
//             }
//             if (message.contractCreateResult != null && message.hasOwnProperty("contractCreateResult")) {
//                 object.contractCreateResult = $root.proto.ContractFunctionResult.toObject(message.contractCreateResult, options);
//                 if (options.oneofs)
//                     object.body = "contractCreateResult";
//             }
//             if (message.transferList != null && message.hasOwnProperty("transferList"))
//                 object.transferList = $root.proto.TransferList.toObject(message.transferList, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionRecord to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionRecord
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionRecord.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionRecord;
//     })();
// 
//     proto.TransactionReceipt = (function() {
// 
//         /**
//          * Properties of a TransactionReceipt.
//          * @memberof proto
//          * @interface ITransactionReceipt
//          * @property {proto.ResponseCodeEnum|null} [status] TransactionReceipt status
//          * @property {proto.IAccountID|null} [accountID] TransactionReceipt accountID
//          * @property {proto.IFileID|null} [fileID] TransactionReceipt fileID
//          * @property {proto.IContractID|null} [contractID] TransactionReceipt contractID
//          * @property {proto.IExchangeRateSet|null} [exchangeRate] TransactionReceipt exchangeRate
//          * @property {proto.ITopicID|null} [topicID] TransactionReceipt topicID
//          * @property {number|Long|null} [topicSequenceNumber] TransactionReceipt topicSequenceNumber
//          * @property {Uint8Array|null} [topicRunningHash] TransactionReceipt topicRunningHash
//          * @property {number|Long|null} [topicRunningHashVersion] TransactionReceipt topicRunningHashVersion
//          */
// 
//         /**
//          * Constructs a new TransactionReceipt.
//          * @memberof proto
//          * @classdesc Represents a TransactionReceipt.
//          * @implements ITransactionReceipt
//          * @constructor
//          * @param {proto.ITransactionReceipt=} [properties] Properties to set
//          */
//         function TransactionReceipt(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionReceipt status.
//          * @member {proto.ResponseCodeEnum} status
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.status = 0;
// 
//         /**
//          * TransactionReceipt accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.accountID = null;
// 
//         /**
//          * TransactionReceipt fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.fileID = null;
// 
//         /**
//          * TransactionReceipt contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.contractID = null;
// 
//         /**
//          * TransactionReceipt exchangeRate.
//          * @member {proto.IExchangeRateSet|null|undefined} exchangeRate
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.exchangeRate = null;
// 
//         /**
//          * TransactionReceipt topicID.
//          * @member {proto.ITopicID|null|undefined} topicID
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.topicID = null;
// 
//         /**
//          * TransactionReceipt topicSequenceNumber.
//          * @member {number|Long} topicSequenceNumber
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.topicSequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * TransactionReceipt topicRunningHash.
//          * @member {Uint8Array} topicRunningHash
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.topicRunningHash = $util.newBuffer([]);
// 
//         /**
//          * TransactionReceipt topicRunningHashVersion.
//          * @member {number|Long} topicRunningHashVersion
//          * @memberof proto.TransactionReceipt
//          * @instance
//          */
//         TransactionReceipt.prototype.topicRunningHashVersion = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * Creates a new TransactionReceipt instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {proto.ITransactionReceipt=} [properties] Properties to set
//          * @returns {proto.TransactionReceipt} TransactionReceipt instance
//          */
//         TransactionReceipt.create = function create(properties) {
//             return new TransactionReceipt(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionReceipt message. Does not implicitly {@link proto.TransactionReceipt.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {proto.ITransactionReceipt} message TransactionReceipt message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionReceipt.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.status != null && Object.hasOwnProperty.call(message, "status"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.exchangeRate != null && Object.hasOwnProperty.call(message, "exchangeRate"))
//                 $root.proto.ExchangeRateSet.encode(message.exchangeRate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             if (message.topicID != null && Object.hasOwnProperty.call(message, "topicID"))
//                 $root.proto.TopicID.encode(message.topicID, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.topicSequenceNumber != null && Object.hasOwnProperty.call(message, "topicSequenceNumber"))
//                 writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.topicSequenceNumber);
//             if (message.topicRunningHash != null && Object.hasOwnProperty.call(message, "topicRunningHash"))
//                 writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.topicRunningHash);
//             if (message.topicRunningHashVersion != null && Object.hasOwnProperty.call(message, "topicRunningHashVersion"))
//                 writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.topicRunningHashVersion);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionReceipt message, length delimited. Does not implicitly {@link proto.TransactionReceipt.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {proto.ITransactionReceipt} message TransactionReceipt message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionReceipt.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionReceipt message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionReceipt} TransactionReceipt
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionReceipt.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionReceipt();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.status = reader.int32();
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.exchangeRate = $root.proto.ExchangeRateSet.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.topicID = $root.proto.TopicID.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.topicSequenceNumber = reader.uint64();
//                     break;
//                 case 8:
//                     message.topicRunningHash = reader.bytes();
//                     break;
//                 case 9:
//                     message.topicRunningHashVersion = reader.uint64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionReceipt message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionReceipt} TransactionReceipt
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionReceipt.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionReceipt message.
//          * @function verify
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionReceipt.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.status != null && message.hasOwnProperty("status"))
//                 switch (message.status) {
//                 default:
//                     return "status: enum value expected";
//                 case 0:
//                 case 1:
//                 case 2:
//                 case 3:
//                 case 4:
//                 case 5:
//                 case 6:
//                 case 7:
//                 case 8:
//                 case 9:
//                 case 10:
//                 case 11:
//                 case 12:
//                 case 13:
//                 case 14:
//                 case 15:
//                 case 16:
//                 case 17:
//                 case 18:
//                 case 19:
//                 case 20:
//                 case 21:
//                 case 22:
//                 case 23:
//                 case 24:
//                 case 25:
//                 case 26:
//                 case 27:
//                 case 28:
//                 case 29:
//                 case 30:
//                 case 31:
//                 case 32:
//                 case 33:
//                 case 34:
//                 case 35:
//                 case 36:
//                 case 37:
//                 case 38:
//                 case 39:
//                 case 40:
//                 case 41:
//                 case 42:
//                 case 43:
//                 case 44:
//                 case 45:
//                 case 46:
//                 case 47:
//                 case 48:
//                 case 49:
//                 case 50:
//                 case 51:
//                 case 52:
//                 case 53:
//                 case 54:
//                 case 55:
//                 case 56:
//                 case 57:
//                 case 58:
//                 case 59:
//                 case 60:
//                 case 61:
//                 case 62:
//                 case 63:
//                 case 64:
//                 case 65:
//                 case 66:
//                 case 67:
//                 case 68:
//                 case 69:
//                 case 70:
//                 case 71:
//                 case 72:
//                 case 73:
//                 case 74:
//                 case 75:
//                 case 76:
//                 case 77:
//                 case 78:
//                 case 79:
//                 case 80:
//                 case 81:
//                 case 82:
//                 case 83:
//                 case 84:
//                 case 85:
//                 case 86:
//                 case 87:
//                 case 88:
//                 case 89:
//                 case 90:
//                 case 91:
//                 case 92:
//                 case 93:
//                 case 94:
//                 case 95:
//                 case 96:
//                 case 97:
//                 case 98:
//                 case 99:
//                 case 100:
//                 case 101:
//                 case 102:
//                 case 103:
//                 case 104:
//                 case 105:
//                 case 106:
//                 case 107:
//                 case 108:
//                 case 110:
//                 case 111:
//                 case 112:
//                 case 150:
//                 case 155:
//                 case 156:
//                 case 157:
//                 case 158:
//                 case 159:
//                 case 160:
//                 case 162:
//                 case 163:
//                 case 164:
//                     break;
//                 }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 let error = $root.proto.ContractID.verify(message.contractID);
//                 if (error)
//                     return "contractID." + error;
//             }
//             if (message.exchangeRate != null && message.hasOwnProperty("exchangeRate")) {
//                 let error = $root.proto.ExchangeRateSet.verify(message.exchangeRate);
//                 if (error)
//                     return "exchangeRate." + error;
//             }
//             if (message.topicID != null && message.hasOwnProperty("topicID")) {
//                 let error = $root.proto.TopicID.verify(message.topicID);
//                 if (error)
//                     return "topicID." + error;
//             }
//             if (message.topicSequenceNumber != null && message.hasOwnProperty("topicSequenceNumber"))
//                 if (!$util.isInteger(message.topicSequenceNumber) && !(message.topicSequenceNumber && $util.isInteger(message.topicSequenceNumber.low) && $util.isInteger(message.topicSequenceNumber.high)))
//                     return "topicSequenceNumber: integer|Long expected";
//             if (message.topicRunningHash != null && message.hasOwnProperty("topicRunningHash"))
//                 if (!(message.topicRunningHash && typeof message.topicRunningHash.length === "number" || $util.isString(message.topicRunningHash)))
//                     return "topicRunningHash: buffer expected";
//             if (message.topicRunningHashVersion != null && message.hasOwnProperty("topicRunningHashVersion"))
//                 if (!$util.isInteger(message.topicRunningHashVersion) && !(message.topicRunningHashVersion && $util.isInteger(message.topicRunningHashVersion.low) && $util.isInteger(message.topicRunningHashVersion.high)))
//                     return "topicRunningHashVersion: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionReceipt message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionReceipt} TransactionReceipt
//          */
//         TransactionReceipt.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionReceipt)
//                 return object;
//             let message = new $root.proto.TransactionReceipt();
//             switch (object.status) {
//             case "OK":
//             case 0:
//                 message.status = 0;
//                 break;
//             case "INVALID_TRANSACTION":
//             case 1:
//                 message.status = 1;
//                 break;
//             case "PAYER_ACCOUNT_NOT_FOUND":
//             case 2:
//                 message.status = 2;
//                 break;
//             case "INVALID_NODE_ACCOUNT":
//             case 3:
//                 message.status = 3;
//                 break;
//             case "TRANSACTION_EXPIRED":
//             case 4:
//                 message.status = 4;
//                 break;
//             case "INVALID_TRANSACTION_START":
//             case 5:
//                 message.status = 5;
//                 break;
//             case "INVALID_TRANSACTION_DURATION":
//             case 6:
//                 message.status = 6;
//                 break;
//             case "INVALID_SIGNATURE":
//             case 7:
//                 message.status = 7;
//                 break;
//             case "MEMO_TOO_LONG":
//             case 8:
//                 message.status = 8;
//                 break;
//             case "INSUFFICIENT_TX_FEE":
//             case 9:
//                 message.status = 9;
//                 break;
//             case "INSUFFICIENT_PAYER_BALANCE":
//             case 10:
//                 message.status = 10;
//                 break;
//             case "DUPLICATE_TRANSACTION":
//             case 11:
//                 message.status = 11;
//                 break;
//             case "BUSY":
//             case 12:
//                 message.status = 12;
//                 break;
//             case "NOT_SUPPORTED":
//             case 13:
//                 message.status = 13;
//                 break;
//             case "INVALID_FILE_ID":
//             case 14:
//                 message.status = 14;
//                 break;
//             case "INVALID_ACCOUNT_ID":
//             case 15:
//                 message.status = 15;
//                 break;
//             case "INVALID_CONTRACT_ID":
//             case 16:
//                 message.status = 16;
//                 break;
//             case "INVALID_TRANSACTION_ID":
//             case 17:
//                 message.status = 17;
//                 break;
//             case "RECEIPT_NOT_FOUND":
//             case 18:
//                 message.status = 18;
//                 break;
//             case "RECORD_NOT_FOUND":
//             case 19:
//                 message.status = 19;
//                 break;
//             case "INVALID_SOLIDITY_ID":
//             case 20:
//                 message.status = 20;
//                 break;
//             case "UNKNOWN":
//             case 21:
//                 message.status = 21;
//                 break;
//             case "SUCCESS":
//             case 22:
//                 message.status = 22;
//                 break;
//             case "FAIL_INVALID":
//             case 23:
//                 message.status = 23;
//                 break;
//             case "FAIL_FEE":
//             case 24:
//                 message.status = 24;
//                 break;
//             case "FAIL_BALANCE":
//             case 25:
//                 message.status = 25;
//                 break;
//             case "KEY_REQUIRED":
//             case 26:
//                 message.status = 26;
//                 break;
//             case "BAD_ENCODING":
//             case 27:
//                 message.status = 27;
//                 break;
//             case "INSUFFICIENT_ACCOUNT_BALANCE":
//             case 28:
//                 message.status = 28;
//                 break;
//             case "INVALID_SOLIDITY_ADDRESS":
//             case 29:
//                 message.status = 29;
//                 break;
//             case "INSUFFICIENT_GAS":
//             case 30:
//                 message.status = 30;
//                 break;
//             case "CONTRACT_SIZE_LIMIT_EXCEEDED":
//             case 31:
//                 message.status = 31;
//                 break;
//             case "LOCAL_CALL_MODIFICATION_EXCEPTION":
//             case 32:
//                 message.status = 32;
//                 break;
//             case "CONTRACT_REVERT_EXECUTED":
//             case 33:
//                 message.status = 33;
//                 break;
//             case "CONTRACT_EXECUTION_EXCEPTION":
//             case 34:
//                 message.status = 34;
//                 break;
//             case "INVALID_RECEIVING_NODE_ACCOUNT":
//             case 35:
//                 message.status = 35;
//                 break;
//             case "MISSING_QUERY_HEADER":
//             case 36:
//                 message.status = 36;
//                 break;
//             case "ACCOUNT_UPDATE_FAILED":
//             case 37:
//                 message.status = 37;
//                 break;
//             case "INVALID_KEY_ENCODING":
//             case 38:
//                 message.status = 38;
//                 break;
//             case "NULL_SOLIDITY_ADDRESS":
//             case 39:
//                 message.status = 39;
//                 break;
//             case "CONTRACT_UPDATE_FAILED":
//             case 40:
//                 message.status = 40;
//                 break;
//             case "INVALID_QUERY_HEADER":
//             case 41:
//                 message.status = 41;
//                 break;
//             case "INVALID_FEE_SUBMITTED":
//             case 42:
//                 message.status = 42;
//                 break;
//             case "INVALID_PAYER_SIGNATURE":
//             case 43:
//                 message.status = 43;
//                 break;
//             case "KEY_NOT_PROVIDED":
//             case 44:
//                 message.status = 44;
//                 break;
//             case "INVALID_EXPIRATION_TIME":
//             case 45:
//                 message.status = 45;
//                 break;
//             case "NO_WACL_KEY":
//             case 46:
//                 message.status = 46;
//                 break;
//             case "FILE_CONTENT_EMPTY":
//             case 47:
//                 message.status = 47;
//                 break;
//             case "INVALID_ACCOUNT_AMOUNTS":
//             case 48:
//                 message.status = 48;
//                 break;
//             case "EMPTY_TRANSACTION_BODY":
//             case 49:
//                 message.status = 49;
//                 break;
//             case "INVALID_TRANSACTION_BODY":
//             case 50:
//                 message.status = 50;
//                 break;
//             case "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY":
//             case 51:
//                 message.status = 51;
//                 break;
//             case "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY":
//             case 52:
//                 message.status = 52;
//                 break;
//             case "EMPTY_LIVE_HASH_BODY":
//             case 53:
//                 message.status = 53;
//                 break;
//             case "EMPTY_LIVE_HASH":
//             case 54:
//                 message.status = 54;
//                 break;
//             case "EMPTY_LIVE_HASH_KEYS":
//             case 55:
//                 message.status = 55;
//                 break;
//             case "INVALID_LIVE_HASH_SIZE":
//             case 56:
//                 message.status = 56;
//                 break;
//             case "EMPTY_QUERY_BODY":
//             case 57:
//                 message.status = 57;
//                 break;
//             case "EMPTY_LIVE_HASH_QUERY":
//             case 58:
//                 message.status = 58;
//                 break;
//             case "LIVE_HASH_NOT_FOUND":
//             case 59:
//                 message.status = 59;
//                 break;
//             case "ACCOUNT_ID_DOES_NOT_EXIST":
//             case 60:
//                 message.status = 60;
//                 break;
//             case "LIVE_HASH_ALREADY_EXISTS":
//             case 61:
//                 message.status = 61;
//                 break;
//             case "INVALID_FILE_WACL":
//             case 62:
//                 message.status = 62;
//                 break;
//             case "SERIALIZATION_FAILED":
//             case 63:
//                 message.status = 63;
//                 break;
//             case "TRANSACTION_OVERSIZE":
//             case 64:
//                 message.status = 64;
//                 break;
//             case "TRANSACTION_TOO_MANY_LAYERS":
//             case 65:
//                 message.status = 65;
//                 break;
//             case "CONTRACT_DELETED":
//             case 66:
//                 message.status = 66;
//                 break;
//             case "PLATFORM_NOT_ACTIVE":
//             case 67:
//                 message.status = 67;
//                 break;
//             case "KEY_PREFIX_MISMATCH":
//             case 68:
//                 message.status = 68;
//                 break;
//             case "PLATFORM_TRANSACTION_NOT_CREATED":
//             case 69:
//                 message.status = 69;
//                 break;
//             case "INVALID_RENEWAL_PERIOD":
//             case 70:
//                 message.status = 70;
//                 break;
//             case "INVALID_PAYER_ACCOUNT_ID":
//             case 71:
//                 message.status = 71;
//                 break;
//             case "ACCOUNT_DELETED":
//             case 72:
//                 message.status = 72;
//                 break;
//             case "FILE_DELETED":
//             case 73:
//                 message.status = 73;
//                 break;
//             case "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS":
//             case 74:
//                 message.status = 74;
//                 break;
//             case "SETTING_NEGATIVE_ACCOUNT_BALANCE":
//             case 75:
//                 message.status = 75;
//                 break;
//             case "OBTAINER_REQUIRED":
//             case 76:
//                 message.status = 76;
//                 break;
//             case "OBTAINER_SAME_CONTRACT_ID":
//             case 77:
//                 message.status = 77;
//                 break;
//             case "OBTAINER_DOES_NOT_EXIST":
//             case 78:
//                 message.status = 78;
//                 break;
//             case "MODIFYING_IMMUTABLE_CONTRACT":
//             case 79:
//                 message.status = 79;
//                 break;
//             case "FILE_SYSTEM_EXCEPTION":
//             case 80:
//                 message.status = 80;
//                 break;
//             case "AUTORENEW_DURATION_NOT_IN_RANGE":
//             case 81:
//                 message.status = 81;
//                 break;
//             case "ERROR_DECODING_BYTESTRING":
//             case 82:
//                 message.status = 82;
//                 break;
//             case "CONTRACT_FILE_EMPTY":
//             case 83:
//                 message.status = 83;
//                 break;
//             case "CONTRACT_BYTECODE_EMPTY":
//             case 84:
//                 message.status = 84;
//                 break;
//             case "INVALID_INITIAL_BALANCE":
//             case 85:
//                 message.status = 85;
//                 break;
//             case "INVALID_RECEIVE_RECORD_THRESHOLD":
//             case 86:
//                 message.status = 86;
//                 break;
//             case "INVALID_SEND_RECORD_THRESHOLD":
//             case 87:
//                 message.status = 87;
//                 break;
//             case "ACCOUNT_IS_NOT_GENESIS_ACCOUNT":
//             case 88:
//                 message.status = 88;
//                 break;
//             case "PAYER_ACCOUNT_UNAUTHORIZED":
//             case 89:
//                 message.status = 89;
//                 break;
//             case "INVALID_FREEZE_TRANSACTION_BODY":
//             case 90:
//                 message.status = 90;
//                 break;
//             case "FREEZE_TRANSACTION_BODY_NOT_FOUND":
//             case 91:
//                 message.status = 91;
//                 break;
//             case "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED":
//             case 92:
//                 message.status = 92;
//                 break;
//             case "RESULT_SIZE_LIMIT_EXCEEDED":
//             case 93:
//                 message.status = 93;
//                 break;
//             case "NOT_SPECIAL_ACCOUNT":
//             case 94:
//                 message.status = 94;
//                 break;
//             case "CONTRACT_NEGATIVE_GAS":
//             case 95:
//                 message.status = 95;
//                 break;
//             case "CONTRACT_NEGATIVE_VALUE":
//             case 96:
//                 message.status = 96;
//                 break;
//             case "INVALID_FEE_FILE":
//             case 97:
//                 message.status = 97;
//                 break;
//             case "INVALID_EXCHANGE_RATE_FILE":
//             case 98:
//                 message.status = 98;
//                 break;
//             case "INSUFFICIENT_LOCAL_CALL_GAS":
//             case 99:
//                 message.status = 99;
//                 break;
//             case "ENTITY_NOT_ALLOWED_TO_DELETE":
//             case 100:
//                 message.status = 100;
//                 break;
//             case "AUTHORIZATION_FAILED":
//             case 101:
//                 message.status = 101;
//                 break;
//             case "FILE_UPLOADED_PROTO_INVALID":
//             case 102:
//                 message.status = 102;
//                 break;
//             case "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK":
//             case 103:
//                 message.status = 103;
//                 break;
//             case "FEE_SCHEDULE_FILE_PART_UPLOADED":
//             case 104:
//                 message.status = 104;
//                 break;
//             case "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED":
//             case 105:
//                 message.status = 105;
//                 break;
//             case "MAX_CONTRACT_STORAGE_EXCEEDED":
//             case 106:
//                 message.status = 106;
//                 break;
//             case "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT":
//             case 107:
//                 message.status = 107;
//                 break;
//             case "TOTAL_LEDGER_BALANCE_INVALID":
//             case 108:
//                 message.status = 108;
//                 break;
//             case "EXPIRATION_REDUCTION_NOT_ALLOWED":
//             case 110:
//                 message.status = 110;
//                 break;
//             case "MAX_GAS_LIMIT_EXCEEDED":
//             case 111:
//                 message.status = 111;
//                 break;
//             case "MAX_FILE_SIZE_EXCEEDED":
//             case 112:
//                 message.status = 112;
//                 break;
//             case "INVALID_TOPIC_ID":
//             case 150:
//                 message.status = 150;
//                 break;
//             case "INVALID_ADMIN_KEY":
//             case 155:
//                 message.status = 155;
//                 break;
//             case "INVALID_SUBMIT_KEY":
//             case 156:
//                 message.status = 156;
//                 break;
//             case "UNAUTHORIZED":
//             case 157:
//                 message.status = 157;
//                 break;
//             case "INVALID_TOPIC_MESSAGE":
//             case 158:
//                 message.status = 158;
//                 break;
//             case "INVALID_AUTORENEW_ACCOUNT":
//             case 159:
//                 message.status = 159;
//                 break;
//             case "AUTORENEW_ACCOUNT_NOT_ALLOWED":
//             case 160:
//                 message.status = 160;
//                 break;
//             case "TOPIC_EXPIRED":
//             case 162:
//                 message.status = 162;
//                 break;
//             case "INVALID_CHUNK_NUMBER":
//             case 163:
//                 message.status = 163;
//                 break;
//             case "INVALID_CHUNK_TRANSACTION_ID":
//             case 164:
//                 message.status = 164;
//                 break;
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.TransactionReceipt.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.TransactionReceipt.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.TransactionReceipt.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             if (object.exchangeRate != null) {
//                 if (typeof object.exchangeRate !== "object")
//                     throw TypeError(".proto.TransactionReceipt.exchangeRate: object expected");
//                 message.exchangeRate = $root.proto.ExchangeRateSet.fromObject(object.exchangeRate);
//             }
//             if (object.topicID != null) {
//                 if (typeof object.topicID !== "object")
//                     throw TypeError(".proto.TransactionReceipt.topicID: object expected");
//                 message.topicID = $root.proto.TopicID.fromObject(object.topicID);
//             }
//             if (object.topicSequenceNumber != null)
//                 if ($util.Long)
//                     (message.topicSequenceNumber = $util.Long.fromValue(object.topicSequenceNumber)).unsigned = true;
//                 else if (typeof object.topicSequenceNumber === "string")
//                     message.topicSequenceNumber = parseInt(object.topicSequenceNumber, 10);
//                 else if (typeof object.topicSequenceNumber === "number")
//                     message.topicSequenceNumber = object.topicSequenceNumber;
//                 else if (typeof object.topicSequenceNumber === "object")
//                     message.topicSequenceNumber = new $util.LongBits(object.topicSequenceNumber.low >>> 0, object.topicSequenceNumber.high >>> 0).toNumber(true);
//             if (object.topicRunningHash != null)
//                 if (typeof object.topicRunningHash === "string")
//                     $util.base64.decode(object.topicRunningHash, message.topicRunningHash = $util.newBuffer($util.base64.length(object.topicRunningHash)), 0);
//                 else if (object.topicRunningHash.length)
//                     message.topicRunningHash = object.topicRunningHash;
//             if (object.topicRunningHashVersion != null)
//                 if ($util.Long)
//                     (message.topicRunningHashVersion = $util.Long.fromValue(object.topicRunningHashVersion)).unsigned = true;
//                 else if (typeof object.topicRunningHashVersion === "string")
//                     message.topicRunningHashVersion = parseInt(object.topicRunningHashVersion, 10);
//                 else if (typeof object.topicRunningHashVersion === "number")
//                     message.topicRunningHashVersion = object.topicRunningHashVersion;
//                 else if (typeof object.topicRunningHashVersion === "object")
//                     message.topicRunningHashVersion = new $util.LongBits(object.topicRunningHashVersion.low >>> 0, object.topicRunningHashVersion.high >>> 0).toNumber(true);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionReceipt message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionReceipt
//          * @static
//          * @param {proto.TransactionReceipt} message TransactionReceipt
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionReceipt.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.status = options.enums === String ? "OK" : 0;
//                 object.accountID = null;
//                 object.fileID = null;
//                 object.contractID = null;
//                 object.exchangeRate = null;
//                 object.topicID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.topicSequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.topicSequenceNumber = options.longs === String ? "0" : 0;
//                 if (options.bytes === String)
//                     object.topicRunningHash = "";
//                 else {
//                     object.topicRunningHash = [];
//                     if (options.bytes !== Array)
//                         object.topicRunningHash = $util.newBuffer(object.topicRunningHash);
//                 }
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.topicRunningHashVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.topicRunningHashVersion = options.longs === String ? "0" : 0;
//             }
//             if (message.status != null && message.hasOwnProperty("status"))
//                 object.status = options.enums === String ? $root.proto.ResponseCodeEnum[message.status] : message.status;
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             if (message.contractID != null && message.hasOwnProperty("contractID"))
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//             if (message.exchangeRate != null && message.hasOwnProperty("exchangeRate"))
//                 object.exchangeRate = $root.proto.ExchangeRateSet.toObject(message.exchangeRate, options);
//             if (message.topicID != null && message.hasOwnProperty("topicID"))
//                 object.topicID = $root.proto.TopicID.toObject(message.topicID, options);
//             if (message.topicSequenceNumber != null && message.hasOwnProperty("topicSequenceNumber"))
//                 if (typeof message.topicSequenceNumber === "number")
//                     object.topicSequenceNumber = options.longs === String ? String(message.topicSequenceNumber) : message.topicSequenceNumber;
//                 else
//                     object.topicSequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.topicSequenceNumber) : options.longs === Number ? new $util.LongBits(message.topicSequenceNumber.low >>> 0, message.topicSequenceNumber.high >>> 0).toNumber(true) : message.topicSequenceNumber;
//             if (message.topicRunningHash != null && message.hasOwnProperty("topicRunningHash"))
//                 object.topicRunningHash = options.bytes === String ? $util.base64.encode(message.topicRunningHash, 0, message.topicRunningHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.topicRunningHash) : message.topicRunningHash;
//             if (message.topicRunningHashVersion != null && message.hasOwnProperty("topicRunningHashVersion"))
//                 if (typeof message.topicRunningHashVersion === "number")
//                     object.topicRunningHashVersion = options.longs === String ? String(message.topicRunningHashVersion) : message.topicRunningHashVersion;
//                 else
//                     object.topicRunningHashVersion = options.longs === String ? $util.Long.prototype.toString.call(message.topicRunningHashVersion) : options.longs === Number ? new $util.LongBits(message.topicRunningHashVersion.low >>> 0, message.topicRunningHashVersion.high >>> 0).toNumber(true) : message.topicRunningHashVersion;
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionReceipt to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionReceipt
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionReceipt.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionReceipt;
//     })();
// 
//     proto.ExchangeRate = (function() {
// 
//         /**
//          * Properties of an ExchangeRate.
//          * @memberof proto
//          * @interface IExchangeRate
//          * @property {number|null} [hbarEquiv] ExchangeRate hbarEquiv
//          * @property {number|null} [centEquiv] ExchangeRate centEquiv
//          * @property {proto.ITimestampSeconds|null} [expirationTime] ExchangeRate expirationTime
//          */
// 
//         /**
//          * Constructs a new ExchangeRate.
//          * @memberof proto
//          * @classdesc Represents an ExchangeRate.
//          * @implements IExchangeRate
//          * @constructor
//          * @param {proto.IExchangeRate=} [properties] Properties to set
//          */
//         function ExchangeRate(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ExchangeRate hbarEquiv.
//          * @member {number} hbarEquiv
//          * @memberof proto.ExchangeRate
//          * @instance
//          */
//         ExchangeRate.prototype.hbarEquiv = 0;
// 
//         /**
//          * ExchangeRate centEquiv.
//          * @member {number} centEquiv
//          * @memberof proto.ExchangeRate
//          * @instance
//          */
//         ExchangeRate.prototype.centEquiv = 0;
// 
//         /**
//          * ExchangeRate expirationTime.
//          * @member {proto.ITimestampSeconds|null|undefined} expirationTime
//          * @memberof proto.ExchangeRate
//          * @instance
//          */
//         ExchangeRate.prototype.expirationTime = null;
// 
//         /**
//          * Creates a new ExchangeRate instance using the specified properties.
//          * @function create
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {proto.IExchangeRate=} [properties] Properties to set
//          * @returns {proto.ExchangeRate} ExchangeRate instance
//          */
//         ExchangeRate.create = function create(properties) {
//             return new ExchangeRate(properties);
//         };
// 
//         /**
//          * Encodes the specified ExchangeRate message. Does not implicitly {@link proto.ExchangeRate.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {proto.IExchangeRate} message ExchangeRate message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ExchangeRate.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.hbarEquiv != null && Object.hasOwnProperty.call(message, "hbarEquiv"))
//                 writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hbarEquiv);
//             if (message.centEquiv != null && Object.hasOwnProperty.call(message, "centEquiv"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int32(message.centEquiv);
//             if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                 $root.proto.TimestampSeconds.encode(message.expirationTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ExchangeRate message, length delimited. Does not implicitly {@link proto.ExchangeRate.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {proto.IExchangeRate} message ExchangeRate message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ExchangeRate.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an ExchangeRate message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ExchangeRate} ExchangeRate
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ExchangeRate.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ExchangeRate();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.hbarEquiv = reader.int32();
//                     break;
//                 case 2:
//                     message.centEquiv = reader.int32();
//                     break;
//                 case 3:
//                     message.expirationTime = $root.proto.TimestampSeconds.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an ExchangeRate message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ExchangeRate} ExchangeRate
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ExchangeRate.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an ExchangeRate message.
//          * @function verify
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ExchangeRate.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.hbarEquiv != null && message.hasOwnProperty("hbarEquiv"))
//                 if (!$util.isInteger(message.hbarEquiv))
//                     return "hbarEquiv: integer expected";
//             if (message.centEquiv != null && message.hasOwnProperty("centEquiv"))
//                 if (!$util.isInteger(message.centEquiv))
//                     return "centEquiv: integer expected";
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                 let error = $root.proto.TimestampSeconds.verify(message.expirationTime);
//                 if (error)
//                     return "expirationTime." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates an ExchangeRate message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ExchangeRate} ExchangeRate
//          */
//         ExchangeRate.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ExchangeRate)
//                 return object;
//             let message = new $root.proto.ExchangeRate();
//             if (object.hbarEquiv != null)
//                 message.hbarEquiv = object.hbarEquiv | 0;
//             if (object.centEquiv != null)
//                 message.centEquiv = object.centEquiv | 0;
//             if (object.expirationTime != null) {
//                 if (typeof object.expirationTime !== "object")
//                     throw TypeError(".proto.ExchangeRate.expirationTime: object expected");
//                 message.expirationTime = $root.proto.TimestampSeconds.fromObject(object.expirationTime);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an ExchangeRate message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ExchangeRate
//          * @static
//          * @param {proto.ExchangeRate} message ExchangeRate
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ExchangeRate.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.hbarEquiv = 0;
//                 object.centEquiv = 0;
//                 object.expirationTime = null;
//             }
//             if (message.hbarEquiv != null && message.hasOwnProperty("hbarEquiv"))
//                 object.hbarEquiv = message.hbarEquiv;
//             if (message.centEquiv != null && message.hasOwnProperty("centEquiv"))
//                 object.centEquiv = message.centEquiv;
//             if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                 object.expirationTime = $root.proto.TimestampSeconds.toObject(message.expirationTime, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ExchangeRate to JSON.
//          * @function toJSON
//          * @memberof proto.ExchangeRate
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ExchangeRate.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ExchangeRate;
//     })();
// 
//     proto.ExchangeRateSet = (function() {
// 
//         /**
//          * Properties of an ExchangeRateSet.
//          * @memberof proto
//          * @interface IExchangeRateSet
//          * @property {proto.IExchangeRate|null} [currentRate] ExchangeRateSet currentRate
//          * @property {proto.IExchangeRate|null} [nextRate] ExchangeRateSet nextRate
//          */
// 
//         /**
//          * Constructs a new ExchangeRateSet.
//          * @memberof proto
//          * @classdesc Represents an ExchangeRateSet.
//          * @implements IExchangeRateSet
//          * @constructor
//          * @param {proto.IExchangeRateSet=} [properties] Properties to set
//          */
//         function ExchangeRateSet(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ExchangeRateSet currentRate.
//          * @member {proto.IExchangeRate|null|undefined} currentRate
//          * @memberof proto.ExchangeRateSet
//          * @instance
//          */
//         ExchangeRateSet.prototype.currentRate = null;
// 
//         /**
//          * ExchangeRateSet nextRate.
//          * @member {proto.IExchangeRate|null|undefined} nextRate
//          * @memberof proto.ExchangeRateSet
//          * @instance
//          */
//         ExchangeRateSet.prototype.nextRate = null;
// 
//         /**
//          * Creates a new ExchangeRateSet instance using the specified properties.
//          * @function create
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {proto.IExchangeRateSet=} [properties] Properties to set
//          * @returns {proto.ExchangeRateSet} ExchangeRateSet instance
//          */
//         ExchangeRateSet.create = function create(properties) {
//             return new ExchangeRateSet(properties);
//         };
// 
//         /**
//          * Encodes the specified ExchangeRateSet message. Does not implicitly {@link proto.ExchangeRateSet.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {proto.IExchangeRateSet} message ExchangeRateSet message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ExchangeRateSet.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.currentRate != null && Object.hasOwnProperty.call(message, "currentRate"))
//                 $root.proto.ExchangeRate.encode(message.currentRate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.nextRate != null && Object.hasOwnProperty.call(message, "nextRate"))
//                 $root.proto.ExchangeRate.encode(message.nextRate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ExchangeRateSet message, length delimited. Does not implicitly {@link proto.ExchangeRateSet.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {proto.IExchangeRateSet} message ExchangeRateSet message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ExchangeRateSet.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an ExchangeRateSet message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ExchangeRateSet} ExchangeRateSet
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ExchangeRateSet.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ExchangeRateSet();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.currentRate = $root.proto.ExchangeRate.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.nextRate = $root.proto.ExchangeRate.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an ExchangeRateSet message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ExchangeRateSet} ExchangeRateSet
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ExchangeRateSet.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an ExchangeRateSet message.
//          * @function verify
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ExchangeRateSet.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.currentRate != null && message.hasOwnProperty("currentRate")) {
//                 let error = $root.proto.ExchangeRate.verify(message.currentRate);
//                 if (error)
//                     return "currentRate." + error;
//             }
//             if (message.nextRate != null && message.hasOwnProperty("nextRate")) {
//                 let error = $root.proto.ExchangeRate.verify(message.nextRate);
//                 if (error)
//                     return "nextRate." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates an ExchangeRateSet message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ExchangeRateSet} ExchangeRateSet
//          */
//         ExchangeRateSet.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ExchangeRateSet)
//                 return object;
//             let message = new $root.proto.ExchangeRateSet();
//             if (object.currentRate != null) {
//                 if (typeof object.currentRate !== "object")
//                     throw TypeError(".proto.ExchangeRateSet.currentRate: object expected");
//                 message.currentRate = $root.proto.ExchangeRate.fromObject(object.currentRate);
//             }
//             if (object.nextRate != null) {
//                 if (typeof object.nextRate !== "object")
//                     throw TypeError(".proto.ExchangeRateSet.nextRate: object expected");
//                 message.nextRate = $root.proto.ExchangeRate.fromObject(object.nextRate);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an ExchangeRateSet message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ExchangeRateSet
//          * @static
//          * @param {proto.ExchangeRateSet} message ExchangeRateSet
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ExchangeRateSet.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.currentRate = null;
//                 object.nextRate = null;
//             }
//             if (message.currentRate != null && message.hasOwnProperty("currentRate"))
//                 object.currentRate = $root.proto.ExchangeRate.toObject(message.currentRate, options);
//             if (message.nextRate != null && message.hasOwnProperty("nextRate"))
//                 object.nextRate = $root.proto.ExchangeRate.toObject(message.nextRate, options);
//             return object;
//         };
// 
//         /**
//          * Converts this ExchangeRateSet to JSON.
//          * @function toJSON
//          * @memberof proto.ExchangeRateSet
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ExchangeRateSet.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ExchangeRateSet;
//     })();
// 
//     proto.CryptoGetAccountBalanceQuery = (function() {
// 
//         /**
//          * Properties of a CryptoGetAccountBalanceQuery.
//          * @memberof proto
//          * @interface ICryptoGetAccountBalanceQuery
//          * @property {proto.IQueryHeader|null} [header] CryptoGetAccountBalanceQuery header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetAccountBalanceQuery accountID
//          * @property {proto.IContractID|null} [contractID] CryptoGetAccountBalanceQuery contractID
//          */
// 
//         /**
//          * Constructs a new CryptoGetAccountBalanceQuery.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetAccountBalanceQuery.
//          * @implements ICryptoGetAccountBalanceQuery
//          * @constructor
//          * @param {proto.ICryptoGetAccountBalanceQuery=} [properties] Properties to set
//          */
//         function CryptoGetAccountBalanceQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetAccountBalanceQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @instance
//          */
//         CryptoGetAccountBalanceQuery.prototype.header = null;
// 
//         /**
//          * CryptoGetAccountBalanceQuery accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @instance
//          */
//         CryptoGetAccountBalanceQuery.prototype.accountID = null;
// 
//         /**
//          * CryptoGetAccountBalanceQuery contractID.
//          * @member {proto.IContractID|null|undefined} contractID
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @instance
//          */
//         CryptoGetAccountBalanceQuery.prototype.contractID = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * CryptoGetAccountBalanceQuery balanceSource.
//          * @member {"accountID"|"contractID"|undefined} balanceSource
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @instance
//          */
//         Object.defineProperty(CryptoGetAccountBalanceQuery.prototype, "balanceSource", {
//             get: $util.oneOfGetter($oneOfFields = ["accountID", "contractID"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new CryptoGetAccountBalanceQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {proto.ICryptoGetAccountBalanceQuery=} [properties] Properties to set
//          * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery instance
//          */
//         CryptoGetAccountBalanceQuery.create = function create(properties) {
//             return new CryptoGetAccountBalanceQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountBalanceQuery message. Does not implicitly {@link proto.CryptoGetAccountBalanceQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {proto.ICryptoGetAccountBalanceQuery} message CryptoGetAccountBalanceQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountBalanceQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
//                 $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountBalanceQuery message, length delimited. Does not implicitly {@link proto.CryptoGetAccountBalanceQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {proto.ICryptoGetAccountBalanceQuery} message CryptoGetAccountBalanceQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountBalanceQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountBalanceQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountBalanceQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetAccountBalanceQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountBalanceQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountBalanceQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetAccountBalanceQuery message.
//          * @function verify
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetAccountBalanceQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 properties.balanceSource = 1;
//                 {
//                     let error = $root.proto.AccountID.verify(message.accountID);
//                     if (error)
//                         return "accountID." + error;
//                 }
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 if (properties.balanceSource === 1)
//                     return "balanceSource: multiple values";
//                 properties.balanceSource = 1;
//                 {
//                     let error = $root.proto.ContractID.verify(message.contractID);
//                     if (error)
//                         return "contractID." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetAccountBalanceQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery
//          */
//         CryptoGetAccountBalanceQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetAccountBalanceQuery)
//                 return object;
//             let message = new $root.proto.CryptoGetAccountBalanceQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetAccountBalanceQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetAccountBalanceQuery.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.contractID != null) {
//                 if (typeof object.contractID !== "object")
//                     throw TypeError(".proto.CryptoGetAccountBalanceQuery.contractID: object expected");
//                 message.contractID = $root.proto.ContractID.fromObject(object.contractID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetAccountBalanceQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @static
//          * @param {proto.CryptoGetAccountBalanceQuery} message CryptoGetAccountBalanceQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetAccountBalanceQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.header = null;
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//                 if (options.oneofs)
//                     object.balanceSource = "accountID";
//             }
//             if (message.contractID != null && message.hasOwnProperty("contractID")) {
//                 object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
//                 if (options.oneofs)
//                     object.balanceSource = "contractID";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetAccountBalanceQuery to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetAccountBalanceQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetAccountBalanceQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetAccountBalanceQuery;
//     })();
// 
//     proto.CryptoGetAccountBalanceResponse = (function() {
// 
//         /**
//          * Properties of a CryptoGetAccountBalanceResponse.
//          * @memberof proto
//          * @interface ICryptoGetAccountBalanceResponse
//          * @property {proto.IResponseHeader|null} [header] CryptoGetAccountBalanceResponse header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetAccountBalanceResponse accountID
//          * @property {number|Long|null} [balance] CryptoGetAccountBalanceResponse balance
//          */
// 
//         /**
//          * Constructs a new CryptoGetAccountBalanceResponse.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetAccountBalanceResponse.
//          * @implements ICryptoGetAccountBalanceResponse
//          * @constructor
//          * @param {proto.ICryptoGetAccountBalanceResponse=} [properties] Properties to set
//          */
//         function CryptoGetAccountBalanceResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetAccountBalanceResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @instance
//          */
//         CryptoGetAccountBalanceResponse.prototype.header = null;
// 
//         /**
//          * CryptoGetAccountBalanceResponse accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @instance
//          */
//         CryptoGetAccountBalanceResponse.prototype.accountID = null;
// 
//         /**
//          * CryptoGetAccountBalanceResponse balance.
//          * @member {number|Long} balance
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @instance
//          */
//         CryptoGetAccountBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//         /**
//          * Creates a new CryptoGetAccountBalanceResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {proto.ICryptoGetAccountBalanceResponse=} [properties] Properties to set
//          * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse instance
//          */
//         CryptoGetAccountBalanceResponse.create = function create(properties) {
//             return new CryptoGetAccountBalanceResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountBalanceResponse message. Does not implicitly {@link proto.CryptoGetAccountBalanceResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {proto.ICryptoGetAccountBalanceResponse} message CryptoGetAccountBalanceResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountBalanceResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
//                 writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.balance);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountBalanceResponse message, length delimited. Does not implicitly {@link proto.CryptoGetAccountBalanceResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {proto.ICryptoGetAccountBalanceResponse} message CryptoGetAccountBalanceResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountBalanceResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountBalanceResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetAccountBalanceResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.balance = reader.uint64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountBalanceResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetAccountBalanceResponse message.
//          * @function verify
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetAccountBalanceResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.balance != null && message.hasOwnProperty("balance"))
//                 if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
//                     return "balance: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetAccountBalanceResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse
//          */
//         CryptoGetAccountBalanceResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetAccountBalanceResponse)
//                 return object;
//             let message = new $root.proto.CryptoGetAccountBalanceResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetAccountBalanceResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetAccountBalanceResponse.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.balance != null)
//                 if ($util.Long)
//                     (message.balance = $util.Long.fromValue(object.balance)).unsigned = true;
//                 else if (typeof object.balance === "string")
//                     message.balance = parseInt(object.balance, 10);
//                 else if (typeof object.balance === "number")
//                     message.balance = object.balance;
//                 else if (typeof object.balance === "object")
//                     message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber(true);
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetAccountBalanceResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @static
//          * @param {proto.CryptoGetAccountBalanceResponse} message CryptoGetAccountBalanceResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetAccountBalanceResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, true);
//                     object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.balance = options.longs === String ? "0" : 0;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.balance != null && message.hasOwnProperty("balance"))
//                 if (typeof message.balance === "number")
//                     object.balance = options.longs === String ? String(message.balance) : message.balance;
//                 else
//                     object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber(true) : message.balance;
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetAccountBalanceResponse to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetAccountBalanceResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetAccountBalanceResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetAccountBalanceResponse;
//     })();
// 
//     proto.CryptoGetAccountRecordsQuery = (function() {
// 
//         /**
//          * Properties of a CryptoGetAccountRecordsQuery.
//          * @memberof proto
//          * @interface ICryptoGetAccountRecordsQuery
//          * @property {proto.IQueryHeader|null} [header] CryptoGetAccountRecordsQuery header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetAccountRecordsQuery accountID
//          */
// 
//         /**
//          * Constructs a new CryptoGetAccountRecordsQuery.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetAccountRecordsQuery.
//          * @implements ICryptoGetAccountRecordsQuery
//          * @constructor
//          * @param {proto.ICryptoGetAccountRecordsQuery=} [properties] Properties to set
//          */
//         function CryptoGetAccountRecordsQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetAccountRecordsQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @instance
//          */
//         CryptoGetAccountRecordsQuery.prototype.header = null;
// 
//         /**
//          * CryptoGetAccountRecordsQuery accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @instance
//          */
//         CryptoGetAccountRecordsQuery.prototype.accountID = null;
// 
//         /**
//          * Creates a new CryptoGetAccountRecordsQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {proto.ICryptoGetAccountRecordsQuery=} [properties] Properties to set
//          * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery instance
//          */
//         CryptoGetAccountRecordsQuery.create = function create(properties) {
//             return new CryptoGetAccountRecordsQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountRecordsQuery message. Does not implicitly {@link proto.CryptoGetAccountRecordsQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {proto.ICryptoGetAccountRecordsQuery} message CryptoGetAccountRecordsQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountRecordsQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountRecordsQuery message, length delimited. Does not implicitly {@link proto.CryptoGetAccountRecordsQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {proto.ICryptoGetAccountRecordsQuery} message CryptoGetAccountRecordsQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountRecordsQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountRecordsQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountRecordsQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetAccountRecordsQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountRecordsQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountRecordsQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetAccountRecordsQuery message.
//          * @function verify
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetAccountRecordsQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetAccountRecordsQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery
//          */
//         CryptoGetAccountRecordsQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetAccountRecordsQuery)
//                 return object;
//             let message = new $root.proto.CryptoGetAccountRecordsQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetAccountRecordsQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetAccountRecordsQuery.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetAccountRecordsQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @static
//          * @param {proto.CryptoGetAccountRecordsQuery} message CryptoGetAccountRecordsQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetAccountRecordsQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetAccountRecordsQuery to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetAccountRecordsQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetAccountRecordsQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetAccountRecordsQuery;
//     })();
// 
//     proto.CryptoGetAccountRecordsResponse = (function() {
// 
//         /**
//          * Properties of a CryptoGetAccountRecordsResponse.
//          * @memberof proto
//          * @interface ICryptoGetAccountRecordsResponse
//          * @property {proto.IResponseHeader|null} [header] CryptoGetAccountRecordsResponse header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetAccountRecordsResponse accountID
//          * @property {Array.<proto.ITransactionRecord>|null} [records] CryptoGetAccountRecordsResponse records
//          */
// 
//         /**
//          * Constructs a new CryptoGetAccountRecordsResponse.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetAccountRecordsResponse.
//          * @implements ICryptoGetAccountRecordsResponse
//          * @constructor
//          * @param {proto.ICryptoGetAccountRecordsResponse=} [properties] Properties to set
//          */
//         function CryptoGetAccountRecordsResponse(properties) {
//             this.records = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetAccountRecordsResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @instance
//          */
//         CryptoGetAccountRecordsResponse.prototype.header = null;
// 
//         /**
//          * CryptoGetAccountRecordsResponse accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @instance
//          */
//         CryptoGetAccountRecordsResponse.prototype.accountID = null;
// 
//         /**
//          * CryptoGetAccountRecordsResponse records.
//          * @member {Array.<proto.ITransactionRecord>} records
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @instance
//          */
//         CryptoGetAccountRecordsResponse.prototype.records = $util.emptyArray;
// 
//         /**
//          * Creates a new CryptoGetAccountRecordsResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {proto.ICryptoGetAccountRecordsResponse=} [properties] Properties to set
//          * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse instance
//          */
//         CryptoGetAccountRecordsResponse.create = function create(properties) {
//             return new CryptoGetAccountRecordsResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountRecordsResponse message. Does not implicitly {@link proto.CryptoGetAccountRecordsResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {proto.ICryptoGetAccountRecordsResponse} message CryptoGetAccountRecordsResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountRecordsResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.records != null && message.records.length)
//                 for (let i = 0; i < message.records.length; ++i)
//                     $root.proto.TransactionRecord.encode(message.records[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetAccountRecordsResponse message, length delimited. Does not implicitly {@link proto.CryptoGetAccountRecordsResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {proto.ICryptoGetAccountRecordsResponse} message CryptoGetAccountRecordsResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetAccountRecordsResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountRecordsResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountRecordsResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetAccountRecordsResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     if (!(message.records && message.records.length))
//                         message.records = [];
//                     message.records.push($root.proto.TransactionRecord.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetAccountRecordsResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetAccountRecordsResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetAccountRecordsResponse message.
//          * @function verify
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetAccountRecordsResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.records != null && message.hasOwnProperty("records")) {
//                 if (!Array.isArray(message.records))
//                     return "records: array expected";
//                 for (let i = 0; i < message.records.length; ++i) {
//                     let error = $root.proto.TransactionRecord.verify(message.records[i]);
//                     if (error)
//                         return "records." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetAccountRecordsResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse
//          */
//         CryptoGetAccountRecordsResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetAccountRecordsResponse)
//                 return object;
//             let message = new $root.proto.CryptoGetAccountRecordsResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetAccountRecordsResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetAccountRecordsResponse.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.records) {
//                 if (!Array.isArray(object.records))
//                     throw TypeError(".proto.CryptoGetAccountRecordsResponse.records: array expected");
//                 message.records = [];
//                 for (let i = 0; i < object.records.length; ++i) {
//                     if (typeof object.records[i] !== "object")
//                         throw TypeError(".proto.CryptoGetAccountRecordsResponse.records: object expected");
//                     message.records[i] = $root.proto.TransactionRecord.fromObject(object.records[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetAccountRecordsResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @static
//          * @param {proto.CryptoGetAccountRecordsResponse} message CryptoGetAccountRecordsResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetAccountRecordsResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.records = [];
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.records && message.records.length) {
//                 object.records = [];
//                 for (let j = 0; j < message.records.length; ++j)
//                     object.records[j] = $root.proto.TransactionRecord.toObject(message.records[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetAccountRecordsResponse to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetAccountRecordsResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetAccountRecordsResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetAccountRecordsResponse;
//     })();
// 
//     proto.CryptoGetInfoQuery = (function() {
// 
//         /**
//          * Properties of a CryptoGetInfoQuery.
//          * @memberof proto
//          * @interface ICryptoGetInfoQuery
//          * @property {proto.IQueryHeader|null} [header] CryptoGetInfoQuery header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetInfoQuery accountID
//          */
// 
//         /**
//          * Constructs a new CryptoGetInfoQuery.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetInfoQuery.
//          * @implements ICryptoGetInfoQuery
//          * @constructor
//          * @param {proto.ICryptoGetInfoQuery=} [properties] Properties to set
//          */
//         function CryptoGetInfoQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetInfoQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.CryptoGetInfoQuery
//          * @instance
//          */
//         CryptoGetInfoQuery.prototype.header = null;
// 
//         /**
//          * CryptoGetInfoQuery accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetInfoQuery
//          * @instance
//          */
//         CryptoGetInfoQuery.prototype.accountID = null;
// 
//         /**
//          * Creates a new CryptoGetInfoQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {proto.ICryptoGetInfoQuery=} [properties] Properties to set
//          * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery instance
//          */
//         CryptoGetInfoQuery.create = function create(properties) {
//             return new CryptoGetInfoQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetInfoQuery message. Does not implicitly {@link proto.CryptoGetInfoQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {proto.ICryptoGetInfoQuery} message CryptoGetInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetInfoQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetInfoQuery message, length delimited. Does not implicitly {@link proto.CryptoGetInfoQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {proto.ICryptoGetInfoQuery} message CryptoGetInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetInfoQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetInfoQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetInfoQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetInfoQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetInfoQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetInfoQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetInfoQuery message.
//          * @function verify
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetInfoQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetInfoQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery
//          */
//         CryptoGetInfoQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetInfoQuery)
//                 return object;
//             let message = new $root.proto.CryptoGetInfoQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetInfoQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetInfoQuery.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetInfoQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetInfoQuery
//          * @static
//          * @param {proto.CryptoGetInfoQuery} message CryptoGetInfoQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetInfoQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetInfoQuery to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetInfoQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetInfoQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetInfoQuery;
//     })();
// 
//     proto.CryptoGetInfoResponse = (function() {
// 
//         /**
//          * Properties of a CryptoGetInfoResponse.
//          * @memberof proto
//          * @interface ICryptoGetInfoResponse
//          * @property {proto.IResponseHeader|null} [header] CryptoGetInfoResponse header
//          * @property {proto.CryptoGetInfoResponse.IAccountInfo|null} [accountInfo] CryptoGetInfoResponse accountInfo
//          */
// 
//         /**
//          * Constructs a new CryptoGetInfoResponse.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetInfoResponse.
//          * @implements ICryptoGetInfoResponse
//          * @constructor
//          * @param {proto.ICryptoGetInfoResponse=} [properties] Properties to set
//          */
//         function CryptoGetInfoResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetInfoResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.CryptoGetInfoResponse
//          * @instance
//          */
//         CryptoGetInfoResponse.prototype.header = null;
// 
//         /**
//          * CryptoGetInfoResponse accountInfo.
//          * @member {proto.CryptoGetInfoResponse.IAccountInfo|null|undefined} accountInfo
//          * @memberof proto.CryptoGetInfoResponse
//          * @instance
//          */
//         CryptoGetInfoResponse.prototype.accountInfo = null;
// 
//         /**
//          * Creates a new CryptoGetInfoResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {proto.ICryptoGetInfoResponse=} [properties] Properties to set
//          * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse instance
//          */
//         CryptoGetInfoResponse.create = function create(properties) {
//             return new CryptoGetInfoResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetInfoResponse message. Does not implicitly {@link proto.CryptoGetInfoResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {proto.ICryptoGetInfoResponse} message CryptoGetInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetInfoResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountInfo != null && Object.hasOwnProperty.call(message, "accountInfo"))
//                 $root.proto.CryptoGetInfoResponse.AccountInfo.encode(message.accountInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetInfoResponse message, length delimited. Does not implicitly {@link proto.CryptoGetInfoResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {proto.ICryptoGetInfoResponse} message CryptoGetInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetInfoResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetInfoResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetInfoResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetInfoResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetInfoResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetInfoResponse message.
//          * @function verify
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetInfoResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountInfo != null && message.hasOwnProperty("accountInfo")) {
//                 let error = $root.proto.CryptoGetInfoResponse.AccountInfo.verify(message.accountInfo);
//                 if (error)
//                     return "accountInfo." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetInfoResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse
//          */
//         CryptoGetInfoResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetInfoResponse)
//                 return object;
//             let message = new $root.proto.CryptoGetInfoResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetInfoResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.accountInfo != null) {
//                 if (typeof object.accountInfo !== "object")
//                     throw TypeError(".proto.CryptoGetInfoResponse.accountInfo: object expected");
//                 message.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.fromObject(object.accountInfo);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetInfoResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetInfoResponse
//          * @static
//          * @param {proto.CryptoGetInfoResponse} message CryptoGetInfoResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetInfoResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountInfo = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.accountInfo != null && message.hasOwnProperty("accountInfo"))
//                 object.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.toObject(message.accountInfo, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetInfoResponse to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetInfoResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetInfoResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         CryptoGetInfoResponse.AccountInfo = (function() {
// 
//             /**
//              * Properties of an AccountInfo.
//              * @memberof proto.CryptoGetInfoResponse
//              * @interface IAccountInfo
//              * @property {proto.IAccountID|null} [accountID] AccountInfo accountID
//              * @property {string|null} [contractAccountID] AccountInfo contractAccountID
//              * @property {boolean|null} [deleted] AccountInfo deleted
//              * @property {proto.IAccountID|null} [proxyAccountID] AccountInfo proxyAccountID
//              * @property {number|Long|null} [proxyReceived] AccountInfo proxyReceived
//              * @property {proto.IKey|null} [key] AccountInfo key
//              * @property {number|Long|null} [balance] AccountInfo balance
//              * @property {number|Long|null} [generateSendRecordThreshold] AccountInfo generateSendRecordThreshold
//              * @property {number|Long|null} [generateReceiveRecordThreshold] AccountInfo generateReceiveRecordThreshold
//              * @property {boolean|null} [receiverSigRequired] AccountInfo receiverSigRequired
//              * @property {proto.ITimestamp|null} [expirationTime] AccountInfo expirationTime
//              * @property {proto.IDuration|null} [autoRenewPeriod] AccountInfo autoRenewPeriod
//              * @property {Array.<proto.ILiveHash>|null} [liveHashes] AccountInfo liveHashes
//              */
// 
//             /**
//              * Constructs a new AccountInfo.
//              * @memberof proto.CryptoGetInfoResponse
//              * @classdesc Represents an AccountInfo.
//              * @implements IAccountInfo
//              * @constructor
//              * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [properties] Properties to set
//              */
//             function AccountInfo(properties) {
//                 this.liveHashes = [];
//                 if (properties)
//                     for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                         if (properties[keys[i]] != null)
//                             this[keys[i]] = properties[keys[i]];
//             }
// 
//             /**
//              * AccountInfo accountID.
//              * @member {proto.IAccountID|null|undefined} accountID
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.accountID = null;
// 
//             /**
//              * AccountInfo contractAccountID.
//              * @member {string} contractAccountID
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.contractAccountID = "";
// 
//             /**
//              * AccountInfo deleted.
//              * @member {boolean} deleted
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.deleted = false;
// 
//             /**
//              * AccountInfo proxyAccountID.
//              * @member {proto.IAccountID|null|undefined} proxyAccountID
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.proxyAccountID = null;
// 
//             /**
//              * AccountInfo proxyReceived.
//              * @member {number|Long} proxyReceived
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//             /**
//              * AccountInfo key.
//              * @member {proto.IKey|null|undefined} key
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.key = null;
// 
//             /**
//              * AccountInfo balance.
//              * @member {number|Long} balance
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//             /**
//              * AccountInfo generateSendRecordThreshold.
//              * @member {number|Long} generateSendRecordThreshold
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.generateSendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//             /**
//              * AccountInfo generateReceiveRecordThreshold.
//              * @member {number|Long} generateReceiveRecordThreshold
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.generateReceiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
// 
//             /**
//              * AccountInfo receiverSigRequired.
//              * @member {boolean} receiverSigRequired
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.receiverSigRequired = false;
// 
//             /**
//              * AccountInfo expirationTime.
//              * @member {proto.ITimestamp|null|undefined} expirationTime
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.expirationTime = null;
// 
//             /**
//              * AccountInfo autoRenewPeriod.
//              * @member {proto.IDuration|null|undefined} autoRenewPeriod
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.autoRenewPeriod = null;
// 
//             /**
//              * AccountInfo liveHashes.
//              * @member {Array.<proto.ILiveHash>} liveHashes
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              */
//             AccountInfo.prototype.liveHashes = $util.emptyArray;
// 
//             /**
//              * Creates a new AccountInfo instance using the specified properties.
//              * @function create
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [properties] Properties to set
//              * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo instance
//              */
//             AccountInfo.create = function create(properties) {
//                 return new AccountInfo(properties);
//             };
// 
//             /**
//              * Encodes the specified AccountInfo message. Does not implicitly {@link proto.CryptoGetInfoResponse.AccountInfo.verify|verify} messages.
//              * @function encode
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {proto.CryptoGetInfoResponse.IAccountInfo} message AccountInfo message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             AccountInfo.encode = function encode(message, writer) {
//                 if (!writer)
//                     writer = $Writer.create();
//                 if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                     $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//                 if (message.contractAccountID != null && Object.hasOwnProperty.call(message, "contractAccountID"))
//                     writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractAccountID);
//                 if (message.deleted != null && Object.hasOwnProperty.call(message, "deleted"))
//                     writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deleted);
//                 if (message.proxyAccountID != null && Object.hasOwnProperty.call(message, "proxyAccountID"))
//                     $root.proto.AccountID.encode(message.proxyAccountID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//                 if (message.proxyReceived != null && Object.hasOwnProperty.call(message, "proxyReceived"))
//                     writer.uint32(/* id 6, wireType 0 =*/48).int64(message.proxyReceived);
//                 if (message.key != null && Object.hasOwnProperty.call(message, "key"))
//                     $root.proto.Key.encode(message.key, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//                 if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
//                     writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.balance);
//                 if (message.generateSendRecordThreshold != null && Object.hasOwnProperty.call(message, "generateSendRecordThreshold"))
//                     writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.generateSendRecordThreshold);
//                 if (message.generateReceiveRecordThreshold != null && Object.hasOwnProperty.call(message, "generateReceiveRecordThreshold"))
//                     writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.generateReceiveRecordThreshold);
//                 if (message.receiverSigRequired != null && Object.hasOwnProperty.call(message, "receiverSigRequired"))
//                     writer.uint32(/* id 11, wireType 0 =*/88).bool(message.receiverSigRequired);
//                 if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                     $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
//                 if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
//                     $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
//                 if (message.liveHashes != null && message.liveHashes.length)
//                     for (let i = 0; i < message.liveHashes.length; ++i)
//                         $root.proto.LiveHash.encode(message.liveHashes[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
//                 return writer;
//             };
// 
//             /**
//              * Encodes the specified AccountInfo message, length delimited. Does not implicitly {@link proto.CryptoGetInfoResponse.AccountInfo.verify|verify} messages.
//              * @function encodeDelimited
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {proto.CryptoGetInfoResponse.IAccountInfo} message AccountInfo message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             AccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
//                 return this.encode(message, writer).ldelim();
//             };
// 
//             /**
//              * Decodes an AccountInfo message from the specified reader or buffer.
//              * @function decode
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @param {number} [length] Message length if known beforehand
//              * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             AccountInfo.decode = function decode(reader, length) {
//                 if (!(reader instanceof $Reader))
//                     reader = $Reader.create(reader);
//                 let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetInfoResponse.AccountInfo();
//                 while (reader.pos < end) {
//                     let tag = reader.uint32();
//                     switch (tag >>> 3) {
//                     case 1:
//                         message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                         break;
//                     case 2:
//                         message.contractAccountID = reader.string();
//                         break;
//                     case 3:
//                         message.deleted = reader.bool();
//                         break;
//                     case 4:
//                         message.proxyAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                         break;
//                     case 6:
//                         message.proxyReceived = reader.int64();
//                         break;
//                     case 7:
//                         message.key = $root.proto.Key.decode(reader, reader.uint32());
//                         break;
//                     case 8:
//                         message.balance = reader.uint64();
//                         break;
//                     case 9:
//                         message.generateSendRecordThreshold = reader.uint64();
//                         break;
//                     case 10:
//                         message.generateReceiveRecordThreshold = reader.uint64();
//                         break;
//                     case 11:
//                         message.receiverSigRequired = reader.bool();
//                         break;
//                     case 12:
//                         message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                         break;
//                     case 13:
//                         message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
//                         break;
//                     case 14:
//                         if (!(message.liveHashes && message.liveHashes.length))
//                             message.liveHashes = [];
//                         message.liveHashes.push($root.proto.LiveHash.decode(reader, reader.uint32()));
//                         break;
//                     default:
//                         reader.skipType(tag & 7);
//                         break;
//                     }
//                 }
//                 return message;
//             };
// 
//             /**
//              * Decodes an AccountInfo message from the specified reader or buffer, length delimited.
//              * @function decodeDelimited
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             AccountInfo.decodeDelimited = function decodeDelimited(reader) {
//                 if (!(reader instanceof $Reader))
//                     reader = new $Reader(reader);
//                 return this.decode(reader, reader.uint32());
//             };
// 
//             /**
//              * Verifies an AccountInfo message.
//              * @function verify
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {Object.<string,*>} message Plain object to verify
//              * @returns {string|null} `null` if valid, otherwise the reason why it is not
//              */
//             AccountInfo.verify = function verify(message) {
//                 if (typeof message !== "object" || message === null)
//                     return "object expected";
//                 if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                     let error = $root.proto.AccountID.verify(message.accountID);
//                     if (error)
//                         return "accountID." + error;
//                 }
//                 if (message.contractAccountID != null && message.hasOwnProperty("contractAccountID"))
//                     if (!$util.isString(message.contractAccountID))
//                         return "contractAccountID: string expected";
//                 if (message.deleted != null && message.hasOwnProperty("deleted"))
//                     if (typeof message.deleted !== "boolean")
//                         return "deleted: boolean expected";
//                 if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID")) {
//                     let error = $root.proto.AccountID.verify(message.proxyAccountID);
//                     if (error)
//                         return "proxyAccountID." + error;
//                 }
//                 if (message.proxyReceived != null && message.hasOwnProperty("proxyReceived"))
//                     if (!$util.isInteger(message.proxyReceived) && !(message.proxyReceived && $util.isInteger(message.proxyReceived.low) && $util.isInteger(message.proxyReceived.high)))
//                         return "proxyReceived: integer|Long expected";
//                 if (message.key != null && message.hasOwnProperty("key")) {
//                     let error = $root.proto.Key.verify(message.key);
//                     if (error)
//                         return "key." + error;
//                 }
//                 if (message.balance != null && message.hasOwnProperty("balance"))
//                     if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
//                         return "balance: integer|Long expected";
//                 if (message.generateSendRecordThreshold != null && message.hasOwnProperty("generateSendRecordThreshold"))
//                     if (!$util.isInteger(message.generateSendRecordThreshold) && !(message.generateSendRecordThreshold && $util.isInteger(message.generateSendRecordThreshold.low) && $util.isInteger(message.generateSendRecordThreshold.high)))
//                         return "generateSendRecordThreshold: integer|Long expected";
//                 if (message.generateReceiveRecordThreshold != null && message.hasOwnProperty("generateReceiveRecordThreshold"))
//                     if (!$util.isInteger(message.generateReceiveRecordThreshold) && !(message.generateReceiveRecordThreshold && $util.isInteger(message.generateReceiveRecordThreshold.low) && $util.isInteger(message.generateReceiveRecordThreshold.high)))
//                         return "generateReceiveRecordThreshold: integer|Long expected";
//                 if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired"))
//                     if (typeof message.receiverSigRequired !== "boolean")
//                         return "receiverSigRequired: boolean expected";
//                 if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                     let error = $root.proto.Timestamp.verify(message.expirationTime);
//                     if (error)
//                         return "expirationTime." + error;
//                 }
//                 if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
//                     let error = $root.proto.Duration.verify(message.autoRenewPeriod);
//                     if (error)
//                         return "autoRenewPeriod." + error;
//                 }
//                 if (message.liveHashes != null && message.hasOwnProperty("liveHashes")) {
//                     if (!Array.isArray(message.liveHashes))
//                         return "liveHashes: array expected";
//                     for (let i = 0; i < message.liveHashes.length; ++i) {
//                         let error = $root.proto.LiveHash.verify(message.liveHashes[i]);
//                         if (error)
//                             return "liveHashes." + error;
//                     }
//                 }
//                 return null;
//             };
// 
//             /**
//              * Creates an AccountInfo message from a plain object. Also converts values to their respective internal types.
//              * @function fromObject
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {Object.<string,*>} object Plain object
//              * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo
//              */
//             AccountInfo.fromObject = function fromObject(object) {
//                 if (object instanceof $root.proto.CryptoGetInfoResponse.AccountInfo)
//                     return object;
//                 let message = new $root.proto.CryptoGetInfoResponse.AccountInfo();
//                 if (object.accountID != null) {
//                     if (typeof object.accountID !== "object")
//                         throw TypeError(".proto.CryptoGetInfoResponse.AccountInfo.accountID: object expected");
//                     message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//                 }
//                 if (object.contractAccountID != null)
//                     message.contractAccountID = String(object.contractAccountID);
//                 if (object.deleted != null)
//                     message.deleted = Boolean(object.deleted);
//                 if (object.proxyAccountID != null) {
//                     if (typeof object.proxyAccountID !== "object")
//                         throw TypeError(".proto.CryptoGetInfoResponse.AccountInfo.proxyAccountID: object expected");
//                     message.proxyAccountID = $root.proto.AccountID.fromObject(object.proxyAccountID);
//                 }
//                 if (object.proxyReceived != null)
//                     if ($util.Long)
//                         (message.proxyReceived = $util.Long.fromValue(object.proxyReceived)).unsigned = false;
//                     else if (typeof object.proxyReceived === "string")
//                         message.proxyReceived = parseInt(object.proxyReceived, 10);
//                     else if (typeof object.proxyReceived === "number")
//                         message.proxyReceived = object.proxyReceived;
//                     else if (typeof object.proxyReceived === "object")
//                         message.proxyReceived = new $util.LongBits(object.proxyReceived.low >>> 0, object.proxyReceived.high >>> 0).toNumber();
//                 if (object.key != null) {
//                     if (typeof object.key !== "object")
//                         throw TypeError(".proto.CryptoGetInfoResponse.AccountInfo.key: object expected");
//                     message.key = $root.proto.Key.fromObject(object.key);
//                 }
//                 if (object.balance != null)
//                     if ($util.Long)
//                         (message.balance = $util.Long.fromValue(object.balance)).unsigned = true;
//                     else if (typeof object.balance === "string")
//                         message.balance = parseInt(object.balance, 10);
//                     else if (typeof object.balance === "number")
//                         message.balance = object.balance;
//                     else if (typeof object.balance === "object")
//                         message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber(true);
//                 if (object.generateSendRecordThreshold != null)
//                     if ($util.Long)
//                         (message.generateSendRecordThreshold = $util.Long.fromValue(object.generateSendRecordThreshold)).unsigned = true;
//                     else if (typeof object.generateSendRecordThreshold === "string")
//                         message.generateSendRecordThreshold = parseInt(object.generateSendRecordThreshold, 10);
//                     else if (typeof object.generateSendRecordThreshold === "number")
//                         message.generateSendRecordThreshold = object.generateSendRecordThreshold;
//                     else if (typeof object.generateSendRecordThreshold === "object")
//                         message.generateSendRecordThreshold = new $util.LongBits(object.generateSendRecordThreshold.low >>> 0, object.generateSendRecordThreshold.high >>> 0).toNumber(true);
//                 if (object.generateReceiveRecordThreshold != null)
//                     if ($util.Long)
//                         (message.generateReceiveRecordThreshold = $util.Long.fromValue(object.generateReceiveRecordThreshold)).unsigned = true;
//                     else if (typeof object.generateReceiveRecordThreshold === "string")
//                         message.generateReceiveRecordThreshold = parseInt(object.generateReceiveRecordThreshold, 10);
//                     else if (typeof object.generateReceiveRecordThreshold === "number")
//                         message.generateReceiveRecordThreshold = object.generateReceiveRecordThreshold;
//                     else if (typeof object.generateReceiveRecordThreshold === "object")
//                         message.generateReceiveRecordThreshold = new $util.LongBits(object.generateReceiveRecordThreshold.low >>> 0, object.generateReceiveRecordThreshold.high >>> 0).toNumber(true);
//                 if (object.receiverSigRequired != null)
//                     message.receiverSigRequired = Boolean(object.receiverSigRequired);
//                 if (object.expirationTime != null) {
//                     if (typeof object.expirationTime !== "object")
//                         throw TypeError(".proto.CryptoGetInfoResponse.AccountInfo.expirationTime: object expected");
//                     message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//                 }
//                 if (object.autoRenewPeriod != null) {
//                     if (typeof object.autoRenewPeriod !== "object")
//                         throw TypeError(".proto.CryptoGetInfoResponse.AccountInfo.autoRenewPeriod: object expected");
//                     message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
//                 }
//                 if (object.liveHashes) {
//                     if (!Array.isArray(object.liveHashes))
//                         throw TypeError(".proto.CryptoGetInfoResponse.AccountInfo.liveHashes: array expected");
//                     message.liveHashes = [];
//                     for (let i = 0; i < object.liveHashes.length; ++i) {
//                         if (typeof object.liveHashes[i] !== "object")
//                             throw TypeError(".proto.CryptoGetInfoResponse.AccountInfo.liveHashes: object expected");
//                         message.liveHashes[i] = $root.proto.LiveHash.fromObject(object.liveHashes[i]);
//                     }
//                 }
//                 return message;
//             };
// 
//             /**
//              * Creates a plain object from an AccountInfo message. Also converts values to other types if specified.
//              * @function toObject
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @static
//              * @param {proto.CryptoGetInfoResponse.AccountInfo} message AccountInfo
//              * @param {$protobuf.IConversionOptions} [options] Conversion options
//              * @returns {Object.<string,*>} Plain object
//              */
//             AccountInfo.toObject = function toObject(message, options) {
//                 if (!options)
//                     options = {};
//                 let object = {};
//                 if (options.arrays || options.defaults)
//                     object.liveHashes = [];
//                 if (options.defaults) {
//                     object.accountID = null;
//                     object.contractAccountID = "";
//                     object.deleted = false;
//                     object.proxyAccountID = null;
//                     if ($util.Long) {
//                         let long = new $util.Long(0, 0, false);
//                         object.proxyReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                     } else
//                         object.proxyReceived = options.longs === String ? "0" : 0;
//                     object.key = null;
//                     if ($util.Long) {
//                         let long = new $util.Long(0, 0, true);
//                         object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                     } else
//                         object.balance = options.longs === String ? "0" : 0;
//                     if ($util.Long) {
//                         let long = new $util.Long(0, 0, true);
//                         object.generateSendRecordThreshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                     } else
//                         object.generateSendRecordThreshold = options.longs === String ? "0" : 0;
//                     if ($util.Long) {
//                         let long = new $util.Long(0, 0, true);
//                         object.generateReceiveRecordThreshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                     } else
//                         object.generateReceiveRecordThreshold = options.longs === String ? "0" : 0;
//                     object.receiverSigRequired = false;
//                     object.expirationTime = null;
//                     object.autoRenewPeriod = null;
//                 }
//                 if (message.accountID != null && message.hasOwnProperty("accountID"))
//                     object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//                 if (message.contractAccountID != null && message.hasOwnProperty("contractAccountID"))
//                     object.contractAccountID = message.contractAccountID;
//                 if (message.deleted != null && message.hasOwnProperty("deleted"))
//                     object.deleted = message.deleted;
//                 if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID"))
//                     object.proxyAccountID = $root.proto.AccountID.toObject(message.proxyAccountID, options);
//                 if (message.proxyReceived != null && message.hasOwnProperty("proxyReceived"))
//                     if (typeof message.proxyReceived === "number")
//                         object.proxyReceived = options.longs === String ? String(message.proxyReceived) : message.proxyReceived;
//                     else
//                         object.proxyReceived = options.longs === String ? $util.Long.prototype.toString.call(message.proxyReceived) : options.longs === Number ? new $util.LongBits(message.proxyReceived.low >>> 0, message.proxyReceived.high >>> 0).toNumber() : message.proxyReceived;
//                 if (message.key != null && message.hasOwnProperty("key"))
//                     object.key = $root.proto.Key.toObject(message.key, options);
//                 if (message.balance != null && message.hasOwnProperty("balance"))
//                     if (typeof message.balance === "number")
//                         object.balance = options.longs === String ? String(message.balance) : message.balance;
//                     else
//                         object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber(true) : message.balance;
//                 if (message.generateSendRecordThreshold != null && message.hasOwnProperty("generateSendRecordThreshold"))
//                     if (typeof message.generateSendRecordThreshold === "number")
//                         object.generateSendRecordThreshold = options.longs === String ? String(message.generateSendRecordThreshold) : message.generateSendRecordThreshold;
//                     else
//                         object.generateSendRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.generateSendRecordThreshold) : options.longs === Number ? new $util.LongBits(message.generateSendRecordThreshold.low >>> 0, message.generateSendRecordThreshold.high >>> 0).toNumber(true) : message.generateSendRecordThreshold;
//                 if (message.generateReceiveRecordThreshold != null && message.hasOwnProperty("generateReceiveRecordThreshold"))
//                     if (typeof message.generateReceiveRecordThreshold === "number")
//                         object.generateReceiveRecordThreshold = options.longs === String ? String(message.generateReceiveRecordThreshold) : message.generateReceiveRecordThreshold;
//                     else
//                         object.generateReceiveRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.generateReceiveRecordThreshold) : options.longs === Number ? new $util.LongBits(message.generateReceiveRecordThreshold.low >>> 0, message.generateReceiveRecordThreshold.high >>> 0).toNumber(true) : message.generateReceiveRecordThreshold;
//                 if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired"))
//                     object.receiverSigRequired = message.receiverSigRequired;
//                 if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                     object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//                 if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
//                     object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
//                 if (message.liveHashes && message.liveHashes.length) {
//                     object.liveHashes = [];
//                     for (let j = 0; j < message.liveHashes.length; ++j)
//                         object.liveHashes[j] = $root.proto.LiveHash.toObject(message.liveHashes[j], options);
//                 }
//                 return object;
//             };
// 
//             /**
//              * Converts this AccountInfo to JSON.
//              * @function toJSON
//              * @memberof proto.CryptoGetInfoResponse.AccountInfo
//              * @instance
//              * @returns {Object.<string,*>} JSON object
//              */
//             AccountInfo.prototype.toJSON = function toJSON() {
//                 return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//             };
// 
//             return AccountInfo;
//         })();
// 
//         return CryptoGetInfoResponse;
//     })();
// 
//     proto.CryptoGetLiveHashQuery = (function() {
// 
//         /**
//          * Properties of a CryptoGetLiveHashQuery.
//          * @memberof proto
//          * @interface ICryptoGetLiveHashQuery
//          * @property {proto.IQueryHeader|null} [header] CryptoGetLiveHashQuery header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetLiveHashQuery accountID
//          * @property {Uint8Array|null} [hash] CryptoGetLiveHashQuery hash
//          */
// 
//         /**
//          * Constructs a new CryptoGetLiveHashQuery.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetLiveHashQuery.
//          * @implements ICryptoGetLiveHashQuery
//          * @constructor
//          * @param {proto.ICryptoGetLiveHashQuery=} [properties] Properties to set
//          */
//         function CryptoGetLiveHashQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetLiveHashQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @instance
//          */
//         CryptoGetLiveHashQuery.prototype.header = null;
// 
//         /**
//          * CryptoGetLiveHashQuery accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @instance
//          */
//         CryptoGetLiveHashQuery.prototype.accountID = null;
// 
//         /**
//          * CryptoGetLiveHashQuery hash.
//          * @member {Uint8Array} hash
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @instance
//          */
//         CryptoGetLiveHashQuery.prototype.hash = $util.newBuffer([]);
// 
//         /**
//          * Creates a new CryptoGetLiveHashQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {proto.ICryptoGetLiveHashQuery=} [properties] Properties to set
//          * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery instance
//          */
//         CryptoGetLiveHashQuery.create = function create(properties) {
//             return new CryptoGetLiveHashQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetLiveHashQuery message. Does not implicitly {@link proto.CryptoGetLiveHashQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {proto.ICryptoGetLiveHashQuery} message CryptoGetLiveHashQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetLiveHashQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hash);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetLiveHashQuery message, length delimited. Does not implicitly {@link proto.CryptoGetLiveHashQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {proto.ICryptoGetLiveHashQuery} message CryptoGetLiveHashQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetLiveHashQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetLiveHashQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetLiveHashQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetLiveHashQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.hash = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetLiveHashQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetLiveHashQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetLiveHashQuery message.
//          * @function verify
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetLiveHashQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
//                     return "hash: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetLiveHashQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery
//          */
//         CryptoGetLiveHashQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetLiveHashQuery)
//                 return object;
//             let message = new $root.proto.CryptoGetLiveHashQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetLiveHashQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetLiveHashQuery.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.hash != null)
//                 if (typeof object.hash === "string")
//                     $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
//                 else if (object.hash.length)
//                     message.hash = object.hash;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetLiveHashQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @static
//          * @param {proto.CryptoGetLiveHashQuery} message CryptoGetLiveHashQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetLiveHashQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//                 if (options.bytes === String)
//                     object.hash = "";
//                 else {
//                     object.hash = [];
//                     if (options.bytes !== Array)
//                         object.hash = $util.newBuffer(object.hash);
//                 }
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetLiveHashQuery to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetLiveHashQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetLiveHashQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetLiveHashQuery;
//     })();
// 
//     proto.CryptoGetLiveHashResponse = (function() {
// 
//         /**
//          * Properties of a CryptoGetLiveHashResponse.
//          * @memberof proto
//          * @interface ICryptoGetLiveHashResponse
//          * @property {proto.IResponseHeader|null} [header] CryptoGetLiveHashResponse header
//          * @property {proto.ILiveHash|null} [liveHash] CryptoGetLiveHashResponse liveHash
//          */
// 
//         /**
//          * Constructs a new CryptoGetLiveHashResponse.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetLiveHashResponse.
//          * @implements ICryptoGetLiveHashResponse
//          * @constructor
//          * @param {proto.ICryptoGetLiveHashResponse=} [properties] Properties to set
//          */
//         function CryptoGetLiveHashResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetLiveHashResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @instance
//          */
//         CryptoGetLiveHashResponse.prototype.header = null;
// 
//         /**
//          * CryptoGetLiveHashResponse liveHash.
//          * @member {proto.ILiveHash|null|undefined} liveHash
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @instance
//          */
//         CryptoGetLiveHashResponse.prototype.liveHash = null;
// 
//         /**
//          * Creates a new CryptoGetLiveHashResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {proto.ICryptoGetLiveHashResponse=} [properties] Properties to set
//          * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse instance
//          */
//         CryptoGetLiveHashResponse.create = function create(properties) {
//             return new CryptoGetLiveHashResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetLiveHashResponse message. Does not implicitly {@link proto.CryptoGetLiveHashResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {proto.ICryptoGetLiveHashResponse} message CryptoGetLiveHashResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetLiveHashResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.liveHash != null && Object.hasOwnProperty.call(message, "liveHash"))
//                 $root.proto.LiveHash.encode(message.liveHash, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetLiveHashResponse message, length delimited. Does not implicitly {@link proto.CryptoGetLiveHashResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {proto.ICryptoGetLiveHashResponse} message CryptoGetLiveHashResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetLiveHashResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetLiveHashResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetLiveHashResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetLiveHashResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.liveHash = $root.proto.LiveHash.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetLiveHashResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetLiveHashResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetLiveHashResponse message.
//          * @function verify
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetLiveHashResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.liveHash != null && message.hasOwnProperty("liveHash")) {
//                 let error = $root.proto.LiveHash.verify(message.liveHash);
//                 if (error)
//                     return "liveHash." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetLiveHashResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse
//          */
//         CryptoGetLiveHashResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetLiveHashResponse)
//                 return object;
//             let message = new $root.proto.CryptoGetLiveHashResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetLiveHashResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.liveHash != null) {
//                 if (typeof object.liveHash !== "object")
//                     throw TypeError(".proto.CryptoGetLiveHashResponse.liveHash: object expected");
//                 message.liveHash = $root.proto.LiveHash.fromObject(object.liveHash);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetLiveHashResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @static
//          * @param {proto.CryptoGetLiveHashResponse} message CryptoGetLiveHashResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetLiveHashResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.liveHash = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.liveHash != null && message.hasOwnProperty("liveHash"))
//                 object.liveHash = $root.proto.LiveHash.toObject(message.liveHash, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetLiveHashResponse to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetLiveHashResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetLiveHashResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetLiveHashResponse;
//     })();
// 
//     proto.CryptoGetStakersQuery = (function() {
// 
//         /**
//          * Properties of a CryptoGetStakersQuery.
//          * @memberof proto
//          * @interface ICryptoGetStakersQuery
//          * @property {proto.IQueryHeader|null} [header] CryptoGetStakersQuery header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetStakersQuery accountID
//          */
// 
//         /**
//          * Constructs a new CryptoGetStakersQuery.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetStakersQuery.
//          * @implements ICryptoGetStakersQuery
//          * @constructor
//          * @param {proto.ICryptoGetStakersQuery=} [properties] Properties to set
//          */
//         function CryptoGetStakersQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetStakersQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.CryptoGetStakersQuery
//          * @instance
//          */
//         CryptoGetStakersQuery.prototype.header = null;
// 
//         /**
//          * CryptoGetStakersQuery accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetStakersQuery
//          * @instance
//          */
//         CryptoGetStakersQuery.prototype.accountID = null;
// 
//         /**
//          * Creates a new CryptoGetStakersQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {proto.ICryptoGetStakersQuery=} [properties] Properties to set
//          * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery instance
//          */
//         CryptoGetStakersQuery.create = function create(properties) {
//             return new CryptoGetStakersQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetStakersQuery message. Does not implicitly {@link proto.CryptoGetStakersQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {proto.ICryptoGetStakersQuery} message CryptoGetStakersQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetStakersQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetStakersQuery message, length delimited. Does not implicitly {@link proto.CryptoGetStakersQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {proto.ICryptoGetStakersQuery} message CryptoGetStakersQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetStakersQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetStakersQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetStakersQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetStakersQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetStakersQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetStakersQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetStakersQuery message.
//          * @function verify
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetStakersQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetStakersQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery
//          */
//         CryptoGetStakersQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetStakersQuery)
//                 return object;
//             let message = new $root.proto.CryptoGetStakersQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetStakersQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetStakersQuery.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetStakersQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetStakersQuery
//          * @static
//          * @param {proto.CryptoGetStakersQuery} message CryptoGetStakersQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetStakersQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetStakersQuery to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetStakersQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetStakersQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetStakersQuery;
//     })();
// 
//     proto.ProxyStaker = (function() {
// 
//         /**
//          * Properties of a ProxyStaker.
//          * @memberof proto
//          * @interface IProxyStaker
//          * @property {proto.IAccountID|null} [accountID] ProxyStaker accountID
//          * @property {number|Long|null} [amount] ProxyStaker amount
//          */
// 
//         /**
//          * Constructs a new ProxyStaker.
//          * @memberof proto
//          * @classdesc Represents a ProxyStaker.
//          * @implements IProxyStaker
//          * @constructor
//          * @param {proto.IProxyStaker=} [properties] Properties to set
//          */
//         function ProxyStaker(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * ProxyStaker accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.ProxyStaker
//          * @instance
//          */
//         ProxyStaker.prototype.accountID = null;
// 
//         /**
//          * ProxyStaker amount.
//          * @member {number|Long} amount
//          * @memberof proto.ProxyStaker
//          * @instance
//          */
//         ProxyStaker.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//         /**
//          * Creates a new ProxyStaker instance using the specified properties.
//          * @function create
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {proto.IProxyStaker=} [properties] Properties to set
//          * @returns {proto.ProxyStaker} ProxyStaker instance
//          */
//         ProxyStaker.create = function create(properties) {
//             return new ProxyStaker(properties);
//         };
// 
//         /**
//          * Encodes the specified ProxyStaker message. Does not implicitly {@link proto.ProxyStaker.verify|verify} messages.
//          * @function encode
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {proto.IProxyStaker} message ProxyStaker message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ProxyStaker.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
//                 writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified ProxyStaker message, length delimited. Does not implicitly {@link proto.ProxyStaker.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {proto.IProxyStaker} message ProxyStaker message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         ProxyStaker.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a ProxyStaker message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.ProxyStaker} ProxyStaker
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ProxyStaker.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ProxyStaker();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.amount = reader.int64();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a ProxyStaker message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.ProxyStaker} ProxyStaker
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         ProxyStaker.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a ProxyStaker message.
//          * @function verify
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         ProxyStaker.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.amount != null && message.hasOwnProperty("amount"))
//                 if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
//                     return "amount: integer|Long expected";
//             return null;
//         };
// 
//         /**
//          * Creates a ProxyStaker message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.ProxyStaker} ProxyStaker
//          */
//         ProxyStaker.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.ProxyStaker)
//                 return object;
//             let message = new $root.proto.ProxyStaker();
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.ProxyStaker.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.amount != null)
//                 if ($util.Long)
//                     (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
//                 else if (typeof object.amount === "string")
//                     message.amount = parseInt(object.amount, 10);
//                 else if (typeof object.amount === "number")
//                     message.amount = object.amount;
//                 else if (typeof object.amount === "object")
//                     message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a ProxyStaker message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.ProxyStaker
//          * @static
//          * @param {proto.ProxyStaker} message ProxyStaker
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         ProxyStaker.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.accountID = null;
//                 if ($util.Long) {
//                     let long = new $util.Long(0, 0, false);
//                     object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                 } else
//                     object.amount = options.longs === String ? "0" : 0;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.amount != null && message.hasOwnProperty("amount"))
//                 if (typeof message.amount === "number")
//                     object.amount = options.longs === String ? String(message.amount) : message.amount;
//                 else
//                     object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
//             return object;
//         };
// 
//         /**
//          * Converts this ProxyStaker to JSON.
//          * @function toJSON
//          * @memberof proto.ProxyStaker
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         ProxyStaker.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return ProxyStaker;
//     })();
// 
//     proto.AllProxyStakers = (function() {
// 
//         /**
//          * Properties of an AllProxyStakers.
//          * @memberof proto
//          * @interface IAllProxyStakers
//          * @property {proto.IAccountID|null} [accountID] AllProxyStakers accountID
//          * @property {Array.<proto.IProxyStaker>|null} [proxyStaker] AllProxyStakers proxyStaker
//          */
// 
//         /**
//          * Constructs a new AllProxyStakers.
//          * @memberof proto
//          * @classdesc Represents an AllProxyStakers.
//          * @implements IAllProxyStakers
//          * @constructor
//          * @param {proto.IAllProxyStakers=} [properties] Properties to set
//          */
//         function AllProxyStakers(properties) {
//             this.proxyStaker = [];
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * AllProxyStakers accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.AllProxyStakers
//          * @instance
//          */
//         AllProxyStakers.prototype.accountID = null;
// 
//         /**
//          * AllProxyStakers proxyStaker.
//          * @member {Array.<proto.IProxyStaker>} proxyStaker
//          * @memberof proto.AllProxyStakers
//          * @instance
//          */
//         AllProxyStakers.prototype.proxyStaker = $util.emptyArray;
// 
//         /**
//          * Creates a new AllProxyStakers instance using the specified properties.
//          * @function create
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {proto.IAllProxyStakers=} [properties] Properties to set
//          * @returns {proto.AllProxyStakers} AllProxyStakers instance
//          */
//         AllProxyStakers.create = function create(properties) {
//             return new AllProxyStakers(properties);
//         };
// 
//         /**
//          * Encodes the specified AllProxyStakers message. Does not implicitly {@link proto.AllProxyStakers.verify|verify} messages.
//          * @function encode
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {proto.IAllProxyStakers} message AllProxyStakers message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         AllProxyStakers.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.proxyStaker != null && message.proxyStaker.length)
//                 for (let i = 0; i < message.proxyStaker.length; ++i)
//                     $root.proto.ProxyStaker.encode(message.proxyStaker[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified AllProxyStakers message, length delimited. Does not implicitly {@link proto.AllProxyStakers.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {proto.IAllProxyStakers} message AllProxyStakers message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         AllProxyStakers.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes an AllProxyStakers message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.AllProxyStakers} AllProxyStakers
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         AllProxyStakers.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AllProxyStakers();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     if (!(message.proxyStaker && message.proxyStaker.length))
//                         message.proxyStaker = [];
//                     message.proxyStaker.push($root.proto.ProxyStaker.decode(reader, reader.uint32()));
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes an AllProxyStakers message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.AllProxyStakers} AllProxyStakers
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         AllProxyStakers.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies an AllProxyStakers message.
//          * @function verify
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         AllProxyStakers.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.proxyStaker != null && message.hasOwnProperty("proxyStaker")) {
//                 if (!Array.isArray(message.proxyStaker))
//                     return "proxyStaker: array expected";
//                 for (let i = 0; i < message.proxyStaker.length; ++i) {
//                     let error = $root.proto.ProxyStaker.verify(message.proxyStaker[i]);
//                     if (error)
//                         return "proxyStaker." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates an AllProxyStakers message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.AllProxyStakers} AllProxyStakers
//          */
//         AllProxyStakers.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.AllProxyStakers)
//                 return object;
//             let message = new $root.proto.AllProxyStakers();
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.AllProxyStakers.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.proxyStaker) {
//                 if (!Array.isArray(object.proxyStaker))
//                     throw TypeError(".proto.AllProxyStakers.proxyStaker: array expected");
//                 message.proxyStaker = [];
//                 for (let i = 0; i < object.proxyStaker.length; ++i) {
//                     if (typeof object.proxyStaker[i] !== "object")
//                         throw TypeError(".proto.AllProxyStakers.proxyStaker: object expected");
//                     message.proxyStaker[i] = $root.proto.ProxyStaker.fromObject(object.proxyStaker[i]);
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from an AllProxyStakers message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.AllProxyStakers
//          * @static
//          * @param {proto.AllProxyStakers} message AllProxyStakers
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         AllProxyStakers.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.arrays || options.defaults)
//                 object.proxyStaker = [];
//             if (options.defaults)
//                 object.accountID = null;
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.proxyStaker && message.proxyStaker.length) {
//                 object.proxyStaker = [];
//                 for (let j = 0; j < message.proxyStaker.length; ++j)
//                     object.proxyStaker[j] = $root.proto.ProxyStaker.toObject(message.proxyStaker[j], options);
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this AllProxyStakers to JSON.
//          * @function toJSON
//          * @memberof proto.AllProxyStakers
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         AllProxyStakers.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return AllProxyStakers;
//     })();
// 
//     proto.CryptoGetStakersResponse = (function() {
// 
//         /**
//          * Properties of a CryptoGetStakersResponse.
//          * @memberof proto
//          * @interface ICryptoGetStakersResponse
//          * @property {proto.IResponseHeader|null} [header] CryptoGetStakersResponse header
//          * @property {proto.IAllProxyStakers|null} [stakers] CryptoGetStakersResponse stakers
//          */
// 
//         /**
//          * Constructs a new CryptoGetStakersResponse.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetStakersResponse.
//          * @implements ICryptoGetStakersResponse
//          * @constructor
//          * @param {proto.ICryptoGetStakersResponse=} [properties] Properties to set
//          */
//         function CryptoGetStakersResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetStakersResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.CryptoGetStakersResponse
//          * @instance
//          */
//         CryptoGetStakersResponse.prototype.header = null;
// 
//         /**
//          * CryptoGetStakersResponse stakers.
//          * @member {proto.IAllProxyStakers|null|undefined} stakers
//          * @memberof proto.CryptoGetStakersResponse
//          * @instance
//          */
//         CryptoGetStakersResponse.prototype.stakers = null;
// 
//         /**
//          * Creates a new CryptoGetStakersResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {proto.ICryptoGetStakersResponse=} [properties] Properties to set
//          * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse instance
//          */
//         CryptoGetStakersResponse.create = function create(properties) {
//             return new CryptoGetStakersResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetStakersResponse message. Does not implicitly {@link proto.CryptoGetStakersResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {proto.ICryptoGetStakersResponse} message CryptoGetStakersResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetStakersResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.stakers != null && Object.hasOwnProperty.call(message, "stakers"))
//                 $root.proto.AllProxyStakers.encode(message.stakers, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetStakersResponse message, length delimited. Does not implicitly {@link proto.CryptoGetStakersResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {proto.ICryptoGetStakersResponse} message CryptoGetStakersResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetStakersResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetStakersResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetStakersResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetStakersResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.stakers = $root.proto.AllProxyStakers.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetStakersResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetStakersResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetStakersResponse message.
//          * @function verify
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetStakersResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.stakers != null && message.hasOwnProperty("stakers")) {
//                 let error = $root.proto.AllProxyStakers.verify(message.stakers);
//                 if (error)
//                     return "stakers." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetStakersResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse
//          */
//         CryptoGetStakersResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetStakersResponse)
//                 return object;
//             let message = new $root.proto.CryptoGetStakersResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetStakersResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.stakers != null) {
//                 if (typeof object.stakers !== "object")
//                     throw TypeError(".proto.CryptoGetStakersResponse.stakers: object expected");
//                 message.stakers = $root.proto.AllProxyStakers.fromObject(object.stakers);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetStakersResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetStakersResponse
//          * @static
//          * @param {proto.CryptoGetStakersResponse} message CryptoGetStakersResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetStakersResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.stakers = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.stakers != null && message.hasOwnProperty("stakers"))
//                 object.stakers = $root.proto.AllProxyStakers.toObject(message.stakers, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetStakersResponse to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetStakersResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetStakersResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetStakersResponse;
//     })();
// 
//     proto.FileGetContentsQuery = (function() {
// 
//         /**
//          * Properties of a FileGetContentsQuery.
//          * @memberof proto
//          * @interface IFileGetContentsQuery
//          * @property {proto.IQueryHeader|null} [header] FileGetContentsQuery header
//          * @property {proto.IFileID|null} [fileID] FileGetContentsQuery fileID
//          */
// 
//         /**
//          * Constructs a new FileGetContentsQuery.
//          * @memberof proto
//          * @classdesc Represents a FileGetContentsQuery.
//          * @implements IFileGetContentsQuery
//          * @constructor
//          * @param {proto.IFileGetContentsQuery=} [properties] Properties to set
//          */
//         function FileGetContentsQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileGetContentsQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.FileGetContentsQuery
//          * @instance
//          */
//         FileGetContentsQuery.prototype.header = null;
// 
//         /**
//          * FileGetContentsQuery fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.FileGetContentsQuery
//          * @instance
//          */
//         FileGetContentsQuery.prototype.fileID = null;
// 
//         /**
//          * Creates a new FileGetContentsQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {proto.IFileGetContentsQuery=} [properties] Properties to set
//          * @returns {proto.FileGetContentsQuery} FileGetContentsQuery instance
//          */
//         FileGetContentsQuery.create = function create(properties) {
//             return new FileGetContentsQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified FileGetContentsQuery message. Does not implicitly {@link proto.FileGetContentsQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {proto.IFileGetContentsQuery} message FileGetContentsQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetContentsQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileGetContentsQuery message, length delimited. Does not implicitly {@link proto.FileGetContentsQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {proto.IFileGetContentsQuery} message FileGetContentsQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetContentsQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileGetContentsQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileGetContentsQuery} FileGetContentsQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetContentsQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileGetContentsQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileGetContentsQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileGetContentsQuery} FileGetContentsQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetContentsQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileGetContentsQuery message.
//          * @function verify
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileGetContentsQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FileGetContentsQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileGetContentsQuery} FileGetContentsQuery
//          */
//         FileGetContentsQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileGetContentsQuery)
//                 return object;
//             let message = new $root.proto.FileGetContentsQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.FileGetContentsQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.FileGetContentsQuery.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileGetContentsQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileGetContentsQuery
//          * @static
//          * @param {proto.FileGetContentsQuery} message FileGetContentsQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileGetContentsQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.fileID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FileGetContentsQuery to JSON.
//          * @function toJSON
//          * @memberof proto.FileGetContentsQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileGetContentsQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FileGetContentsQuery;
//     })();
// 
//     proto.FileGetContentsResponse = (function() {
// 
//         /**
//          * Properties of a FileGetContentsResponse.
//          * @memberof proto
//          * @interface IFileGetContentsResponse
//          * @property {proto.IResponseHeader|null} [header] FileGetContentsResponse header
//          * @property {proto.FileGetContentsResponse.IFileContents|null} [fileContents] FileGetContentsResponse fileContents
//          */
// 
//         /**
//          * Constructs a new FileGetContentsResponse.
//          * @memberof proto
//          * @classdesc Represents a FileGetContentsResponse.
//          * @implements IFileGetContentsResponse
//          * @constructor
//          * @param {proto.IFileGetContentsResponse=} [properties] Properties to set
//          */
//         function FileGetContentsResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileGetContentsResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.FileGetContentsResponse
//          * @instance
//          */
//         FileGetContentsResponse.prototype.header = null;
// 
//         /**
//          * FileGetContentsResponse fileContents.
//          * @member {proto.FileGetContentsResponse.IFileContents|null|undefined} fileContents
//          * @memberof proto.FileGetContentsResponse
//          * @instance
//          */
//         FileGetContentsResponse.prototype.fileContents = null;
// 
//         /**
//          * Creates a new FileGetContentsResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {proto.IFileGetContentsResponse=} [properties] Properties to set
//          * @returns {proto.FileGetContentsResponse} FileGetContentsResponse instance
//          */
//         FileGetContentsResponse.create = function create(properties) {
//             return new FileGetContentsResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified FileGetContentsResponse message. Does not implicitly {@link proto.FileGetContentsResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {proto.IFileGetContentsResponse} message FileGetContentsResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetContentsResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.fileContents != null && Object.hasOwnProperty.call(message, "fileContents"))
//                 $root.proto.FileGetContentsResponse.FileContents.encode(message.fileContents, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileGetContentsResponse message, length delimited. Does not implicitly {@link proto.FileGetContentsResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {proto.IFileGetContentsResponse} message FileGetContentsResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetContentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileGetContentsResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileGetContentsResponse} FileGetContentsResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetContentsResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileGetContentsResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.fileContents = $root.proto.FileGetContentsResponse.FileContents.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileGetContentsResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileGetContentsResponse} FileGetContentsResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetContentsResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileGetContentsResponse message.
//          * @function verify
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileGetContentsResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.fileContents != null && message.hasOwnProperty("fileContents")) {
//                 let error = $root.proto.FileGetContentsResponse.FileContents.verify(message.fileContents);
//                 if (error)
//                     return "fileContents." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FileGetContentsResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileGetContentsResponse} FileGetContentsResponse
//          */
//         FileGetContentsResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileGetContentsResponse)
//                 return object;
//             let message = new $root.proto.FileGetContentsResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.FileGetContentsResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.fileContents != null) {
//                 if (typeof object.fileContents !== "object")
//                     throw TypeError(".proto.FileGetContentsResponse.fileContents: object expected");
//                 message.fileContents = $root.proto.FileGetContentsResponse.FileContents.fromObject(object.fileContents);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileGetContentsResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileGetContentsResponse
//          * @static
//          * @param {proto.FileGetContentsResponse} message FileGetContentsResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileGetContentsResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.fileContents = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.fileContents != null && message.hasOwnProperty("fileContents"))
//                 object.fileContents = $root.proto.FileGetContentsResponse.FileContents.toObject(message.fileContents, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FileGetContentsResponse to JSON.
//          * @function toJSON
//          * @memberof proto.FileGetContentsResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileGetContentsResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         FileGetContentsResponse.FileContents = (function() {
// 
//             /**
//              * Properties of a FileContents.
//              * @memberof proto.FileGetContentsResponse
//              * @interface IFileContents
//              * @property {proto.IFileID|null} [fileID] FileContents fileID
//              * @property {Uint8Array|null} [contents] FileContents contents
//              */
// 
//             /**
//              * Constructs a new FileContents.
//              * @memberof proto.FileGetContentsResponse
//              * @classdesc Represents a FileContents.
//              * @implements IFileContents
//              * @constructor
//              * @param {proto.FileGetContentsResponse.IFileContents=} [properties] Properties to set
//              */
//             function FileContents(properties) {
//                 if (properties)
//                     for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                         if (properties[keys[i]] != null)
//                             this[keys[i]] = properties[keys[i]];
//             }
// 
//             /**
//              * FileContents fileID.
//              * @member {proto.IFileID|null|undefined} fileID
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @instance
//              */
//             FileContents.prototype.fileID = null;
// 
//             /**
//              * FileContents contents.
//              * @member {Uint8Array} contents
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @instance
//              */
//             FileContents.prototype.contents = $util.newBuffer([]);
// 
//             /**
//              * Creates a new FileContents instance using the specified properties.
//              * @function create
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {proto.FileGetContentsResponse.IFileContents=} [properties] Properties to set
//              * @returns {proto.FileGetContentsResponse.FileContents} FileContents instance
//              */
//             FileContents.create = function create(properties) {
//                 return new FileContents(properties);
//             };
// 
//             /**
//              * Encodes the specified FileContents message. Does not implicitly {@link proto.FileGetContentsResponse.FileContents.verify|verify} messages.
//              * @function encode
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {proto.FileGetContentsResponse.IFileContents} message FileContents message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             FileContents.encode = function encode(message, writer) {
//                 if (!writer)
//                     writer = $Writer.create();
//                 if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                     $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//                 if (message.contents != null && Object.hasOwnProperty.call(message, "contents"))
//                     writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contents);
//                 return writer;
//             };
// 
//             /**
//              * Encodes the specified FileContents message, length delimited. Does not implicitly {@link proto.FileGetContentsResponse.FileContents.verify|verify} messages.
//              * @function encodeDelimited
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {proto.FileGetContentsResponse.IFileContents} message FileContents message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             FileContents.encodeDelimited = function encodeDelimited(message, writer) {
//                 return this.encode(message, writer).ldelim();
//             };
// 
//             /**
//              * Decodes a FileContents message from the specified reader or buffer.
//              * @function decode
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @param {number} [length] Message length if known beforehand
//              * @returns {proto.FileGetContentsResponse.FileContents} FileContents
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             FileContents.decode = function decode(reader, length) {
//                 if (!(reader instanceof $Reader))
//                     reader = $Reader.create(reader);
//                 let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileGetContentsResponse.FileContents();
//                 while (reader.pos < end) {
//                     let tag = reader.uint32();
//                     switch (tag >>> 3) {
//                     case 1:
//                         message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                         break;
//                     case 2:
//                         message.contents = reader.bytes();
//                         break;
//                     default:
//                         reader.skipType(tag & 7);
//                         break;
//                     }
//                 }
//                 return message;
//             };
// 
//             /**
//              * Decodes a FileContents message from the specified reader or buffer, length delimited.
//              * @function decodeDelimited
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @returns {proto.FileGetContentsResponse.FileContents} FileContents
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             FileContents.decodeDelimited = function decodeDelimited(reader) {
//                 if (!(reader instanceof $Reader))
//                     reader = new $Reader(reader);
//                 return this.decode(reader, reader.uint32());
//             };
// 
//             /**
//              * Verifies a FileContents message.
//              * @function verify
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {Object.<string,*>} message Plain object to verify
//              * @returns {string|null} `null` if valid, otherwise the reason why it is not
//              */
//             FileContents.verify = function verify(message) {
//                 if (typeof message !== "object" || message === null)
//                     return "object expected";
//                 if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                     let error = $root.proto.FileID.verify(message.fileID);
//                     if (error)
//                         return "fileID." + error;
//                 }
//                 if (message.contents != null && message.hasOwnProperty("contents"))
//                     if (!(message.contents && typeof message.contents.length === "number" || $util.isString(message.contents)))
//                         return "contents: buffer expected";
//                 return null;
//             };
// 
//             /**
//              * Creates a FileContents message from a plain object. Also converts values to their respective internal types.
//              * @function fromObject
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {Object.<string,*>} object Plain object
//              * @returns {proto.FileGetContentsResponse.FileContents} FileContents
//              */
//             FileContents.fromObject = function fromObject(object) {
//                 if (object instanceof $root.proto.FileGetContentsResponse.FileContents)
//                     return object;
//                 let message = new $root.proto.FileGetContentsResponse.FileContents();
//                 if (object.fileID != null) {
//                     if (typeof object.fileID !== "object")
//                         throw TypeError(".proto.FileGetContentsResponse.FileContents.fileID: object expected");
//                     message.fileID = $root.proto.FileID.fromObject(object.fileID);
//                 }
//                 if (object.contents != null)
//                     if (typeof object.contents === "string")
//                         $util.base64.decode(object.contents, message.contents = $util.newBuffer($util.base64.length(object.contents)), 0);
//                     else if (object.contents.length)
//                         message.contents = object.contents;
//                 return message;
//             };
// 
//             /**
//              * Creates a plain object from a FileContents message. Also converts values to other types if specified.
//              * @function toObject
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @static
//              * @param {proto.FileGetContentsResponse.FileContents} message FileContents
//              * @param {$protobuf.IConversionOptions} [options] Conversion options
//              * @returns {Object.<string,*>} Plain object
//              */
//             FileContents.toObject = function toObject(message, options) {
//                 if (!options)
//                     options = {};
//                 let object = {};
//                 if (options.defaults) {
//                     object.fileID = null;
//                     if (options.bytes === String)
//                         object.contents = "";
//                     else {
//                         object.contents = [];
//                         if (options.bytes !== Array)
//                             object.contents = $util.newBuffer(object.contents);
//                     }
//                 }
//                 if (message.fileID != null && message.hasOwnProperty("fileID"))
//                     object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//                 if (message.contents != null && message.hasOwnProperty("contents"))
//                     object.contents = options.bytes === String ? $util.base64.encode(message.contents, 0, message.contents.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents) : message.contents;
//                 return object;
//             };
// 
//             /**
//              * Converts this FileContents to JSON.
//              * @function toJSON
//              * @memberof proto.FileGetContentsResponse.FileContents
//              * @instance
//              * @returns {Object.<string,*>} JSON object
//              */
//             FileContents.prototype.toJSON = function toJSON() {
//                 return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//             };
// 
//             return FileContents;
//         })();
// 
//         return FileGetContentsResponse;
//     })();
// 
//     proto.FileGetInfoQuery = (function() {
// 
//         /**
//          * Properties of a FileGetInfoQuery.
//          * @memberof proto
//          * @interface IFileGetInfoQuery
//          * @property {proto.IQueryHeader|null} [header] FileGetInfoQuery header
//          * @property {proto.IFileID|null} [fileID] FileGetInfoQuery fileID
//          */
// 
//         /**
//          * Constructs a new FileGetInfoQuery.
//          * @memberof proto
//          * @classdesc Represents a FileGetInfoQuery.
//          * @implements IFileGetInfoQuery
//          * @constructor
//          * @param {proto.IFileGetInfoQuery=} [properties] Properties to set
//          */
//         function FileGetInfoQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileGetInfoQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.FileGetInfoQuery
//          * @instance
//          */
//         FileGetInfoQuery.prototype.header = null;
// 
//         /**
//          * FileGetInfoQuery fileID.
//          * @member {proto.IFileID|null|undefined} fileID
//          * @memberof proto.FileGetInfoQuery
//          * @instance
//          */
//         FileGetInfoQuery.prototype.fileID = null;
// 
//         /**
//          * Creates a new FileGetInfoQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {proto.IFileGetInfoQuery=} [properties] Properties to set
//          * @returns {proto.FileGetInfoQuery} FileGetInfoQuery instance
//          */
//         FileGetInfoQuery.create = function create(properties) {
//             return new FileGetInfoQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified FileGetInfoQuery message. Does not implicitly {@link proto.FileGetInfoQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {proto.IFileGetInfoQuery} message FileGetInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetInfoQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                 $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileGetInfoQuery message, length delimited. Does not implicitly {@link proto.FileGetInfoQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {proto.IFileGetInfoQuery} message FileGetInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetInfoQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileGetInfoQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileGetInfoQuery} FileGetInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetInfoQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileGetInfoQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileGetInfoQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileGetInfoQuery} FileGetInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetInfoQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileGetInfoQuery message.
//          * @function verify
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileGetInfoQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                 let error = $root.proto.FileID.verify(message.fileID);
//                 if (error)
//                     return "fileID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FileGetInfoQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileGetInfoQuery} FileGetInfoQuery
//          */
//         FileGetInfoQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileGetInfoQuery)
//                 return object;
//             let message = new $root.proto.FileGetInfoQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.FileGetInfoQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.fileID != null) {
//                 if (typeof object.fileID !== "object")
//                     throw TypeError(".proto.FileGetInfoQuery.fileID: object expected");
//                 message.fileID = $root.proto.FileID.fromObject(object.fileID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileGetInfoQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileGetInfoQuery
//          * @static
//          * @param {proto.FileGetInfoQuery} message FileGetInfoQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileGetInfoQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.fileID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.fileID != null && message.hasOwnProperty("fileID"))
//                 object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FileGetInfoQuery to JSON.
//          * @function toJSON
//          * @memberof proto.FileGetInfoQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileGetInfoQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return FileGetInfoQuery;
//     })();
// 
//     proto.FileGetInfoResponse = (function() {
// 
//         /**
//          * Properties of a FileGetInfoResponse.
//          * @memberof proto
//          * @interface IFileGetInfoResponse
//          * @property {proto.IResponseHeader|null} [header] FileGetInfoResponse header
//          * @property {proto.FileGetInfoResponse.IFileInfo|null} [fileInfo] FileGetInfoResponse fileInfo
//          */
// 
//         /**
//          * Constructs a new FileGetInfoResponse.
//          * @memberof proto
//          * @classdesc Represents a FileGetInfoResponse.
//          * @implements IFileGetInfoResponse
//          * @constructor
//          * @param {proto.IFileGetInfoResponse=} [properties] Properties to set
//          */
//         function FileGetInfoResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * FileGetInfoResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.FileGetInfoResponse
//          * @instance
//          */
//         FileGetInfoResponse.prototype.header = null;
// 
//         /**
//          * FileGetInfoResponse fileInfo.
//          * @member {proto.FileGetInfoResponse.IFileInfo|null|undefined} fileInfo
//          * @memberof proto.FileGetInfoResponse
//          * @instance
//          */
//         FileGetInfoResponse.prototype.fileInfo = null;
// 
//         /**
//          * Creates a new FileGetInfoResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {proto.IFileGetInfoResponse=} [properties] Properties to set
//          * @returns {proto.FileGetInfoResponse} FileGetInfoResponse instance
//          */
//         FileGetInfoResponse.create = function create(properties) {
//             return new FileGetInfoResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified FileGetInfoResponse message. Does not implicitly {@link proto.FileGetInfoResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {proto.IFileGetInfoResponse} message FileGetInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetInfoResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.fileInfo != null && Object.hasOwnProperty.call(message, "fileInfo"))
//                 $root.proto.FileGetInfoResponse.FileInfo.encode(message.fileInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified FileGetInfoResponse message, length delimited. Does not implicitly {@link proto.FileGetInfoResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {proto.IFileGetInfoResponse} message FileGetInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         FileGetInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a FileGetInfoResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.FileGetInfoResponse} FileGetInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetInfoResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileGetInfoResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a FileGetInfoResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.FileGetInfoResponse} FileGetInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         FileGetInfoResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a FileGetInfoResponse message.
//          * @function verify
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         FileGetInfoResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.fileInfo != null && message.hasOwnProperty("fileInfo")) {
//                 let error = $root.proto.FileGetInfoResponse.FileInfo.verify(message.fileInfo);
//                 if (error)
//                     return "fileInfo." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a FileGetInfoResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.FileGetInfoResponse} FileGetInfoResponse
//          */
//         FileGetInfoResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.FileGetInfoResponse)
//                 return object;
//             let message = new $root.proto.FileGetInfoResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.FileGetInfoResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.fileInfo != null) {
//                 if (typeof object.fileInfo !== "object")
//                     throw TypeError(".proto.FileGetInfoResponse.fileInfo: object expected");
//                 message.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.fromObject(object.fileInfo);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a FileGetInfoResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.FileGetInfoResponse
//          * @static
//          * @param {proto.FileGetInfoResponse} message FileGetInfoResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         FileGetInfoResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.fileInfo = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.fileInfo != null && message.hasOwnProperty("fileInfo"))
//                 object.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.toObject(message.fileInfo, options);
//             return object;
//         };
// 
//         /**
//          * Converts this FileGetInfoResponse to JSON.
//          * @function toJSON
//          * @memberof proto.FileGetInfoResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         FileGetInfoResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         FileGetInfoResponse.FileInfo = (function() {
// 
//             /**
//              * Properties of a FileInfo.
//              * @memberof proto.FileGetInfoResponse
//              * @interface IFileInfo
//              * @property {proto.IFileID|null} [fileID] FileInfo fileID
//              * @property {number|Long|null} [size] FileInfo size
//              * @property {proto.ITimestamp|null} [expirationTime] FileInfo expirationTime
//              * @property {boolean|null} [deleted] FileInfo deleted
//              * @property {proto.IKeyList|null} [keys] FileInfo keys
//              */
// 
//             /**
//              * Constructs a new FileInfo.
//              * @memberof proto.FileGetInfoResponse
//              * @classdesc Represents a FileInfo.
//              * @implements IFileInfo
//              * @constructor
//              * @param {proto.FileGetInfoResponse.IFileInfo=} [properties] Properties to set
//              */
//             function FileInfo(properties) {
//                 if (properties)
//                     for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                         if (properties[keys[i]] != null)
//                             this[keys[i]] = properties[keys[i]];
//             }
// 
//             /**
//              * FileInfo fileID.
//              * @member {proto.IFileID|null|undefined} fileID
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @instance
//              */
//             FileInfo.prototype.fileID = null;
// 
//             /**
//              * FileInfo size.
//              * @member {number|Long} size
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @instance
//              */
//             FileInfo.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
// 
//             /**
//              * FileInfo expirationTime.
//              * @member {proto.ITimestamp|null|undefined} expirationTime
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @instance
//              */
//             FileInfo.prototype.expirationTime = null;
// 
//             /**
//              * FileInfo deleted.
//              * @member {boolean} deleted
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @instance
//              */
//             FileInfo.prototype.deleted = false;
// 
//             /**
//              * FileInfo keys.
//              * @member {proto.IKeyList|null|undefined} keys
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @instance
//              */
//             FileInfo.prototype.keys = null;
// 
//             /**
//              * Creates a new FileInfo instance using the specified properties.
//              * @function create
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {proto.FileGetInfoResponse.IFileInfo=} [properties] Properties to set
//              * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo instance
//              */
//             FileInfo.create = function create(properties) {
//                 return new FileInfo(properties);
//             };
// 
//             /**
//              * Encodes the specified FileInfo message. Does not implicitly {@link proto.FileGetInfoResponse.FileInfo.verify|verify} messages.
//              * @function encode
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {proto.FileGetInfoResponse.IFileInfo} message FileInfo message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             FileInfo.encode = function encode(message, writer) {
//                 if (!writer)
//                     writer = $Writer.create();
//                 if (message.fileID != null && Object.hasOwnProperty.call(message, "fileID"))
//                     $root.proto.FileID.encode(message.fileID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//                 if (message.size != null && Object.hasOwnProperty.call(message, "size"))
//                     writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size);
//                 if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
//                     $root.proto.Timestamp.encode(message.expirationTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//                 if (message.deleted != null && Object.hasOwnProperty.call(message, "deleted"))
//                     writer.uint32(/* id 4, wireType 0 =*/32).bool(message.deleted);
//                 if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
//                     $root.proto.KeyList.encode(message.keys, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//                 return writer;
//             };
// 
//             /**
//              * Encodes the specified FileInfo message, length delimited. Does not implicitly {@link proto.FileGetInfoResponse.FileInfo.verify|verify} messages.
//              * @function encodeDelimited
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {proto.FileGetInfoResponse.IFileInfo} message FileInfo message or plain object to encode
//              * @param {$protobuf.Writer} [writer] Writer to encode to
//              * @returns {$protobuf.Writer} Writer
//              */
//             FileInfo.encodeDelimited = function encodeDelimited(message, writer) {
//                 return this.encode(message, writer).ldelim();
//             };
// 
//             /**
//              * Decodes a FileInfo message from the specified reader or buffer.
//              * @function decode
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @param {number} [length] Message length if known beforehand
//              * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             FileInfo.decode = function decode(reader, length) {
//                 if (!(reader instanceof $Reader))
//                     reader = $Reader.create(reader);
//                 let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileGetInfoResponse.FileInfo();
//                 while (reader.pos < end) {
//                     let tag = reader.uint32();
//                     switch (tag >>> 3) {
//                     case 1:
//                         message.fileID = $root.proto.FileID.decode(reader, reader.uint32());
//                         break;
//                     case 2:
//                         message.size = reader.int64();
//                         break;
//                     case 3:
//                         message.expirationTime = $root.proto.Timestamp.decode(reader, reader.uint32());
//                         break;
//                     case 4:
//                         message.deleted = reader.bool();
//                         break;
//                     case 5:
//                         message.keys = $root.proto.KeyList.decode(reader, reader.uint32());
//                         break;
//                     default:
//                         reader.skipType(tag & 7);
//                         break;
//                     }
//                 }
//                 return message;
//             };
// 
//             /**
//              * Decodes a FileInfo message from the specified reader or buffer, length delimited.
//              * @function decodeDelimited
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//              * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo
//              * @throws {Error} If the payload is not a reader or valid buffer
//              * @throws {$protobuf.util.ProtocolError} If required fields are missing
//              */
//             FileInfo.decodeDelimited = function decodeDelimited(reader) {
//                 if (!(reader instanceof $Reader))
//                     reader = new $Reader(reader);
//                 return this.decode(reader, reader.uint32());
//             };
// 
//             /**
//              * Verifies a FileInfo message.
//              * @function verify
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {Object.<string,*>} message Plain object to verify
//              * @returns {string|null} `null` if valid, otherwise the reason why it is not
//              */
//             FileInfo.verify = function verify(message) {
//                 if (typeof message !== "object" || message === null)
//                     return "object expected";
//                 if (message.fileID != null && message.hasOwnProperty("fileID")) {
//                     let error = $root.proto.FileID.verify(message.fileID);
//                     if (error)
//                         return "fileID." + error;
//                 }
//                 if (message.size != null && message.hasOwnProperty("size"))
//                     if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
//                         return "size: integer|Long expected";
//                 if (message.expirationTime != null && message.hasOwnProperty("expirationTime")) {
//                     let error = $root.proto.Timestamp.verify(message.expirationTime);
//                     if (error)
//                         return "expirationTime." + error;
//                 }
//                 if (message.deleted != null && message.hasOwnProperty("deleted"))
//                     if (typeof message.deleted !== "boolean")
//                         return "deleted: boolean expected";
//                 if (message.keys != null && message.hasOwnProperty("keys")) {
//                     let error = $root.proto.KeyList.verify(message.keys);
//                     if (error)
//                         return "keys." + error;
//                 }
//                 return null;
//             };
// 
//             /**
//              * Creates a FileInfo message from a plain object. Also converts values to their respective internal types.
//              * @function fromObject
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {Object.<string,*>} object Plain object
//              * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo
//              */
//             FileInfo.fromObject = function fromObject(object) {
//                 if (object instanceof $root.proto.FileGetInfoResponse.FileInfo)
//                     return object;
//                 let message = new $root.proto.FileGetInfoResponse.FileInfo();
//                 if (object.fileID != null) {
//                     if (typeof object.fileID !== "object")
//                         throw TypeError(".proto.FileGetInfoResponse.FileInfo.fileID: object expected");
//                     message.fileID = $root.proto.FileID.fromObject(object.fileID);
//                 }
//                 if (object.size != null)
//                     if ($util.Long)
//                         (message.size = $util.Long.fromValue(object.size)).unsigned = false;
//                     else if (typeof object.size === "string")
//                         message.size = parseInt(object.size, 10);
//                     else if (typeof object.size === "number")
//                         message.size = object.size;
//                     else if (typeof object.size === "object")
//                         message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
//                 if (object.expirationTime != null) {
//                     if (typeof object.expirationTime !== "object")
//                         throw TypeError(".proto.FileGetInfoResponse.FileInfo.expirationTime: object expected");
//                     message.expirationTime = $root.proto.Timestamp.fromObject(object.expirationTime);
//                 }
//                 if (object.deleted != null)
//                     message.deleted = Boolean(object.deleted);
//                 if (object.keys != null) {
//                     if (typeof object.keys !== "object")
//                         throw TypeError(".proto.FileGetInfoResponse.FileInfo.keys: object expected");
//                     message.keys = $root.proto.KeyList.fromObject(object.keys);
//                 }
//                 return message;
//             };
// 
//             /**
//              * Creates a plain object from a FileInfo message. Also converts values to other types if specified.
//              * @function toObject
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @static
//              * @param {proto.FileGetInfoResponse.FileInfo} message FileInfo
//              * @param {$protobuf.IConversionOptions} [options] Conversion options
//              * @returns {Object.<string,*>} Plain object
//              */
//             FileInfo.toObject = function toObject(message, options) {
//                 if (!options)
//                     options = {};
//                 let object = {};
//                 if (options.defaults) {
//                     object.fileID = null;
//                     if ($util.Long) {
//                         let long = new $util.Long(0, 0, false);
//                         object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
//                     } else
//                         object.size = options.longs === String ? "0" : 0;
//                     object.expirationTime = null;
//                     object.deleted = false;
//                     object.keys = null;
//                 }
//                 if (message.fileID != null && message.hasOwnProperty("fileID"))
//                     object.fileID = $root.proto.FileID.toObject(message.fileID, options);
//                 if (message.size != null && message.hasOwnProperty("size"))
//                     if (typeof message.size === "number")
//                         object.size = options.longs === String ? String(message.size) : message.size;
//                     else
//                         object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
//                 if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
//                     object.expirationTime = $root.proto.Timestamp.toObject(message.expirationTime, options);
//                 if (message.deleted != null && message.hasOwnProperty("deleted"))
//                     object.deleted = message.deleted;
//                 if (message.keys != null && message.hasOwnProperty("keys"))
//                     object.keys = $root.proto.KeyList.toObject(message.keys, options);
//                 return object;
//             };
// 
//             /**
//              * Converts this FileInfo to JSON.
//              * @function toJSON
//              * @memberof proto.FileGetInfoResponse.FileInfo
//              * @instance
//              * @returns {Object.<string,*>} JSON object
//              */
//             FileInfo.prototype.toJSON = function toJSON() {
//                 return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//             };
// 
//             return FileInfo;
//         })();
// 
//         return FileGetInfoResponse;
//     })();
// 
//     proto.TransactionGetReceiptQuery = (function() {
// 
//         /**
//          * Properties of a TransactionGetReceiptQuery.
//          * @memberof proto
//          * @interface ITransactionGetReceiptQuery
//          * @property {proto.IQueryHeader|null} [header] TransactionGetReceiptQuery header
//          * @property {proto.ITransactionID|null} [transactionID] TransactionGetReceiptQuery transactionID
//          */
// 
//         /**
//          * Constructs a new TransactionGetReceiptQuery.
//          * @memberof proto
//          * @classdesc Represents a TransactionGetReceiptQuery.
//          * @implements ITransactionGetReceiptQuery
//          * @constructor
//          * @param {proto.ITransactionGetReceiptQuery=} [properties] Properties to set
//          */
//         function TransactionGetReceiptQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionGetReceiptQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.TransactionGetReceiptQuery
//          * @instance
//          */
//         TransactionGetReceiptQuery.prototype.header = null;
// 
//         /**
//          * TransactionGetReceiptQuery transactionID.
//          * @member {proto.ITransactionID|null|undefined} transactionID
//          * @memberof proto.TransactionGetReceiptQuery
//          * @instance
//          */
//         TransactionGetReceiptQuery.prototype.transactionID = null;
// 
//         /**
//          * Creates a new TransactionGetReceiptQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {proto.ITransactionGetReceiptQuery=} [properties] Properties to set
//          * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery instance
//          */
//         TransactionGetReceiptQuery.create = function create(properties) {
//             return new TransactionGetReceiptQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionGetReceiptQuery message. Does not implicitly {@link proto.TransactionGetReceiptQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {proto.ITransactionGetReceiptQuery} message TransactionGetReceiptQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetReceiptQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.transactionID != null && Object.hasOwnProperty.call(message, "transactionID"))
//                 $root.proto.TransactionID.encode(message.transactionID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionGetReceiptQuery message, length delimited. Does not implicitly {@link proto.TransactionGetReceiptQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {proto.ITransactionGetReceiptQuery} message TransactionGetReceiptQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetReceiptQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionGetReceiptQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetReceiptQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionGetReceiptQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.transactionID = $root.proto.TransactionID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionGetReceiptQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetReceiptQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionGetReceiptQuery message.
//          * @function verify
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionGetReceiptQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.transactionID != null && message.hasOwnProperty("transactionID")) {
//                 let error = $root.proto.TransactionID.verify(message.transactionID);
//                 if (error)
//                     return "transactionID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionGetReceiptQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery
//          */
//         TransactionGetReceiptQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionGetReceiptQuery)
//                 return object;
//             let message = new $root.proto.TransactionGetReceiptQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.TransactionGetReceiptQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.transactionID != null) {
//                 if (typeof object.transactionID !== "object")
//                     throw TypeError(".proto.TransactionGetReceiptQuery.transactionID: object expected");
//                 message.transactionID = $root.proto.TransactionID.fromObject(object.transactionID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionGetReceiptQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionGetReceiptQuery
//          * @static
//          * @param {proto.TransactionGetReceiptQuery} message TransactionGetReceiptQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionGetReceiptQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.transactionID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.transactionID != null && message.hasOwnProperty("transactionID"))
//                 object.transactionID = $root.proto.TransactionID.toObject(message.transactionID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionGetReceiptQuery to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionGetReceiptQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionGetReceiptQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionGetReceiptQuery;
//     })();
// 
//     proto.TransactionGetReceiptResponse = (function() {
// 
//         /**
//          * Properties of a TransactionGetReceiptResponse.
//          * @memberof proto
//          * @interface ITransactionGetReceiptResponse
//          * @property {proto.IResponseHeader|null} [header] TransactionGetReceiptResponse header
//          * @property {proto.ITransactionReceipt|null} [receipt] TransactionGetReceiptResponse receipt
//          */
// 
//         /**
//          * Constructs a new TransactionGetReceiptResponse.
//          * @memberof proto
//          * @classdesc Represents a TransactionGetReceiptResponse.
//          * @implements ITransactionGetReceiptResponse
//          * @constructor
//          * @param {proto.ITransactionGetReceiptResponse=} [properties] Properties to set
//          */
//         function TransactionGetReceiptResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionGetReceiptResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.TransactionGetReceiptResponse
//          * @instance
//          */
//         TransactionGetReceiptResponse.prototype.header = null;
// 
//         /**
//          * TransactionGetReceiptResponse receipt.
//          * @member {proto.ITransactionReceipt|null|undefined} receipt
//          * @memberof proto.TransactionGetReceiptResponse
//          * @instance
//          */
//         TransactionGetReceiptResponse.prototype.receipt = null;
// 
//         /**
//          * Creates a new TransactionGetReceiptResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {proto.ITransactionGetReceiptResponse=} [properties] Properties to set
//          * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse instance
//          */
//         TransactionGetReceiptResponse.create = function create(properties) {
//             return new TransactionGetReceiptResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionGetReceiptResponse message. Does not implicitly {@link proto.TransactionGetReceiptResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {proto.ITransactionGetReceiptResponse} message TransactionGetReceiptResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetReceiptResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
//                 $root.proto.TransactionReceipt.encode(message.receipt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionGetReceiptResponse message, length delimited. Does not implicitly {@link proto.TransactionGetReceiptResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {proto.ITransactionGetReceiptResponse} message TransactionGetReceiptResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetReceiptResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionGetReceiptResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetReceiptResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionGetReceiptResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.receipt = $root.proto.TransactionReceipt.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionGetReceiptResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetReceiptResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionGetReceiptResponse message.
//          * @function verify
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionGetReceiptResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.receipt != null && message.hasOwnProperty("receipt")) {
//                 let error = $root.proto.TransactionReceipt.verify(message.receipt);
//                 if (error)
//                     return "receipt." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionGetReceiptResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse
//          */
//         TransactionGetReceiptResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionGetReceiptResponse)
//                 return object;
//             let message = new $root.proto.TransactionGetReceiptResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.TransactionGetReceiptResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.receipt != null) {
//                 if (typeof object.receipt !== "object")
//                     throw TypeError(".proto.TransactionGetReceiptResponse.receipt: object expected");
//                 message.receipt = $root.proto.TransactionReceipt.fromObject(object.receipt);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionGetReceiptResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionGetReceiptResponse
//          * @static
//          * @param {proto.TransactionGetReceiptResponse} message TransactionGetReceiptResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionGetReceiptResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.receipt = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.receipt != null && message.hasOwnProperty("receipt"))
//                 object.receipt = $root.proto.TransactionReceipt.toObject(message.receipt, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionGetReceiptResponse to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionGetReceiptResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionGetReceiptResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionGetReceiptResponse;
//     })();
// 
//     proto.TransactionGetRecordQuery = (function() {
// 
//         /**
//          * Properties of a TransactionGetRecordQuery.
//          * @memberof proto
//          * @interface ITransactionGetRecordQuery
//          * @property {proto.IQueryHeader|null} [header] TransactionGetRecordQuery header
//          * @property {proto.ITransactionID|null} [transactionID] TransactionGetRecordQuery transactionID
//          */
// 
//         /**
//          * Constructs a new TransactionGetRecordQuery.
//          * @memberof proto
//          * @classdesc Represents a TransactionGetRecordQuery.
//          * @implements ITransactionGetRecordQuery
//          * @constructor
//          * @param {proto.ITransactionGetRecordQuery=} [properties] Properties to set
//          */
//         function TransactionGetRecordQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionGetRecordQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.TransactionGetRecordQuery
//          * @instance
//          */
//         TransactionGetRecordQuery.prototype.header = null;
// 
//         /**
//          * TransactionGetRecordQuery transactionID.
//          * @member {proto.ITransactionID|null|undefined} transactionID
//          * @memberof proto.TransactionGetRecordQuery
//          * @instance
//          */
//         TransactionGetRecordQuery.prototype.transactionID = null;
// 
//         /**
//          * Creates a new TransactionGetRecordQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {proto.ITransactionGetRecordQuery=} [properties] Properties to set
//          * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery instance
//          */
//         TransactionGetRecordQuery.create = function create(properties) {
//             return new TransactionGetRecordQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionGetRecordQuery message. Does not implicitly {@link proto.TransactionGetRecordQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {proto.ITransactionGetRecordQuery} message TransactionGetRecordQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetRecordQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.transactionID != null && Object.hasOwnProperty.call(message, "transactionID"))
//                 $root.proto.TransactionID.encode(message.transactionID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionGetRecordQuery message, length delimited. Does not implicitly {@link proto.TransactionGetRecordQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {proto.ITransactionGetRecordQuery} message TransactionGetRecordQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetRecordQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionGetRecordQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetRecordQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionGetRecordQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.transactionID = $root.proto.TransactionID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionGetRecordQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetRecordQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionGetRecordQuery message.
//          * @function verify
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionGetRecordQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.transactionID != null && message.hasOwnProperty("transactionID")) {
//                 let error = $root.proto.TransactionID.verify(message.transactionID);
//                 if (error)
//                     return "transactionID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionGetRecordQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery
//          */
//         TransactionGetRecordQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionGetRecordQuery)
//                 return object;
//             let message = new $root.proto.TransactionGetRecordQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.TransactionGetRecordQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.transactionID != null) {
//                 if (typeof object.transactionID !== "object")
//                     throw TypeError(".proto.TransactionGetRecordQuery.transactionID: object expected");
//                 message.transactionID = $root.proto.TransactionID.fromObject(object.transactionID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionGetRecordQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionGetRecordQuery
//          * @static
//          * @param {proto.TransactionGetRecordQuery} message TransactionGetRecordQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionGetRecordQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.transactionID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.transactionID != null && message.hasOwnProperty("transactionID"))
//                 object.transactionID = $root.proto.TransactionID.toObject(message.transactionID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionGetRecordQuery to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionGetRecordQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionGetRecordQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionGetRecordQuery;
//     })();
// 
//     proto.TransactionGetRecordResponse = (function() {
// 
//         /**
//          * Properties of a TransactionGetRecordResponse.
//          * @memberof proto
//          * @interface ITransactionGetRecordResponse
//          * @property {proto.IResponseHeader|null} [header] TransactionGetRecordResponse header
//          * @property {proto.ITransactionRecord|null} [transactionRecord] TransactionGetRecordResponse transactionRecord
//          */
// 
//         /**
//          * Constructs a new TransactionGetRecordResponse.
//          * @memberof proto
//          * @classdesc Represents a TransactionGetRecordResponse.
//          * @implements ITransactionGetRecordResponse
//          * @constructor
//          * @param {proto.ITransactionGetRecordResponse=} [properties] Properties to set
//          */
//         function TransactionGetRecordResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionGetRecordResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.TransactionGetRecordResponse
//          * @instance
//          */
//         TransactionGetRecordResponse.prototype.header = null;
// 
//         /**
//          * TransactionGetRecordResponse transactionRecord.
//          * @member {proto.ITransactionRecord|null|undefined} transactionRecord
//          * @memberof proto.TransactionGetRecordResponse
//          * @instance
//          */
//         TransactionGetRecordResponse.prototype.transactionRecord = null;
// 
//         /**
//          * Creates a new TransactionGetRecordResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {proto.ITransactionGetRecordResponse=} [properties] Properties to set
//          * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse instance
//          */
//         TransactionGetRecordResponse.create = function create(properties) {
//             return new TransactionGetRecordResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionGetRecordResponse message. Does not implicitly {@link proto.TransactionGetRecordResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {proto.ITransactionGetRecordResponse} message TransactionGetRecordResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetRecordResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.transactionRecord != null && Object.hasOwnProperty.call(message, "transactionRecord"))
//                 $root.proto.TransactionRecord.encode(message.transactionRecord, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionGetRecordResponse message, length delimited. Does not implicitly {@link proto.TransactionGetRecordResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {proto.ITransactionGetRecordResponse} message TransactionGetRecordResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionGetRecordResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetRecordResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionGetRecordResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.transactionRecord = $root.proto.TransactionRecord.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionGetRecordResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetRecordResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionGetRecordResponse message.
//          * @function verify
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionGetRecordResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.transactionRecord != null && message.hasOwnProperty("transactionRecord")) {
//                 let error = $root.proto.TransactionRecord.verify(message.transactionRecord);
//                 if (error)
//                     return "transactionRecord." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionGetRecordResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse
//          */
//         TransactionGetRecordResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionGetRecordResponse)
//                 return object;
//             let message = new $root.proto.TransactionGetRecordResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.TransactionGetRecordResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.transactionRecord != null) {
//                 if (typeof object.transactionRecord !== "object")
//                     throw TypeError(".proto.TransactionGetRecordResponse.transactionRecord: object expected");
//                 message.transactionRecord = $root.proto.TransactionRecord.fromObject(object.transactionRecord);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionGetRecordResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionGetRecordResponse
//          * @static
//          * @param {proto.TransactionGetRecordResponse} message TransactionGetRecordResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionGetRecordResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.transactionRecord = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.transactionRecord != null && message.hasOwnProperty("transactionRecord"))
//                 object.transactionRecord = $root.proto.TransactionRecord.toObject(message.transactionRecord, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionGetRecordResponse to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionGetRecordResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionGetRecordResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionGetRecordResponse;
//     })();
// 
//     proto.TransactionGetFastRecordQuery = (function() {
// 
//         /**
//          * Properties of a TransactionGetFastRecordQuery.
//          * @memberof proto
//          * @interface ITransactionGetFastRecordQuery
//          * @property {proto.IQueryHeader|null} [header] TransactionGetFastRecordQuery header
//          * @property {proto.ITransactionID|null} [transactionID] TransactionGetFastRecordQuery transactionID
//          */
// 
//         /**
//          * Constructs a new TransactionGetFastRecordQuery.
//          * @memberof proto
//          * @classdesc Represents a TransactionGetFastRecordQuery.
//          * @implements ITransactionGetFastRecordQuery
//          * @constructor
//          * @param {proto.ITransactionGetFastRecordQuery=} [properties] Properties to set
//          */
//         function TransactionGetFastRecordQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionGetFastRecordQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @instance
//          */
//         TransactionGetFastRecordQuery.prototype.header = null;
// 
//         /**
//          * TransactionGetFastRecordQuery transactionID.
//          * @member {proto.ITransactionID|null|undefined} transactionID
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @instance
//          */
//         TransactionGetFastRecordQuery.prototype.transactionID = null;
// 
//         /**
//          * Creates a new TransactionGetFastRecordQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {proto.ITransactionGetFastRecordQuery=} [properties] Properties to set
//          * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery instance
//          */
//         TransactionGetFastRecordQuery.create = function create(properties) {
//             return new TransactionGetFastRecordQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionGetFastRecordQuery message. Does not implicitly {@link proto.TransactionGetFastRecordQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {proto.ITransactionGetFastRecordQuery} message TransactionGetFastRecordQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetFastRecordQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.transactionID != null && Object.hasOwnProperty.call(message, "transactionID"))
//                 $root.proto.TransactionID.encode(message.transactionID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionGetFastRecordQuery message, length delimited. Does not implicitly {@link proto.TransactionGetFastRecordQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {proto.ITransactionGetFastRecordQuery} message TransactionGetFastRecordQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetFastRecordQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionGetFastRecordQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetFastRecordQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionGetFastRecordQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.transactionID = $root.proto.TransactionID.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionGetFastRecordQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetFastRecordQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionGetFastRecordQuery message.
//          * @function verify
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionGetFastRecordQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.transactionID != null && message.hasOwnProperty("transactionID")) {
//                 let error = $root.proto.TransactionID.verify(message.transactionID);
//                 if (error)
//                     return "transactionID." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionGetFastRecordQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery
//          */
//         TransactionGetFastRecordQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionGetFastRecordQuery)
//                 return object;
//             let message = new $root.proto.TransactionGetFastRecordQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.TransactionGetFastRecordQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.transactionID != null) {
//                 if (typeof object.transactionID !== "object")
//                     throw TypeError(".proto.TransactionGetFastRecordQuery.transactionID: object expected");
//                 message.transactionID = $root.proto.TransactionID.fromObject(object.transactionID);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionGetFastRecordQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @static
//          * @param {proto.TransactionGetFastRecordQuery} message TransactionGetFastRecordQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionGetFastRecordQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.transactionID = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.transactionID != null && message.hasOwnProperty("transactionID"))
//                 object.transactionID = $root.proto.TransactionID.toObject(message.transactionID, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionGetFastRecordQuery to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionGetFastRecordQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionGetFastRecordQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionGetFastRecordQuery;
//     })();
// 
//     proto.TransactionGetFastRecordResponse = (function() {
// 
//         /**
//          * Properties of a TransactionGetFastRecordResponse.
//          * @memberof proto
//          * @interface ITransactionGetFastRecordResponse
//          * @property {proto.IResponseHeader|null} [header] TransactionGetFastRecordResponse header
//          * @property {proto.ITransactionRecord|null} [transactionRecord] TransactionGetFastRecordResponse transactionRecord
//          */
// 
//         /**
//          * Constructs a new TransactionGetFastRecordResponse.
//          * @memberof proto
//          * @classdesc Represents a TransactionGetFastRecordResponse.
//          * @implements ITransactionGetFastRecordResponse
//          * @constructor
//          * @param {proto.ITransactionGetFastRecordResponse=} [properties] Properties to set
//          */
//         function TransactionGetFastRecordResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * TransactionGetFastRecordResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @instance
//          */
//         TransactionGetFastRecordResponse.prototype.header = null;
// 
//         /**
//          * TransactionGetFastRecordResponse transactionRecord.
//          * @member {proto.ITransactionRecord|null|undefined} transactionRecord
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @instance
//          */
//         TransactionGetFastRecordResponse.prototype.transactionRecord = null;
// 
//         /**
//          * Creates a new TransactionGetFastRecordResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {proto.ITransactionGetFastRecordResponse=} [properties] Properties to set
//          * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse instance
//          */
//         TransactionGetFastRecordResponse.create = function create(properties) {
//             return new TransactionGetFastRecordResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified TransactionGetFastRecordResponse message. Does not implicitly {@link proto.TransactionGetFastRecordResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {proto.ITransactionGetFastRecordResponse} message TransactionGetFastRecordResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetFastRecordResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.transactionRecord != null && Object.hasOwnProperty.call(message, "transactionRecord"))
//                 $root.proto.TransactionRecord.encode(message.transactionRecord, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified TransactionGetFastRecordResponse message, length delimited. Does not implicitly {@link proto.TransactionGetFastRecordResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {proto.ITransactionGetFastRecordResponse} message TransactionGetFastRecordResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         TransactionGetFastRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a TransactionGetFastRecordResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetFastRecordResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionGetFastRecordResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.transactionRecord = $root.proto.TransactionRecord.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a TransactionGetFastRecordResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         TransactionGetFastRecordResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a TransactionGetFastRecordResponse message.
//          * @function verify
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         TransactionGetFastRecordResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.transactionRecord != null && message.hasOwnProperty("transactionRecord")) {
//                 let error = $root.proto.TransactionRecord.verify(message.transactionRecord);
//                 if (error)
//                     return "transactionRecord." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a TransactionGetFastRecordResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse
//          */
//         TransactionGetFastRecordResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.TransactionGetFastRecordResponse)
//                 return object;
//             let message = new $root.proto.TransactionGetFastRecordResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.TransactionGetFastRecordResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.transactionRecord != null) {
//                 if (typeof object.transactionRecord !== "object")
//                     throw TypeError(".proto.TransactionGetFastRecordResponse.transactionRecord: object expected");
//                 message.transactionRecord = $root.proto.TransactionRecord.fromObject(object.transactionRecord);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a TransactionGetFastRecordResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @static
//          * @param {proto.TransactionGetFastRecordResponse} message TransactionGetFastRecordResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         TransactionGetFastRecordResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.transactionRecord = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.transactionRecord != null && message.hasOwnProperty("transactionRecord"))
//                 object.transactionRecord = $root.proto.TransactionRecord.toObject(message.transactionRecord, options);
//             return object;
//         };
// 
//         /**
//          * Converts this TransactionGetFastRecordResponse to JSON.
//          * @function toJSON
//          * @memberof proto.TransactionGetFastRecordResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         TransactionGetFastRecordResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return TransactionGetFastRecordResponse;
//     })();
// 
//     proto.NetworkGetVersionInfoQuery = (function() {
// 
//         /**
//          * Properties of a NetworkGetVersionInfoQuery.
//          * @memberof proto
//          * @interface INetworkGetVersionInfoQuery
//          * @property {proto.IQueryHeader|null} [header] NetworkGetVersionInfoQuery header
//          */
// 
//         /**
//          * Constructs a new NetworkGetVersionInfoQuery.
//          * @memberof proto
//          * @classdesc Represents a NetworkGetVersionInfoQuery.
//          * @implements INetworkGetVersionInfoQuery
//          * @constructor
//          * @param {proto.INetworkGetVersionInfoQuery=} [properties] Properties to set
//          */
//         function NetworkGetVersionInfoQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * NetworkGetVersionInfoQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @instance
//          */
//         NetworkGetVersionInfoQuery.prototype.header = null;
// 
//         /**
//          * Creates a new NetworkGetVersionInfoQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {proto.INetworkGetVersionInfoQuery=} [properties] Properties to set
//          * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery instance
//          */
//         NetworkGetVersionInfoQuery.create = function create(properties) {
//             return new NetworkGetVersionInfoQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified NetworkGetVersionInfoQuery message. Does not implicitly {@link proto.NetworkGetVersionInfoQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {proto.INetworkGetVersionInfoQuery} message NetworkGetVersionInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NetworkGetVersionInfoQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified NetworkGetVersionInfoQuery message, length delimited. Does not implicitly {@link proto.NetworkGetVersionInfoQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {proto.INetworkGetVersionInfoQuery} message NetworkGetVersionInfoQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NetworkGetVersionInfoQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a NetworkGetVersionInfoQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NetworkGetVersionInfoQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NetworkGetVersionInfoQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a NetworkGetVersionInfoQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NetworkGetVersionInfoQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a NetworkGetVersionInfoQuery message.
//          * @function verify
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         NetworkGetVersionInfoQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a NetworkGetVersionInfoQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery
//          */
//         NetworkGetVersionInfoQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.NetworkGetVersionInfoQuery)
//                 return object;
//             let message = new $root.proto.NetworkGetVersionInfoQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.NetworkGetVersionInfoQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a NetworkGetVersionInfoQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @static
//          * @param {proto.NetworkGetVersionInfoQuery} message NetworkGetVersionInfoQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         NetworkGetVersionInfoQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.header = null;
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             return object;
//         };
// 
//         /**
//          * Converts this NetworkGetVersionInfoQuery to JSON.
//          * @function toJSON
//          * @memberof proto.NetworkGetVersionInfoQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         NetworkGetVersionInfoQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return NetworkGetVersionInfoQuery;
//     })();
// 
//     proto.NetworkGetVersionInfoResponse = (function() {
// 
//         /**
//          * Properties of a NetworkGetVersionInfoResponse.
//          * @memberof proto
//          * @interface INetworkGetVersionInfoResponse
//          * @property {proto.IResponseHeader|null} [header] NetworkGetVersionInfoResponse header
//          * @property {proto.ISemanticVersion|null} [hapiProtoVersion] NetworkGetVersionInfoResponse hapiProtoVersion
//          * @property {proto.ISemanticVersion|null} [hederaServicesVersion] NetworkGetVersionInfoResponse hederaServicesVersion
//          */
// 
//         /**
//          * Constructs a new NetworkGetVersionInfoResponse.
//          * @memberof proto
//          * @classdesc Represents a NetworkGetVersionInfoResponse.
//          * @implements INetworkGetVersionInfoResponse
//          * @constructor
//          * @param {proto.INetworkGetVersionInfoResponse=} [properties] Properties to set
//          */
//         function NetworkGetVersionInfoResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * NetworkGetVersionInfoResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @instance
//          */
//         NetworkGetVersionInfoResponse.prototype.header = null;
// 
//         /**
//          * NetworkGetVersionInfoResponse hapiProtoVersion.
//          * @member {proto.ISemanticVersion|null|undefined} hapiProtoVersion
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @instance
//          */
//         NetworkGetVersionInfoResponse.prototype.hapiProtoVersion = null;
// 
//         /**
//          * NetworkGetVersionInfoResponse hederaServicesVersion.
//          * @member {proto.ISemanticVersion|null|undefined} hederaServicesVersion
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @instance
//          */
//         NetworkGetVersionInfoResponse.prototype.hederaServicesVersion = null;
// 
//         /**
//          * Creates a new NetworkGetVersionInfoResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {proto.INetworkGetVersionInfoResponse=} [properties] Properties to set
//          * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse instance
//          */
//         NetworkGetVersionInfoResponse.create = function create(properties) {
//             return new NetworkGetVersionInfoResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified NetworkGetVersionInfoResponse message. Does not implicitly {@link proto.NetworkGetVersionInfoResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {proto.INetworkGetVersionInfoResponse} message NetworkGetVersionInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NetworkGetVersionInfoResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.hapiProtoVersion != null && Object.hasOwnProperty.call(message, "hapiProtoVersion"))
//                 $root.proto.SemanticVersion.encode(message.hapiProtoVersion, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.hederaServicesVersion != null && Object.hasOwnProperty.call(message, "hederaServicesVersion"))
//                 $root.proto.SemanticVersion.encode(message.hederaServicesVersion, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified NetworkGetVersionInfoResponse message, length delimited. Does not implicitly {@link proto.NetworkGetVersionInfoResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {proto.INetworkGetVersionInfoResponse} message NetworkGetVersionInfoResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         NetworkGetVersionInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a NetworkGetVersionInfoResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NetworkGetVersionInfoResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NetworkGetVersionInfoResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.hapiProtoVersion = $root.proto.SemanticVersion.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.hederaServicesVersion = $root.proto.SemanticVersion.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a NetworkGetVersionInfoResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         NetworkGetVersionInfoResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a NetworkGetVersionInfoResponse message.
//          * @function verify
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         NetworkGetVersionInfoResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.hapiProtoVersion != null && message.hasOwnProperty("hapiProtoVersion")) {
//                 let error = $root.proto.SemanticVersion.verify(message.hapiProtoVersion);
//                 if (error)
//                     return "hapiProtoVersion." + error;
//             }
//             if (message.hederaServicesVersion != null && message.hasOwnProperty("hederaServicesVersion")) {
//                 let error = $root.proto.SemanticVersion.verify(message.hederaServicesVersion);
//                 if (error)
//                     return "hederaServicesVersion." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a NetworkGetVersionInfoResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse
//          */
//         NetworkGetVersionInfoResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.NetworkGetVersionInfoResponse)
//                 return object;
//             let message = new $root.proto.NetworkGetVersionInfoResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.NetworkGetVersionInfoResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.hapiProtoVersion != null) {
//                 if (typeof object.hapiProtoVersion !== "object")
//                     throw TypeError(".proto.NetworkGetVersionInfoResponse.hapiProtoVersion: object expected");
//                 message.hapiProtoVersion = $root.proto.SemanticVersion.fromObject(object.hapiProtoVersion);
//             }
//             if (object.hederaServicesVersion != null) {
//                 if (typeof object.hederaServicesVersion !== "object")
//                     throw TypeError(".proto.NetworkGetVersionInfoResponse.hederaServicesVersion: object expected");
//                 message.hederaServicesVersion = $root.proto.SemanticVersion.fromObject(object.hederaServicesVersion);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a NetworkGetVersionInfoResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @static
//          * @param {proto.NetworkGetVersionInfoResponse} message NetworkGetVersionInfoResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         NetworkGetVersionInfoResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.hapiProtoVersion = null;
//                 object.hederaServicesVersion = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.hapiProtoVersion != null && message.hasOwnProperty("hapiProtoVersion"))
//                 object.hapiProtoVersion = $root.proto.SemanticVersion.toObject(message.hapiProtoVersion, options);
//             if (message.hederaServicesVersion != null && message.hasOwnProperty("hederaServicesVersion"))
//                 object.hederaServicesVersion = $root.proto.SemanticVersion.toObject(message.hederaServicesVersion, options);
//             return object;
//         };
// 
//         /**
//          * Converts this NetworkGetVersionInfoResponse to JSON.
//          * @function toJSON
//          * @memberof proto.NetworkGetVersionInfoResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         NetworkGetVersionInfoResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return NetworkGetVersionInfoResponse;
//     })();
// 
//     proto.Response = (function() {
// 
//         /**
//          * Properties of a Response.
//          * @memberof proto
//          * @interface IResponse
//          * @property {proto.IGetByKeyResponse|null} [getByKey] Response getByKey
//          * @property {proto.IGetBySolidityIDResponse|null} [getBySolidityID] Response getBySolidityID
//          * @property {proto.IContractCallLocalResponse|null} [contractCallLocal] Response contractCallLocal
//          * @property {proto.IContractGetBytecodeResponse|null} [contractGetBytecodeResponse] Response contractGetBytecodeResponse
//          * @property {proto.IContractGetInfoResponse|null} [contractGetInfo] Response contractGetInfo
//          * @property {proto.IContractGetRecordsResponse|null} [contractGetRecordsResponse] Response contractGetRecordsResponse
//          * @property {proto.ICryptoGetAccountBalanceResponse|null} [cryptogetAccountBalance] Response cryptogetAccountBalance
//          * @property {proto.ICryptoGetAccountRecordsResponse|null} [cryptoGetAccountRecords] Response cryptoGetAccountRecords
//          * @property {proto.ICryptoGetInfoResponse|null} [cryptoGetInfo] Response cryptoGetInfo
//          * @property {proto.ICryptoGetLiveHashResponse|null} [cryptoGetLiveHash] Response cryptoGetLiveHash
//          * @property {proto.ICryptoGetStakersResponse|null} [cryptoGetProxyStakers] Response cryptoGetProxyStakers
//          * @property {proto.IFileGetContentsResponse|null} [fileGetContents] Response fileGetContents
//          * @property {proto.IFileGetInfoResponse|null} [fileGetInfo] Response fileGetInfo
//          * @property {proto.ITransactionGetReceiptResponse|null} [transactionGetReceipt] Response transactionGetReceipt
//          * @property {proto.ITransactionGetRecordResponse|null} [transactionGetRecord] Response transactionGetRecord
//          * @property {proto.ITransactionGetFastRecordResponse|null} [transactionGetFastRecord] Response transactionGetFastRecord
//          * @property {proto.IConsensusGetTopicInfoResponse|null} [consensusGetTopicInfo] Response consensusGetTopicInfo
//          * @property {proto.INetworkGetVersionInfoResponse|null} [networkGetVersionInfo] Response networkGetVersionInfo
//          */
// 
//         /**
//          * Constructs a new Response.
//          * @memberof proto
//          * @classdesc Represents a Response.
//          * @implements IResponse
//          * @constructor
//          * @param {proto.IResponse=} [properties] Properties to set
//          */
//         function Response(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Response getByKey.
//          * @member {proto.IGetByKeyResponse|null|undefined} getByKey
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.getByKey = null;
// 
//         /**
//          * Response getBySolidityID.
//          * @member {proto.IGetBySolidityIDResponse|null|undefined} getBySolidityID
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.getBySolidityID = null;
// 
//         /**
//          * Response contractCallLocal.
//          * @member {proto.IContractCallLocalResponse|null|undefined} contractCallLocal
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.contractCallLocal = null;
// 
//         /**
//          * Response contractGetBytecodeResponse.
//          * @member {proto.IContractGetBytecodeResponse|null|undefined} contractGetBytecodeResponse
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.contractGetBytecodeResponse = null;
// 
//         /**
//          * Response contractGetInfo.
//          * @member {proto.IContractGetInfoResponse|null|undefined} contractGetInfo
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.contractGetInfo = null;
// 
//         /**
//          * Response contractGetRecordsResponse.
//          * @member {proto.IContractGetRecordsResponse|null|undefined} contractGetRecordsResponse
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.contractGetRecordsResponse = null;
// 
//         /**
//          * Response cryptogetAccountBalance.
//          * @member {proto.ICryptoGetAccountBalanceResponse|null|undefined} cryptogetAccountBalance
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.cryptogetAccountBalance = null;
// 
//         /**
//          * Response cryptoGetAccountRecords.
//          * @member {proto.ICryptoGetAccountRecordsResponse|null|undefined} cryptoGetAccountRecords
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.cryptoGetAccountRecords = null;
// 
//         /**
//          * Response cryptoGetInfo.
//          * @member {proto.ICryptoGetInfoResponse|null|undefined} cryptoGetInfo
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.cryptoGetInfo = null;
// 
//         /**
//          * Response cryptoGetLiveHash.
//          * @member {proto.ICryptoGetLiveHashResponse|null|undefined} cryptoGetLiveHash
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.cryptoGetLiveHash = null;
// 
//         /**
//          * Response cryptoGetProxyStakers.
//          * @member {proto.ICryptoGetStakersResponse|null|undefined} cryptoGetProxyStakers
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.cryptoGetProxyStakers = null;
// 
//         /**
//          * Response fileGetContents.
//          * @member {proto.IFileGetContentsResponse|null|undefined} fileGetContents
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.fileGetContents = null;
// 
//         /**
//          * Response fileGetInfo.
//          * @member {proto.IFileGetInfoResponse|null|undefined} fileGetInfo
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.fileGetInfo = null;
// 
//         /**
//          * Response transactionGetReceipt.
//          * @member {proto.ITransactionGetReceiptResponse|null|undefined} transactionGetReceipt
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.transactionGetReceipt = null;
// 
//         /**
//          * Response transactionGetRecord.
//          * @member {proto.ITransactionGetRecordResponse|null|undefined} transactionGetRecord
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.transactionGetRecord = null;
// 
//         /**
//          * Response transactionGetFastRecord.
//          * @member {proto.ITransactionGetFastRecordResponse|null|undefined} transactionGetFastRecord
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.transactionGetFastRecord = null;
// 
//         /**
//          * Response consensusGetTopicInfo.
//          * @member {proto.IConsensusGetTopicInfoResponse|null|undefined} consensusGetTopicInfo
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.consensusGetTopicInfo = null;
// 
//         /**
//          * Response networkGetVersionInfo.
//          * @member {proto.INetworkGetVersionInfoResponse|null|undefined} networkGetVersionInfo
//          * @memberof proto.Response
//          * @instance
//          */
//         Response.prototype.networkGetVersionInfo = null;
// 
//         // OneOf field names bound to virtual getters and setters
//         let $oneOfFields;
// 
//         /**
//          * Response response.
//          * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetBytecodeResponse"|"contractGetInfo"|"contractGetRecordsResponse"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|undefined} response
//          * @memberof proto.Response
//          * @instance
//          */
//         Object.defineProperty(Response.prototype, "response", {
//             get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetBytecodeResponse", "contractGetInfo", "contractGetRecordsResponse", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo"]),
//             set: $util.oneOfSetter($oneOfFields)
//         });
// 
//         /**
//          * Creates a new Response instance using the specified properties.
//          * @function create
//          * @memberof proto.Response
//          * @static
//          * @param {proto.IResponse=} [properties] Properties to set
//          * @returns {proto.Response} Response instance
//          */
//         Response.create = function create(properties) {
//             return new Response(properties);
//         };
// 
//         /**
//          * Encodes the specified Response message. Does not implicitly {@link proto.Response.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Response
//          * @static
//          * @param {proto.IResponse} message Response message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Response.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.getByKey != null && Object.hasOwnProperty.call(message, "getByKey"))
//                 $root.proto.GetByKeyResponse.encode(message.getByKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.getBySolidityID != null && Object.hasOwnProperty.call(message, "getBySolidityID"))
//                 $root.proto.GetBySolidityIDResponse.encode(message.getBySolidityID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.contractCallLocal != null && Object.hasOwnProperty.call(message, "contractCallLocal"))
//                 $root.proto.ContractCallLocalResponse.encode(message.contractCallLocal, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.contractGetInfo != null && Object.hasOwnProperty.call(message, "contractGetInfo"))
//                 $root.proto.ContractGetInfoResponse.encode(message.contractGetInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
//             if (message.contractGetBytecodeResponse != null && Object.hasOwnProperty.call(message, "contractGetBytecodeResponse"))
//                 $root.proto.ContractGetBytecodeResponse.encode(message.contractGetBytecodeResponse, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             if (message.contractGetRecordsResponse != null && Object.hasOwnProperty.call(message, "contractGetRecordsResponse"))
//                 $root.proto.ContractGetRecordsResponse.encode(message.contractGetRecordsResponse, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
//             if (message.cryptogetAccountBalance != null && Object.hasOwnProperty.call(message, "cryptogetAccountBalance"))
//                 $root.proto.CryptoGetAccountBalanceResponse.encode(message.cryptogetAccountBalance, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
//             if (message.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(message, "cryptoGetAccountRecords"))
//                 $root.proto.CryptoGetAccountRecordsResponse.encode(message.cryptoGetAccountRecords, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
//             if (message.cryptoGetInfo != null && Object.hasOwnProperty.call(message, "cryptoGetInfo"))
//                 $root.proto.CryptoGetInfoResponse.encode(message.cryptoGetInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
//             if (message.cryptoGetLiveHash != null && Object.hasOwnProperty.call(message, "cryptoGetLiveHash"))
//                 $root.proto.CryptoGetLiveHashResponse.encode(message.cryptoGetLiveHash, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
//             if (message.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(message, "cryptoGetProxyStakers"))
//                 $root.proto.CryptoGetStakersResponse.encode(message.cryptoGetProxyStakers, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
//             if (message.fileGetContents != null && Object.hasOwnProperty.call(message, "fileGetContents"))
//                 $root.proto.FileGetContentsResponse.encode(message.fileGetContents, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
//             if (message.fileGetInfo != null && Object.hasOwnProperty.call(message, "fileGetInfo"))
//                 $root.proto.FileGetInfoResponse.encode(message.fileGetInfo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
//             if (message.transactionGetReceipt != null && Object.hasOwnProperty.call(message, "transactionGetReceipt"))
//                 $root.proto.TransactionGetReceiptResponse.encode(message.transactionGetReceipt, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
//             if (message.transactionGetRecord != null && Object.hasOwnProperty.call(message, "transactionGetRecord"))
//                 $root.proto.TransactionGetRecordResponse.encode(message.transactionGetRecord, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
//             if (message.transactionGetFastRecord != null && Object.hasOwnProperty.call(message, "transactionGetFastRecord"))
//                 $root.proto.TransactionGetFastRecordResponse.encode(message.transactionGetFastRecord, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
//             if (message.consensusGetTopicInfo != null && Object.hasOwnProperty.call(message, "consensusGetTopicInfo"))
//                 $root.proto.ConsensusGetTopicInfoResponse.encode(message.consensusGetTopicInfo, writer.uint32(/* id 150, wireType 2 =*/1202).fork()).ldelim();
//             if (message.networkGetVersionInfo != null && Object.hasOwnProperty.call(message, "networkGetVersionInfo"))
//                 $root.proto.NetworkGetVersionInfoResponse.encode(message.networkGetVersionInfo, writer.uint32(/* id 151, wireType 2 =*/1210).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Response message, length delimited. Does not implicitly {@link proto.Response.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Response
//          * @static
//          * @param {proto.IResponse} message Response message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Response.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Response message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Response
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Response} Response
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Response.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Response();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.getByKey = $root.proto.GetByKeyResponse.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.getBySolidityID = $root.proto.GetBySolidityIDResponse.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.contractCallLocal = $root.proto.ContractCallLocalResponse.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.decode(reader, reader.uint32());
//                     break;
//                 case 4:
//                     message.contractGetInfo = $root.proto.ContractGetInfoResponse.decode(reader, reader.uint32());
//                     break;
//                 case 6:
//                     message.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.decode(reader, reader.uint32());
//                     break;
//                 case 7:
//                     message.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.decode(reader, reader.uint32());
//                     break;
//                 case 8:
//                     message.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.decode(reader, reader.uint32());
//                     break;
//                 case 9:
//                     message.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.decode(reader, reader.uint32());
//                     break;
//                 case 10:
//                     message.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.decode(reader, reader.uint32());
//                     break;
//                 case 11:
//                     message.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.decode(reader, reader.uint32());
//                     break;
//                 case 12:
//                     message.fileGetContents = $root.proto.FileGetContentsResponse.decode(reader, reader.uint32());
//                     break;
//                 case 13:
//                     message.fileGetInfo = $root.proto.FileGetInfoResponse.decode(reader, reader.uint32());
//                     break;
//                 case 14:
//                     message.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.decode(reader, reader.uint32());
//                     break;
//                 case 15:
//                     message.transactionGetRecord = $root.proto.TransactionGetRecordResponse.decode(reader, reader.uint32());
//                     break;
//                 case 16:
//                     message.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.decode(reader, reader.uint32());
//                     break;
//                 case 150:
//                     message.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.decode(reader, reader.uint32());
//                     break;
//                 case 151:
//                     message.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Response message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Response
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Response} Response
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Response.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Response message.
//          * @function verify
//          * @memberof proto.Response
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Response.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             let properties = {};
//             if (message.getByKey != null && message.hasOwnProperty("getByKey")) {
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.GetByKeyResponse.verify(message.getByKey);
//                     if (error)
//                         return "getByKey." + error;
//                 }
//             }
//             if (message.getBySolidityID != null && message.hasOwnProperty("getBySolidityID")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.GetBySolidityIDResponse.verify(message.getBySolidityID);
//                     if (error)
//                         return "getBySolidityID." + error;
//                 }
//             }
//             if (message.contractCallLocal != null && message.hasOwnProperty("contractCallLocal")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.ContractCallLocalResponse.verify(message.contractCallLocal);
//                     if (error)
//                         return "contractCallLocal." + error;
//                 }
//             }
//             if (message.contractGetBytecodeResponse != null && message.hasOwnProperty("contractGetBytecodeResponse")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.ContractGetBytecodeResponse.verify(message.contractGetBytecodeResponse);
//                     if (error)
//                         return "contractGetBytecodeResponse." + error;
//                 }
//             }
//             if (message.contractGetInfo != null && message.hasOwnProperty("contractGetInfo")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.ContractGetInfoResponse.verify(message.contractGetInfo);
//                     if (error)
//                         return "contractGetInfo." + error;
//                 }
//             }
//             if (message.contractGetRecordsResponse != null && message.hasOwnProperty("contractGetRecordsResponse")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.ContractGetRecordsResponse.verify(message.contractGetRecordsResponse);
//                     if (error)
//                         return "contractGetRecordsResponse." + error;
//                 }
//             }
//             if (message.cryptogetAccountBalance != null && message.hasOwnProperty("cryptogetAccountBalance")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.CryptoGetAccountBalanceResponse.verify(message.cryptogetAccountBalance);
//                     if (error)
//                         return "cryptogetAccountBalance." + error;
//                 }
//             }
//             if (message.cryptoGetAccountRecords != null && message.hasOwnProperty("cryptoGetAccountRecords")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.CryptoGetAccountRecordsResponse.verify(message.cryptoGetAccountRecords);
//                     if (error)
//                         return "cryptoGetAccountRecords." + error;
//                 }
//             }
//             if (message.cryptoGetInfo != null && message.hasOwnProperty("cryptoGetInfo")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.CryptoGetInfoResponse.verify(message.cryptoGetInfo);
//                     if (error)
//                         return "cryptoGetInfo." + error;
//                 }
//             }
//             if (message.cryptoGetLiveHash != null && message.hasOwnProperty("cryptoGetLiveHash")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.CryptoGetLiveHashResponse.verify(message.cryptoGetLiveHash);
//                     if (error)
//                         return "cryptoGetLiveHash." + error;
//                 }
//             }
//             if (message.cryptoGetProxyStakers != null && message.hasOwnProperty("cryptoGetProxyStakers")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.CryptoGetStakersResponse.verify(message.cryptoGetProxyStakers);
//                     if (error)
//                         return "cryptoGetProxyStakers." + error;
//                 }
//             }
//             if (message.fileGetContents != null && message.hasOwnProperty("fileGetContents")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.FileGetContentsResponse.verify(message.fileGetContents);
//                     if (error)
//                         return "fileGetContents." + error;
//                 }
//             }
//             if (message.fileGetInfo != null && message.hasOwnProperty("fileGetInfo")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.FileGetInfoResponse.verify(message.fileGetInfo);
//                     if (error)
//                         return "fileGetInfo." + error;
//                 }
//             }
//             if (message.transactionGetReceipt != null && message.hasOwnProperty("transactionGetReceipt")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.TransactionGetReceiptResponse.verify(message.transactionGetReceipt);
//                     if (error)
//                         return "transactionGetReceipt." + error;
//                 }
//             }
//             if (message.transactionGetRecord != null && message.hasOwnProperty("transactionGetRecord")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.TransactionGetRecordResponse.verify(message.transactionGetRecord);
//                     if (error)
//                         return "transactionGetRecord." + error;
//                 }
//             }
//             if (message.transactionGetFastRecord != null && message.hasOwnProperty("transactionGetFastRecord")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.TransactionGetFastRecordResponse.verify(message.transactionGetFastRecord);
//                     if (error)
//                         return "transactionGetFastRecord." + error;
//                 }
//             }
//             if (message.consensusGetTopicInfo != null && message.hasOwnProperty("consensusGetTopicInfo")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.ConsensusGetTopicInfoResponse.verify(message.consensusGetTopicInfo);
//                     if (error)
//                         return "consensusGetTopicInfo." + error;
//                 }
//             }
//             if (message.networkGetVersionInfo != null && message.hasOwnProperty("networkGetVersionInfo")) {
//                 if (properties.response === 1)
//                     return "response: multiple values";
//                 properties.response = 1;
//                 {
//                     let error = $root.proto.NetworkGetVersionInfoResponse.verify(message.networkGetVersionInfo);
//                     if (error)
//                         return "networkGetVersionInfo." + error;
//                 }
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a Response message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Response
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Response} Response
//          */
//         Response.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Response)
//                 return object;
//             let message = new $root.proto.Response();
//             if (object.getByKey != null) {
//                 if (typeof object.getByKey !== "object")
//                     throw TypeError(".proto.Response.getByKey: object expected");
//                 message.getByKey = $root.proto.GetByKeyResponse.fromObject(object.getByKey);
//             }
//             if (object.getBySolidityID != null) {
//                 if (typeof object.getBySolidityID !== "object")
//                     throw TypeError(".proto.Response.getBySolidityID: object expected");
//                 message.getBySolidityID = $root.proto.GetBySolidityIDResponse.fromObject(object.getBySolidityID);
//             }
//             if (object.contractCallLocal != null) {
//                 if (typeof object.contractCallLocal !== "object")
//                     throw TypeError(".proto.Response.contractCallLocal: object expected");
//                 message.contractCallLocal = $root.proto.ContractCallLocalResponse.fromObject(object.contractCallLocal);
//             }
//             if (object.contractGetBytecodeResponse != null) {
//                 if (typeof object.contractGetBytecodeResponse !== "object")
//                     throw TypeError(".proto.Response.contractGetBytecodeResponse: object expected");
//                 message.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.fromObject(object.contractGetBytecodeResponse);
//             }
//             if (object.contractGetInfo != null) {
//                 if (typeof object.contractGetInfo !== "object")
//                     throw TypeError(".proto.Response.contractGetInfo: object expected");
//                 message.contractGetInfo = $root.proto.ContractGetInfoResponse.fromObject(object.contractGetInfo);
//             }
//             if (object.contractGetRecordsResponse != null) {
//                 if (typeof object.contractGetRecordsResponse !== "object")
//                     throw TypeError(".proto.Response.contractGetRecordsResponse: object expected");
//                 message.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.fromObject(object.contractGetRecordsResponse);
//             }
//             if (object.cryptogetAccountBalance != null) {
//                 if (typeof object.cryptogetAccountBalance !== "object")
//                     throw TypeError(".proto.Response.cryptogetAccountBalance: object expected");
//                 message.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.fromObject(object.cryptogetAccountBalance);
//             }
//             if (object.cryptoGetAccountRecords != null) {
//                 if (typeof object.cryptoGetAccountRecords !== "object")
//                     throw TypeError(".proto.Response.cryptoGetAccountRecords: object expected");
//                 message.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.fromObject(object.cryptoGetAccountRecords);
//             }
//             if (object.cryptoGetInfo != null) {
//                 if (typeof object.cryptoGetInfo !== "object")
//                     throw TypeError(".proto.Response.cryptoGetInfo: object expected");
//                 message.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.fromObject(object.cryptoGetInfo);
//             }
//             if (object.cryptoGetLiveHash != null) {
//                 if (typeof object.cryptoGetLiveHash !== "object")
//                     throw TypeError(".proto.Response.cryptoGetLiveHash: object expected");
//                 message.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.fromObject(object.cryptoGetLiveHash);
//             }
//             if (object.cryptoGetProxyStakers != null) {
//                 if (typeof object.cryptoGetProxyStakers !== "object")
//                     throw TypeError(".proto.Response.cryptoGetProxyStakers: object expected");
//                 message.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.fromObject(object.cryptoGetProxyStakers);
//             }
//             if (object.fileGetContents != null) {
//                 if (typeof object.fileGetContents !== "object")
//                     throw TypeError(".proto.Response.fileGetContents: object expected");
//                 message.fileGetContents = $root.proto.FileGetContentsResponse.fromObject(object.fileGetContents);
//             }
//             if (object.fileGetInfo != null) {
//                 if (typeof object.fileGetInfo !== "object")
//                     throw TypeError(".proto.Response.fileGetInfo: object expected");
//                 message.fileGetInfo = $root.proto.FileGetInfoResponse.fromObject(object.fileGetInfo);
//             }
//             if (object.transactionGetReceipt != null) {
//                 if (typeof object.transactionGetReceipt !== "object")
//                     throw TypeError(".proto.Response.transactionGetReceipt: object expected");
//                 message.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.fromObject(object.transactionGetReceipt);
//             }
//             if (object.transactionGetRecord != null) {
//                 if (typeof object.transactionGetRecord !== "object")
//                     throw TypeError(".proto.Response.transactionGetRecord: object expected");
//                 message.transactionGetRecord = $root.proto.TransactionGetRecordResponse.fromObject(object.transactionGetRecord);
//             }
//             if (object.transactionGetFastRecord != null) {
//                 if (typeof object.transactionGetFastRecord !== "object")
//                     throw TypeError(".proto.Response.transactionGetFastRecord: object expected");
//                 message.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.fromObject(object.transactionGetFastRecord);
//             }
//             if (object.consensusGetTopicInfo != null) {
//                 if (typeof object.consensusGetTopicInfo !== "object")
//                     throw TypeError(".proto.Response.consensusGetTopicInfo: object expected");
//                 message.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.fromObject(object.consensusGetTopicInfo);
//             }
//             if (object.networkGetVersionInfo != null) {
//                 if (typeof object.networkGetVersionInfo !== "object")
//                     throw TypeError(".proto.Response.networkGetVersionInfo: object expected");
//                 message.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.fromObject(object.networkGetVersionInfo);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Response message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Response
//          * @static
//          * @param {proto.Response} message Response
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Response.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (message.getByKey != null && message.hasOwnProperty("getByKey")) {
//                 object.getByKey = $root.proto.GetByKeyResponse.toObject(message.getByKey, options);
//                 if (options.oneofs)
//                     object.response = "getByKey";
//             }
//             if (message.getBySolidityID != null && message.hasOwnProperty("getBySolidityID")) {
//                 object.getBySolidityID = $root.proto.GetBySolidityIDResponse.toObject(message.getBySolidityID, options);
//                 if (options.oneofs)
//                     object.response = "getBySolidityID";
//             }
//             if (message.contractCallLocal != null && message.hasOwnProperty("contractCallLocal")) {
//                 object.contractCallLocal = $root.proto.ContractCallLocalResponse.toObject(message.contractCallLocal, options);
//                 if (options.oneofs)
//                     object.response = "contractCallLocal";
//             }
//             if (message.contractGetInfo != null && message.hasOwnProperty("contractGetInfo")) {
//                 object.contractGetInfo = $root.proto.ContractGetInfoResponse.toObject(message.contractGetInfo, options);
//                 if (options.oneofs)
//                     object.response = "contractGetInfo";
//             }
//             if (message.contractGetBytecodeResponse != null && message.hasOwnProperty("contractGetBytecodeResponse")) {
//                 object.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.toObject(message.contractGetBytecodeResponse, options);
//                 if (options.oneofs)
//                     object.response = "contractGetBytecodeResponse";
//             }
//             if (message.contractGetRecordsResponse != null && message.hasOwnProperty("contractGetRecordsResponse")) {
//                 object.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.toObject(message.contractGetRecordsResponse, options);
//                 if (options.oneofs)
//                     object.response = "contractGetRecordsResponse";
//             }
//             if (message.cryptogetAccountBalance != null && message.hasOwnProperty("cryptogetAccountBalance")) {
//                 object.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.toObject(message.cryptogetAccountBalance, options);
//                 if (options.oneofs)
//                     object.response = "cryptogetAccountBalance";
//             }
//             if (message.cryptoGetAccountRecords != null && message.hasOwnProperty("cryptoGetAccountRecords")) {
//                 object.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.toObject(message.cryptoGetAccountRecords, options);
//                 if (options.oneofs)
//                     object.response = "cryptoGetAccountRecords";
//             }
//             if (message.cryptoGetInfo != null && message.hasOwnProperty("cryptoGetInfo")) {
//                 object.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.toObject(message.cryptoGetInfo, options);
//                 if (options.oneofs)
//                     object.response = "cryptoGetInfo";
//             }
//             if (message.cryptoGetLiveHash != null && message.hasOwnProperty("cryptoGetLiveHash")) {
//                 object.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.toObject(message.cryptoGetLiveHash, options);
//                 if (options.oneofs)
//                     object.response = "cryptoGetLiveHash";
//             }
//             if (message.cryptoGetProxyStakers != null && message.hasOwnProperty("cryptoGetProxyStakers")) {
//                 object.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.toObject(message.cryptoGetProxyStakers, options);
//                 if (options.oneofs)
//                     object.response = "cryptoGetProxyStakers";
//             }
//             if (message.fileGetContents != null && message.hasOwnProperty("fileGetContents")) {
//                 object.fileGetContents = $root.proto.FileGetContentsResponse.toObject(message.fileGetContents, options);
//                 if (options.oneofs)
//                     object.response = "fileGetContents";
//             }
//             if (message.fileGetInfo != null && message.hasOwnProperty("fileGetInfo")) {
//                 object.fileGetInfo = $root.proto.FileGetInfoResponse.toObject(message.fileGetInfo, options);
//                 if (options.oneofs)
//                     object.response = "fileGetInfo";
//             }
//             if (message.transactionGetReceipt != null && message.hasOwnProperty("transactionGetReceipt")) {
//                 object.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.toObject(message.transactionGetReceipt, options);
//                 if (options.oneofs)
//                     object.response = "transactionGetReceipt";
//             }
//             if (message.transactionGetRecord != null && message.hasOwnProperty("transactionGetRecord")) {
//                 object.transactionGetRecord = $root.proto.TransactionGetRecordResponse.toObject(message.transactionGetRecord, options);
//                 if (options.oneofs)
//                     object.response = "transactionGetRecord";
//             }
//             if (message.transactionGetFastRecord != null && message.hasOwnProperty("transactionGetFastRecord")) {
//                 object.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.toObject(message.transactionGetFastRecord, options);
//                 if (options.oneofs)
//                     object.response = "transactionGetFastRecord";
//             }
//             if (message.consensusGetTopicInfo != null && message.hasOwnProperty("consensusGetTopicInfo")) {
//                 object.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.toObject(message.consensusGetTopicInfo, options);
//                 if (options.oneofs)
//                     object.response = "consensusGetTopicInfo";
//             }
//             if (message.networkGetVersionInfo != null && message.hasOwnProperty("networkGetVersionInfo")) {
//                 object.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.toObject(message.networkGetVersionInfo, options);
//                 if (options.oneofs)
//                     object.response = "networkGetVersionInfo";
//             }
//             return object;
//         };
// 
//         /**
//          * Converts this Response to JSON.
//          * @function toJSON
//          * @memberof proto.Response
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Response.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Response;
//     })();
// 
//     proto.Claim = (function() {
// 
//         /**
//          * Properties of a Claim.
//          * @memberof proto
//          * @interface IClaim
//          * @property {proto.IAccountID|null} [accountID] Claim accountID
//          * @property {Uint8Array|null} [hash] Claim hash
//          * @property {proto.IKeyList|null} [keys] Claim keys
//          * @property {proto.IDuration|null} [claimDuration] Claim claimDuration
//          */
// 
//         /**
//          * Constructs a new Claim.
//          * @memberof proto
//          * @classdesc Represents a Claim.
//          * @implements IClaim
//          * @constructor
//          * @param {proto.IClaim=} [properties] Properties to set
//          */
//         function Claim(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * Claim accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.Claim
//          * @instance
//          */
//         Claim.prototype.accountID = null;
// 
//         /**
//          * Claim hash.
//          * @member {Uint8Array} hash
//          * @memberof proto.Claim
//          * @instance
//          */
//         Claim.prototype.hash = $util.newBuffer([]);
// 
//         /**
//          * Claim keys.
//          * @member {proto.IKeyList|null|undefined} keys
//          * @memberof proto.Claim
//          * @instance
//          */
//         Claim.prototype.keys = null;
// 
//         /**
//          * Claim claimDuration.
//          * @member {proto.IDuration|null|undefined} claimDuration
//          * @memberof proto.Claim
//          * @instance
//          */
//         Claim.prototype.claimDuration = null;
// 
//         /**
//          * Creates a new Claim instance using the specified properties.
//          * @function create
//          * @memberof proto.Claim
//          * @static
//          * @param {proto.IClaim=} [properties] Properties to set
//          * @returns {proto.Claim} Claim instance
//          */
//         Claim.create = function create(properties) {
//             return new Claim(properties);
//         };
// 
//         /**
//          * Encodes the specified Claim message. Does not implicitly {@link proto.Claim.verify|verify} messages.
//          * @function encode
//          * @memberof proto.Claim
//          * @static
//          * @param {proto.IClaim} message Claim message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Claim.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
//             if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
//                 $root.proto.KeyList.encode(message.keys, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             if (message.claimDuration != null && Object.hasOwnProperty.call(message, "claimDuration"))
//                 $root.proto.Duration.encode(message.claimDuration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified Claim message, length delimited. Does not implicitly {@link proto.Claim.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.Claim
//          * @static
//          * @param {proto.IClaim} message Claim message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         Claim.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a Claim message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.Claim
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.Claim} Claim
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Claim.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Claim();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.hash = reader.bytes();
//                     break;
//                 case 3:
//                     message.keys = $root.proto.KeyList.decode(reader, reader.uint32());
//                     break;
//                 case 5:
//                     message.claimDuration = $root.proto.Duration.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a Claim message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.Claim
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.Claim} Claim
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         Claim.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a Claim message.
//          * @function verify
//          * @memberof proto.Claim
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         Claim.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
//                     return "hash: buffer expected";
//             if (message.keys != null && message.hasOwnProperty("keys")) {
//                 let error = $root.proto.KeyList.verify(message.keys);
//                 if (error)
//                     return "keys." + error;
//             }
//             if (message.claimDuration != null && message.hasOwnProperty("claimDuration")) {
//                 let error = $root.proto.Duration.verify(message.claimDuration);
//                 if (error)
//                     return "claimDuration." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a Claim message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.Claim
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.Claim} Claim
//          */
//         Claim.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.Claim)
//                 return object;
//             let message = new $root.proto.Claim();
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.Claim.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.hash != null)
//                 if (typeof object.hash === "string")
//                     $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
//                 else if (object.hash.length)
//                     message.hash = object.hash;
//             if (object.keys != null) {
//                 if (typeof object.keys !== "object")
//                     throw TypeError(".proto.Claim.keys: object expected");
//                 message.keys = $root.proto.KeyList.fromObject(object.keys);
//             }
//             if (object.claimDuration != null) {
//                 if (typeof object.claimDuration !== "object")
//                     throw TypeError(".proto.Claim.claimDuration: object expected");
//                 message.claimDuration = $root.proto.Duration.fromObject(object.claimDuration);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a Claim message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.Claim
//          * @static
//          * @param {proto.Claim} message Claim
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         Claim.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.accountID = null;
//                 if (options.bytes === String)
//                     object.hash = "";
//                 else {
//                     object.hash = [];
//                     if (options.bytes !== Array)
//                         object.hash = $util.newBuffer(object.hash);
//                 }
//                 object.keys = null;
//                 object.claimDuration = null;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
//             if (message.keys != null && message.hasOwnProperty("keys"))
//                 object.keys = $root.proto.KeyList.toObject(message.keys, options);
//             if (message.claimDuration != null && message.hasOwnProperty("claimDuration"))
//                 object.claimDuration = $root.proto.Duration.toObject(message.claimDuration, options);
//             return object;
//         };
// 
//         /**
//          * Converts this Claim to JSON.
//          * @function toJSON
//          * @memberof proto.Claim
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         Claim.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return Claim;
//     })();
// 
//     proto.CryptoAddClaimTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoAddClaimTransactionBody.
//          * @memberof proto
//          * @interface ICryptoAddClaimTransactionBody
//          * @property {proto.IClaim|null} [claim] CryptoAddClaimTransactionBody claim
//          */
// 
//         /**
//          * Constructs a new CryptoAddClaimTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoAddClaimTransactionBody.
//          * @implements ICryptoAddClaimTransactionBody
//          * @constructor
//          * @param {proto.ICryptoAddClaimTransactionBody=} [properties] Properties to set
//          */
//         function CryptoAddClaimTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoAddClaimTransactionBody claim.
//          * @member {proto.IClaim|null|undefined} claim
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @instance
//          */
//         CryptoAddClaimTransactionBody.prototype.claim = null;
// 
//         /**
//          * Creates a new CryptoAddClaimTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {proto.ICryptoAddClaimTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoAddClaimTransactionBody} CryptoAddClaimTransactionBody instance
//          */
//         CryptoAddClaimTransactionBody.create = function create(properties) {
//             return new CryptoAddClaimTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoAddClaimTransactionBody message. Does not implicitly {@link proto.CryptoAddClaimTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {proto.ICryptoAddClaimTransactionBody} message CryptoAddClaimTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoAddClaimTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.claim != null && Object.hasOwnProperty.call(message, "claim"))
//                 $root.proto.Claim.encode(message.claim, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoAddClaimTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoAddClaimTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {proto.ICryptoAddClaimTransactionBody} message CryptoAddClaimTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoAddClaimTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoAddClaimTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoAddClaimTransactionBody} CryptoAddClaimTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoAddClaimTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoAddClaimTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 3:
//                     message.claim = $root.proto.Claim.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoAddClaimTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoAddClaimTransactionBody} CryptoAddClaimTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoAddClaimTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoAddClaimTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoAddClaimTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.claim != null && message.hasOwnProperty("claim")) {
//                 let error = $root.proto.Claim.verify(message.claim);
//                 if (error)
//                     return "claim." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoAddClaimTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoAddClaimTransactionBody} CryptoAddClaimTransactionBody
//          */
//         CryptoAddClaimTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoAddClaimTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoAddClaimTransactionBody();
//             if (object.claim != null) {
//                 if (typeof object.claim !== "object")
//                     throw TypeError(".proto.CryptoAddClaimTransactionBody.claim: object expected");
//                 message.claim = $root.proto.Claim.fromObject(object.claim);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoAddClaimTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @static
//          * @param {proto.CryptoAddClaimTransactionBody} message CryptoAddClaimTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoAddClaimTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults)
//                 object.claim = null;
//             if (message.claim != null && message.hasOwnProperty("claim"))
//                 object.claim = $root.proto.Claim.toObject(message.claim, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoAddClaimTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoAddClaimTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoAddClaimTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoAddClaimTransactionBody;
//     })();
// 
//     proto.CryptoDeleteClaimTransactionBody = (function() {
// 
//         /**
//          * Properties of a CryptoDeleteClaimTransactionBody.
//          * @memberof proto
//          * @interface ICryptoDeleteClaimTransactionBody
//          * @property {proto.IAccountID|null} [accountIDToDeleteFrom] CryptoDeleteClaimTransactionBody accountIDToDeleteFrom
//          * @property {Uint8Array|null} [hashToDelete] CryptoDeleteClaimTransactionBody hashToDelete
//          */
// 
//         /**
//          * Constructs a new CryptoDeleteClaimTransactionBody.
//          * @memberof proto
//          * @classdesc Represents a CryptoDeleteClaimTransactionBody.
//          * @implements ICryptoDeleteClaimTransactionBody
//          * @constructor
//          * @param {proto.ICryptoDeleteClaimTransactionBody=} [properties] Properties to set
//          */
//         function CryptoDeleteClaimTransactionBody(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoDeleteClaimTransactionBody accountIDToDeleteFrom.
//          * @member {proto.IAccountID|null|undefined} accountIDToDeleteFrom
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @instance
//          */
//         CryptoDeleteClaimTransactionBody.prototype.accountIDToDeleteFrom = null;
// 
//         /**
//          * CryptoDeleteClaimTransactionBody hashToDelete.
//          * @member {Uint8Array} hashToDelete
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @instance
//          */
//         CryptoDeleteClaimTransactionBody.prototype.hashToDelete = $util.newBuffer([]);
// 
//         /**
//          * Creates a new CryptoDeleteClaimTransactionBody instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteClaimTransactionBody=} [properties] Properties to set
//          * @returns {proto.CryptoDeleteClaimTransactionBody} CryptoDeleteClaimTransactionBody instance
//          */
//         CryptoDeleteClaimTransactionBody.create = function create(properties) {
//             return new CryptoDeleteClaimTransactionBody(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoDeleteClaimTransactionBody message. Does not implicitly {@link proto.CryptoDeleteClaimTransactionBody.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteClaimTransactionBody} message CryptoDeleteClaimTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoDeleteClaimTransactionBody.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.accountIDToDeleteFrom != null && Object.hasOwnProperty.call(message, "accountIDToDeleteFrom"))
//                 $root.proto.AccountID.encode(message.accountIDToDeleteFrom, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.hashToDelete != null && Object.hasOwnProperty.call(message, "hashToDelete"))
//                 writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hashToDelete);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoDeleteClaimTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoDeleteClaimTransactionBody.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {proto.ICryptoDeleteClaimTransactionBody} message CryptoDeleteClaimTransactionBody message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoDeleteClaimTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoDeleteClaimTransactionBody message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoDeleteClaimTransactionBody} CryptoDeleteClaimTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoDeleteClaimTransactionBody.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoDeleteClaimTransactionBody();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.accountIDToDeleteFrom = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.hashToDelete = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoDeleteClaimTransactionBody message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoDeleteClaimTransactionBody} CryptoDeleteClaimTransactionBody
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoDeleteClaimTransactionBody.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoDeleteClaimTransactionBody message.
//          * @function verify
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoDeleteClaimTransactionBody.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.accountIDToDeleteFrom != null && message.hasOwnProperty("accountIDToDeleteFrom")) {
//                 let error = $root.proto.AccountID.verify(message.accountIDToDeleteFrom);
//                 if (error)
//                     return "accountIDToDeleteFrom." + error;
//             }
//             if (message.hashToDelete != null && message.hasOwnProperty("hashToDelete"))
//                 if (!(message.hashToDelete && typeof message.hashToDelete.length === "number" || $util.isString(message.hashToDelete)))
//                     return "hashToDelete: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoDeleteClaimTransactionBody message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoDeleteClaimTransactionBody} CryptoDeleteClaimTransactionBody
//          */
//         CryptoDeleteClaimTransactionBody.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoDeleteClaimTransactionBody)
//                 return object;
//             let message = new $root.proto.CryptoDeleteClaimTransactionBody();
//             if (object.accountIDToDeleteFrom != null) {
//                 if (typeof object.accountIDToDeleteFrom !== "object")
//                     throw TypeError(".proto.CryptoDeleteClaimTransactionBody.accountIDToDeleteFrom: object expected");
//                 message.accountIDToDeleteFrom = $root.proto.AccountID.fromObject(object.accountIDToDeleteFrom);
//             }
//             if (object.hashToDelete != null)
//                 if (typeof object.hashToDelete === "string")
//                     $util.base64.decode(object.hashToDelete, message.hashToDelete = $util.newBuffer($util.base64.length(object.hashToDelete)), 0);
//                 else if (object.hashToDelete.length)
//                     message.hashToDelete = object.hashToDelete;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoDeleteClaimTransactionBody message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @static
//          * @param {proto.CryptoDeleteClaimTransactionBody} message CryptoDeleteClaimTransactionBody
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoDeleteClaimTransactionBody.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.accountIDToDeleteFrom = null;
//                 if (options.bytes === String)
//                     object.hashToDelete = "";
//                 else {
//                     object.hashToDelete = [];
//                     if (options.bytes !== Array)
//                         object.hashToDelete = $util.newBuffer(object.hashToDelete);
//                 }
//             }
//             if (message.accountIDToDeleteFrom != null && message.hasOwnProperty("accountIDToDeleteFrom"))
//                 object.accountIDToDeleteFrom = $root.proto.AccountID.toObject(message.accountIDToDeleteFrom, options);
//             if (message.hashToDelete != null && message.hasOwnProperty("hashToDelete"))
//                 object.hashToDelete = options.bytes === String ? $util.base64.encode(message.hashToDelete, 0, message.hashToDelete.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashToDelete) : message.hashToDelete;
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoDeleteClaimTransactionBody to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoDeleteClaimTransactionBody
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoDeleteClaimTransactionBody.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoDeleteClaimTransactionBody;
//     })();
// 
//     proto.CryptoGetClaimQuery = (function() {
// 
//         /**
//          * Properties of a CryptoGetClaimQuery.
//          * @memberof proto
//          * @interface ICryptoGetClaimQuery
//          * @property {proto.IQueryHeader|null} [header] CryptoGetClaimQuery header
//          * @property {proto.IAccountID|null} [accountID] CryptoGetClaimQuery accountID
//          * @property {Uint8Array|null} [hash] CryptoGetClaimQuery hash
//          */
// 
//         /**
//          * Constructs a new CryptoGetClaimQuery.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetClaimQuery.
//          * @implements ICryptoGetClaimQuery
//          * @constructor
//          * @param {proto.ICryptoGetClaimQuery=} [properties] Properties to set
//          */
//         function CryptoGetClaimQuery(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetClaimQuery header.
//          * @member {proto.IQueryHeader|null|undefined} header
//          * @memberof proto.CryptoGetClaimQuery
//          * @instance
//          */
//         CryptoGetClaimQuery.prototype.header = null;
// 
//         /**
//          * CryptoGetClaimQuery accountID.
//          * @member {proto.IAccountID|null|undefined} accountID
//          * @memberof proto.CryptoGetClaimQuery
//          * @instance
//          */
//         CryptoGetClaimQuery.prototype.accountID = null;
// 
//         /**
//          * CryptoGetClaimQuery hash.
//          * @member {Uint8Array} hash
//          * @memberof proto.CryptoGetClaimQuery
//          * @instance
//          */
//         CryptoGetClaimQuery.prototype.hash = $util.newBuffer([]);
// 
//         /**
//          * Creates a new CryptoGetClaimQuery instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {proto.ICryptoGetClaimQuery=} [properties] Properties to set
//          * @returns {proto.CryptoGetClaimQuery} CryptoGetClaimQuery instance
//          */
//         CryptoGetClaimQuery.create = function create(properties) {
//             return new CryptoGetClaimQuery(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetClaimQuery message. Does not implicitly {@link proto.CryptoGetClaimQuery.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {proto.ICryptoGetClaimQuery} message CryptoGetClaimQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetClaimQuery.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.QueryHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
//                 $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
//                 writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hash);
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetClaimQuery message, length delimited. Does not implicitly {@link proto.CryptoGetClaimQuery.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {proto.ICryptoGetClaimQuery} message CryptoGetClaimQuery message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetClaimQuery.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetClaimQuery message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetClaimQuery} CryptoGetClaimQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetClaimQuery.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetClaimQuery();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.QueryHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
//                     break;
//                 case 3:
//                     message.hash = reader.bytes();
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetClaimQuery message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetClaimQuery} CryptoGetClaimQuery
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetClaimQuery.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetClaimQuery message.
//          * @function verify
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetClaimQuery.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.QueryHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.accountID != null && message.hasOwnProperty("accountID")) {
//                 let error = $root.proto.AccountID.verify(message.accountID);
//                 if (error)
//                     return "accountID." + error;
//             }
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
//                     return "hash: buffer expected";
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetClaimQuery message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetClaimQuery} CryptoGetClaimQuery
//          */
//         CryptoGetClaimQuery.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetClaimQuery)
//                 return object;
//             let message = new $root.proto.CryptoGetClaimQuery();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetClaimQuery.header: object expected");
//                 message.header = $root.proto.QueryHeader.fromObject(object.header);
//             }
//             if (object.accountID != null) {
//                 if (typeof object.accountID !== "object")
//                     throw TypeError(".proto.CryptoGetClaimQuery.accountID: object expected");
//                 message.accountID = $root.proto.AccountID.fromObject(object.accountID);
//             }
//             if (object.hash != null)
//                 if (typeof object.hash === "string")
//                     $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
//                 else if (object.hash.length)
//                     message.hash = object.hash;
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetClaimQuery message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetClaimQuery
//          * @static
//          * @param {proto.CryptoGetClaimQuery} message CryptoGetClaimQuery
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetClaimQuery.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.accountID = null;
//                 if (options.bytes === String)
//                     object.hash = "";
//                 else {
//                     object.hash = [];
//                     if (options.bytes !== Array)
//                         object.hash = $util.newBuffer(object.hash);
//                 }
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.QueryHeader.toObject(message.header, options);
//             if (message.accountID != null && message.hasOwnProperty("accountID"))
//                 object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
//             if (message.hash != null && message.hasOwnProperty("hash"))
//                 object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetClaimQuery to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetClaimQuery
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetClaimQuery.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetClaimQuery;
//     })();
// 
//     proto.CryptoGetClaimResponse = (function() {
// 
//         /**
//          * Properties of a CryptoGetClaimResponse.
//          * @memberof proto
//          * @interface ICryptoGetClaimResponse
//          * @property {proto.IResponseHeader|null} [header] CryptoGetClaimResponse header
//          * @property {proto.IClaim|null} [claim] CryptoGetClaimResponse claim
//          */
// 
//         /**
//          * Constructs a new CryptoGetClaimResponse.
//          * @memberof proto
//          * @classdesc Represents a CryptoGetClaimResponse.
//          * @implements ICryptoGetClaimResponse
//          * @constructor
//          * @param {proto.ICryptoGetClaimResponse=} [properties] Properties to set
//          */
//         function CryptoGetClaimResponse(properties) {
//             if (properties)
//                 for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
//                     if (properties[keys[i]] != null)
//                         this[keys[i]] = properties[keys[i]];
//         }
// 
//         /**
//          * CryptoGetClaimResponse header.
//          * @member {proto.IResponseHeader|null|undefined} header
//          * @memberof proto.CryptoGetClaimResponse
//          * @instance
//          */
//         CryptoGetClaimResponse.prototype.header = null;
// 
//         /**
//          * CryptoGetClaimResponse claim.
//          * @member {proto.IClaim|null|undefined} claim
//          * @memberof proto.CryptoGetClaimResponse
//          * @instance
//          */
//         CryptoGetClaimResponse.prototype.claim = null;
// 
//         /**
//          * Creates a new CryptoGetClaimResponse instance using the specified properties.
//          * @function create
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {proto.ICryptoGetClaimResponse=} [properties] Properties to set
//          * @returns {proto.CryptoGetClaimResponse} CryptoGetClaimResponse instance
//          */
//         CryptoGetClaimResponse.create = function create(properties) {
//             return new CryptoGetClaimResponse(properties);
//         };
// 
//         /**
//          * Encodes the specified CryptoGetClaimResponse message. Does not implicitly {@link proto.CryptoGetClaimResponse.verify|verify} messages.
//          * @function encode
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {proto.ICryptoGetClaimResponse} message CryptoGetClaimResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetClaimResponse.encode = function encode(message, writer) {
//             if (!writer)
//                 writer = $Writer.create();
//             if (message.header != null && Object.hasOwnProperty.call(message, "header"))
//                 $root.proto.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
//             if (message.claim != null && Object.hasOwnProperty.call(message, "claim"))
//                 $root.proto.Claim.encode(message.claim, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
//             return writer;
//         };
// 
//         /**
//          * Encodes the specified CryptoGetClaimResponse message, length delimited. Does not implicitly {@link proto.CryptoGetClaimResponse.verify|verify} messages.
//          * @function encodeDelimited
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {proto.ICryptoGetClaimResponse} message CryptoGetClaimResponse message or plain object to encode
//          * @param {$protobuf.Writer} [writer] Writer to encode to
//          * @returns {$protobuf.Writer} Writer
//          */
//         CryptoGetClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
//             return this.encode(message, writer).ldelim();
//         };
// 
//         /**
//          * Decodes a CryptoGetClaimResponse message from the specified reader or buffer.
//          * @function decode
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @param {number} [length] Message length if known beforehand
//          * @returns {proto.CryptoGetClaimResponse} CryptoGetClaimResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetClaimResponse.decode = function decode(reader, length) {
//             if (!(reader instanceof $Reader))
//                 reader = $Reader.create(reader);
//             let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoGetClaimResponse();
//             while (reader.pos < end) {
//                 let tag = reader.uint32();
//                 switch (tag >>> 3) {
//                 case 1:
//                     message.header = $root.proto.ResponseHeader.decode(reader, reader.uint32());
//                     break;
//                 case 2:
//                     message.claim = $root.proto.Claim.decode(reader, reader.uint32());
//                     break;
//                 default:
//                     reader.skipType(tag & 7);
//                     break;
//                 }
//             }
//             return message;
//         };
// 
//         /**
//          * Decodes a CryptoGetClaimResponse message from the specified reader or buffer, length delimited.
//          * @function decodeDelimited
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
//          * @returns {proto.CryptoGetClaimResponse} CryptoGetClaimResponse
//          * @throws {Error} If the payload is not a reader or valid buffer
//          * @throws {$protobuf.util.ProtocolError} If required fields are missing
//          */
//         CryptoGetClaimResponse.decodeDelimited = function decodeDelimited(reader) {
//             if (!(reader instanceof $Reader))
//                 reader = new $Reader(reader);
//             return this.decode(reader, reader.uint32());
//         };
// 
//         /**
//          * Verifies a CryptoGetClaimResponse message.
//          * @function verify
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {Object.<string,*>} message Plain object to verify
//          * @returns {string|null} `null` if valid, otherwise the reason why it is not
//          */
//         CryptoGetClaimResponse.verify = function verify(message) {
//             if (typeof message !== "object" || message === null)
//                 return "object expected";
//             if (message.header != null && message.hasOwnProperty("header")) {
//                 let error = $root.proto.ResponseHeader.verify(message.header);
//                 if (error)
//                     return "header." + error;
//             }
//             if (message.claim != null && message.hasOwnProperty("claim")) {
//                 let error = $root.proto.Claim.verify(message.claim);
//                 if (error)
//                     return "claim." + error;
//             }
//             return null;
//         };
// 
//         /**
//          * Creates a CryptoGetClaimResponse message from a plain object. Also converts values to their respective internal types.
//          * @function fromObject
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {Object.<string,*>} object Plain object
//          * @returns {proto.CryptoGetClaimResponse} CryptoGetClaimResponse
//          */
//         CryptoGetClaimResponse.fromObject = function fromObject(object) {
//             if (object instanceof $root.proto.CryptoGetClaimResponse)
//                 return object;
//             let message = new $root.proto.CryptoGetClaimResponse();
//             if (object.header != null) {
//                 if (typeof object.header !== "object")
//                     throw TypeError(".proto.CryptoGetClaimResponse.header: object expected");
//                 message.header = $root.proto.ResponseHeader.fromObject(object.header);
//             }
//             if (object.claim != null) {
//                 if (typeof object.claim !== "object")
//                     throw TypeError(".proto.CryptoGetClaimResponse.claim: object expected");
//                 message.claim = $root.proto.Claim.fromObject(object.claim);
//             }
//             return message;
//         };
// 
//         /**
//          * Creates a plain object from a CryptoGetClaimResponse message. Also converts values to other types if specified.
//          * @function toObject
//          * @memberof proto.CryptoGetClaimResponse
//          * @static
//          * @param {proto.CryptoGetClaimResponse} message CryptoGetClaimResponse
//          * @param {$protobuf.IConversionOptions} [options] Conversion options
//          * @returns {Object.<string,*>} Plain object
//          */
//         CryptoGetClaimResponse.toObject = function toObject(message, options) {
//             if (!options)
//                 options = {};
//             let object = {};
//             if (options.defaults) {
//                 object.header = null;
//                 object.claim = null;
//             }
//             if (message.header != null && message.hasOwnProperty("header"))
//                 object.header = $root.proto.ResponseHeader.toObject(message.header, options);
//             if (message.claim != null && message.hasOwnProperty("claim"))
//                 object.claim = $root.proto.Claim.toObject(message.claim, options);
//             return object;
//         };
// 
//         /**
//          * Converts this CryptoGetClaimResponse to JSON.
//          * @function toJSON
//          * @memberof proto.CryptoGetClaimResponse
//          * @instance
//          * @returns {Object.<string,*>} JSON object
//          */
//         CryptoGetClaimResponse.prototype.toJSON = function toJSON() {
//             return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
//         };
// 
//         return CryptoGetClaimResponse;
//     })();
// 
//     proto.CryptoService = (function() {
// 
//         /**
//          * Constructs a new CryptoService service.
//          * @memberof proto
//          * @classdesc Represents a CryptoService
//          * @extends $protobuf.rpc.Service
//          * @constructor
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          */
//         function CryptoService(rpcImpl, requestDelimited, responseDelimited) {
//             $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
//         }
// 
//         (CryptoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CryptoService;
// 
//         /**
//          * Creates new CryptoService service using the specified rpc implementation.
//          * @function create
//          * @memberof proto.CryptoService
//          * @static
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          * @returns {CryptoService} RPC service. Useful where requests and/or responses are streamed.
//          */
//         CryptoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
//             return new this(rpcImpl, requestDelimited, responseDelimited);
//         };
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#createAccount}.
//          * @memberof proto.CryptoService
//          * @typedef createAccountCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls createAccount.
//          * @function createAccount
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.CryptoService.createAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.createAccount = function createAccount(request, callback) {
//             return this.rpcCall(createAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "createAccount" });
// 
//         /**
//          * Calls createAccount.
//          * @function createAccount
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#updateAccount}.
//          * @memberof proto.CryptoService
//          * @typedef updateAccountCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls updateAccount.
//          * @function updateAccount
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.CryptoService.updateAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.updateAccount = function updateAccount(request, callback) {
//             return this.rpcCall(updateAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "updateAccount" });
// 
//         /**
//          * Calls updateAccount.
//          * @function updateAccount
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#cryptoTransfer}.
//          * @memberof proto.CryptoService
//          * @typedef cryptoTransferCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls cryptoTransfer.
//          * @function cryptoTransfer
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.CryptoService.cryptoTransferCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.cryptoTransfer = function cryptoTransfer(request, callback) {
//             return this.rpcCall(cryptoTransfer, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "cryptoTransfer" });
// 
//         /**
//          * Calls cryptoTransfer.
//          * @function cryptoTransfer
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#cryptoDelete}.
//          * @memberof proto.CryptoService
//          * @typedef cryptoDeleteCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls cryptoDelete.
//          * @function cryptoDelete
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.CryptoService.cryptoDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.cryptoDelete = function cryptoDelete(request, callback) {
//             return this.rpcCall(cryptoDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "cryptoDelete" });
// 
//         /**
//          * Calls cryptoDelete.
//          * @function cryptoDelete
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#addLiveHash}.
//          * @memberof proto.CryptoService
//          * @typedef addLiveHashCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls addLiveHash.
//          * @function addLiveHash
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.CryptoService.addLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.addLiveHash = function addLiveHash(request, callback) {
//             return this.rpcCall(addLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "addLiveHash" });
// 
//         /**
//          * Calls addLiveHash.
//          * @function addLiveHash
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#deleteLiveHash}.
//          * @memberof proto.CryptoService
//          * @typedef deleteLiveHashCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls deleteLiveHash.
//          * @function deleteLiveHash
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.CryptoService.deleteLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.deleteLiveHash = function deleteLiveHash(request, callback) {
//             return this.rpcCall(deleteLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "deleteLiveHash" });
// 
//         /**
//          * Calls deleteLiveHash.
//          * @function deleteLiveHash
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#getLiveHash}.
//          * @memberof proto.CryptoService
//          * @typedef getLiveHashCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getLiveHash.
//          * @function getLiveHash
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.getLiveHashCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.getLiveHash = function getLiveHash(request, callback) {
//             return this.rpcCall(getLiveHash, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getLiveHash" });
// 
//         /**
//          * Calls getLiveHash.
//          * @function getLiveHash
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#getAccountRecords}.
//          * @memberof proto.CryptoService
//          * @typedef getAccountRecordsCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getAccountRecords.
//          * @function getAccountRecords
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.getAccountRecordsCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.getAccountRecords = function getAccountRecords(request, callback) {
//             return this.rpcCall(getAccountRecords, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getAccountRecords" });
// 
//         /**
//          * Calls getAccountRecords.
//          * @function getAccountRecords
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#cryptoGetBalance}.
//          * @memberof proto.CryptoService
//          * @typedef cryptoGetBalanceCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls cryptoGetBalance.
//          * @function cryptoGetBalance
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.cryptoGetBalanceCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.cryptoGetBalance = function cryptoGetBalance(request, callback) {
//             return this.rpcCall(cryptoGetBalance, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "cryptoGetBalance" });
// 
//         /**
//          * Calls cryptoGetBalance.
//          * @function cryptoGetBalance
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#getAccountInfo}.
//          * @memberof proto.CryptoService
//          * @typedef getAccountInfoCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getAccountInfo.
//          * @function getAccountInfo
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.getAccountInfoCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.getAccountInfo = function getAccountInfo(request, callback) {
//             return this.rpcCall(getAccountInfo, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getAccountInfo" });
// 
//         /**
//          * Calls getAccountInfo.
//          * @function getAccountInfo
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#getTransactionReceipts}.
//          * @memberof proto.CryptoService
//          * @typedef getTransactionReceiptsCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getTransactionReceipts.
//          * @function getTransactionReceipts
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.getTransactionReceiptsCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.getTransactionReceipts = function getTransactionReceipts(request, callback) {
//             return this.rpcCall(getTransactionReceipts, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getTransactionReceipts" });
// 
//         /**
//          * Calls getTransactionReceipts.
//          * @function getTransactionReceipts
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#getFastTransactionRecord}.
//          * @memberof proto.CryptoService
//          * @typedef getFastTransactionRecordCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getFastTransactionRecord.
//          * @function getFastTransactionRecord
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.getFastTransactionRecordCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.getFastTransactionRecord = function getFastTransactionRecord(request, callback) {
//             return this.rpcCall(getFastTransactionRecord, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getFastTransactionRecord" });
// 
//         /**
//          * Calls getFastTransactionRecord.
//          * @function getFastTransactionRecord
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#getTxRecordByTxID}.
//          * @memberof proto.CryptoService
//          * @typedef getTxRecordByTxIDCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getTxRecordByTxID.
//          * @function getTxRecordByTxID
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.getTxRecordByTxIDCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.getTxRecordByTxID = function getTxRecordByTxID(request, callback) {
//             return this.rpcCall(getTxRecordByTxID, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getTxRecordByTxID" });
// 
//         /**
//          * Calls getTxRecordByTxID.
//          * @function getTxRecordByTxID
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.CryptoService#getStakersByAccountID}.
//          * @memberof proto.CryptoService
//          * @typedef getStakersByAccountIDCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getStakersByAccountID.
//          * @function getStakersByAccountID
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.CryptoService.getStakersByAccountIDCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(CryptoService.prototype.getStakersByAccountID = function getStakersByAccountID(request, callback) {
//             return this.rpcCall(getStakersByAccountID, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getStakersByAccountID" });
// 
//         /**
//          * Calls getStakersByAccountID.
//          * @function getStakersByAccountID
//          * @memberof proto.CryptoService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         return CryptoService;
//     })();
// 
//     proto.FileService = (function() {
// 
//         /**
//          * Constructs a new FileService service.
//          * @memberof proto
//          * @classdesc Represents a FileService
//          * @extends $protobuf.rpc.Service
//          * @constructor
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          */
//         function FileService(rpcImpl, requestDelimited, responseDelimited) {
//             $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
//         }
// 
//         (FileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FileService;
// 
//         /**
//          * Creates new FileService service using the specified rpc implementation.
//          * @function create
//          * @memberof proto.FileService
//          * @static
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          * @returns {FileService} RPC service. Useful where requests and/or responses are streamed.
//          */
//         FileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
//             return new this(rpcImpl, requestDelimited, responseDelimited);
//         };
// 
//         /**
//          * Callback as used by {@link proto.FileService#createFile}.
//          * @memberof proto.FileService
//          * @typedef createFileCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls createFile.
//          * @function createFile
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.FileService.createFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.createFile = function createFile(request, callback) {
//             return this.rpcCall(createFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "createFile" });
// 
//         /**
//          * Calls createFile.
//          * @function createFile
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.FileService#updateFile}.
//          * @memberof proto.FileService
//          * @typedef updateFileCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls updateFile.
//          * @function updateFile
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.FileService.updateFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.updateFile = function updateFile(request, callback) {
//             return this.rpcCall(updateFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "updateFile" });
// 
//         /**
//          * Calls updateFile.
//          * @function updateFile
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.FileService#deleteFile}.
//          * @memberof proto.FileService
//          * @typedef deleteFileCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls deleteFile.
//          * @function deleteFile
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.FileService.deleteFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.deleteFile = function deleteFile(request, callback) {
//             return this.rpcCall(deleteFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "deleteFile" });
// 
//         /**
//          * Calls deleteFile.
//          * @function deleteFile
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.FileService#appendContent}.
//          * @memberof proto.FileService
//          * @typedef appendContentCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls appendContent.
//          * @function appendContent
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.FileService.appendContentCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.appendContent = function appendContent(request, callback) {
//             return this.rpcCall(appendContent, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "appendContent" });
// 
//         /**
//          * Calls appendContent.
//          * @function appendContent
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.FileService#getFileContent}.
//          * @memberof proto.FileService
//          * @typedef getFileContentCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getFileContent.
//          * @function getFileContent
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.FileService.getFileContentCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.getFileContent = function getFileContent(request, callback) {
//             return this.rpcCall(getFileContent, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getFileContent" });
// 
//         /**
//          * Calls getFileContent.
//          * @function getFileContent
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.FileService#getFileInfo}.
//          * @memberof proto.FileService
//          * @typedef getFileInfoCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getFileInfo.
//          * @function getFileInfo
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.FileService.getFileInfoCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.getFileInfo = function getFileInfo(request, callback) {
//             return this.rpcCall(getFileInfo, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getFileInfo" });
// 
//         /**
//          * Calls getFileInfo.
//          * @function getFileInfo
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.FileService#systemDelete}.
//          * @memberof proto.FileService
//          * @typedef systemDeleteCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls systemDelete.
//          * @function systemDelete
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.FileService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.systemDelete = function systemDelete(request, callback) {
//             return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "systemDelete" });
// 
//         /**
//          * Calls systemDelete.
//          * @function systemDelete
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.FileService#systemUndelete}.
//          * @memberof proto.FileService
//          * @typedef systemUndeleteCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls systemUndelete.
//          * @function systemUndelete
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.FileService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FileService.prototype.systemUndelete = function systemUndelete(request, callback) {
//             return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "systemUndelete" });
// 
//         /**
//          * Calls systemUndelete.
//          * @function systemUndelete
//          * @memberof proto.FileService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         return FileService;
//     })();
// 
//     proto.FreezeService = (function() {
// 
//         /**
//          * Constructs a new FreezeService service.
//          * @memberof proto
//          * @classdesc Represents a FreezeService
//          * @extends $protobuf.rpc.Service
//          * @constructor
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          */
//         function FreezeService(rpcImpl, requestDelimited, responseDelimited) {
//             $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
//         }
// 
//         (FreezeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FreezeService;
// 
//         /**
//          * Creates new FreezeService service using the specified rpc implementation.
//          * @function create
//          * @memberof proto.FreezeService
//          * @static
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          * @returns {FreezeService} RPC service. Useful where requests and/or responses are streamed.
//          */
//         FreezeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
//             return new this(rpcImpl, requestDelimited, responseDelimited);
//         };
// 
//         /**
//          * Callback as used by {@link proto.FreezeService#freeze}.
//          * @memberof proto.FreezeService
//          * @typedef freezeCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls freeze.
//          * @function freeze
//          * @memberof proto.FreezeService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.FreezeService.freezeCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(FreezeService.prototype.freeze = function freeze(request, callback) {
//             return this.rpcCall(freeze, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "freeze" });
// 
//         /**
//          * Calls freeze.
//          * @function freeze
//          * @memberof proto.FreezeService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         return FreezeService;
//     })();
// 
//     proto.NetworkService = (function() {
// 
//         /**
//          * Constructs a new NetworkService service.
//          * @memberof proto
//          * @classdesc Represents a NetworkService
//          * @extends $protobuf.rpc.Service
//          * @constructor
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          */
//         function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
//             $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
//         }
// 
//         (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NetworkService;
// 
//         /**
//          * Creates new NetworkService service using the specified rpc implementation.
//          * @function create
//          * @memberof proto.NetworkService
//          * @static
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          * @returns {NetworkService} RPC service. Useful where requests and/or responses are streamed.
//          */
//         NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
//             return new this(rpcImpl, requestDelimited, responseDelimited);
//         };
// 
//         /**
//          * Callback as used by {@link proto.NetworkService#getVersionInfo}.
//          * @memberof proto.NetworkService
//          * @typedef getVersionInfoCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getVersionInfo.
//          * @function getVersionInfo
//          * @memberof proto.NetworkService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.NetworkService.getVersionInfoCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(NetworkService.prototype.getVersionInfo = function getVersionInfo(request, callback) {
//             return this.rpcCall(getVersionInfo, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getVersionInfo" });
// 
//         /**
//          * Calls getVersionInfo.
//          * @function getVersionInfo
//          * @memberof proto.NetworkService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         return NetworkService;
//     })();
// 
//     proto.SmartContractService = (function() {
// 
//         /**
//          * Constructs a new SmartContractService service.
//          * @memberof proto
//          * @classdesc Represents a SmartContractService
//          * @extends $protobuf.rpc.Service
//          * @constructor
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          */
//         function SmartContractService(rpcImpl, requestDelimited, responseDelimited) {
//             $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
//         }
// 
//         (SmartContractService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SmartContractService;
// 
//         /**
//          * Creates new SmartContractService service using the specified rpc implementation.
//          * @function create
//          * @memberof proto.SmartContractService
//          * @static
//          * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
//          * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
//          * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
//          * @returns {SmartContractService} RPC service. Useful where requests and/or responses are streamed.
//          */
//         SmartContractService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
//             return new this(rpcImpl, requestDelimited, responseDelimited);
//         };
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#createContract}.
//          * @memberof proto.SmartContractService
//          * @typedef createContractCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls createContract.
//          * @function createContract
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.SmartContractService.createContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.createContract = function createContract(request, callback) {
//             return this.rpcCall(createContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "createContract" });
// 
//         /**
//          * Calls createContract.
//          * @function createContract
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#updateContract}.
//          * @memberof proto.SmartContractService
//          * @typedef updateContractCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls updateContract.
//          * @function updateContract
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.SmartContractService.updateContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.updateContract = function updateContract(request, callback) {
//             return this.rpcCall(updateContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "updateContract" });
// 
//         /**
//          * Calls updateContract.
//          * @function updateContract
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#contractCallMethod}.
//          * @memberof proto.SmartContractService
//          * @typedef contractCallMethodCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls contractCallMethod.
//          * @function contractCallMethod
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.SmartContractService.contractCallMethodCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.contractCallMethod = function contractCallMethod(request, callback) {
//             return this.rpcCall(contractCallMethod, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "contractCallMethod" });
// 
//         /**
//          * Calls contractCallMethod.
//          * @function contractCallMethod
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#getContractInfo}.
//          * @memberof proto.SmartContractService
//          * @typedef getContractInfoCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getContractInfo.
//          * @function getContractInfo
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.SmartContractService.getContractInfoCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.getContractInfo = function getContractInfo(request, callback) {
//             return this.rpcCall(getContractInfo, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getContractInfo" });
// 
//         /**
//          * Calls getContractInfo.
//          * @function getContractInfo
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#contractCallLocalMethod}.
//          * @memberof proto.SmartContractService
//          * @typedef contractCallLocalMethodCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls contractCallLocalMethod.
//          * @function contractCallLocalMethod
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.SmartContractService.contractCallLocalMethodCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.contractCallLocalMethod = function contractCallLocalMethod(request, callback) {
//             return this.rpcCall(contractCallLocalMethod, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "contractCallLocalMethod" });
// 
//         /**
//          * Calls contractCallLocalMethod.
//          * @function contractCallLocalMethod
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#contractGetBytecode}.
//          * @memberof proto.SmartContractService
//          * @typedef ContractGetBytecodeCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls ContractGetBytecode.
//          * @function contractGetBytecode
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.SmartContractService.ContractGetBytecodeCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.contractGetBytecode = function contractGetBytecode(request, callback) {
//             return this.rpcCall(contractGetBytecode, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "ContractGetBytecode" });
// 
//         /**
//          * Calls ContractGetBytecode.
//          * @function contractGetBytecode
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#getBySolidityID}.
//          * @memberof proto.SmartContractService
//          * @typedef getBySolidityIDCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getBySolidityID.
//          * @function getBySolidityID
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.SmartContractService.getBySolidityIDCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.getBySolidityID = function getBySolidityID(request, callback) {
//             return this.rpcCall(getBySolidityID, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getBySolidityID" });
// 
//         /**
//          * Calls getBySolidityID.
//          * @function getBySolidityID
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#getTxRecordByContractID}.
//          * @memberof proto.SmartContractService
//          * @typedef getTxRecordByContractIDCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.Response} [response] Response
//          */
// 
//         /**
//          * Calls getTxRecordByContractID.
//          * @function getTxRecordByContractID
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @param {proto.SmartContractService.getTxRecordByContractIDCallback} callback Node-style callback called with the error, if any, and Response
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.getTxRecordByContractID = function getTxRecordByContractID(request, callback) {
//             return this.rpcCall(getTxRecordByContractID, $root.proto.Query, $root.proto.Response, request, callback);
//         }, "name", { value: "getTxRecordByContractID" });
// 
//         /**
//          * Calls getTxRecordByContractID.
//          * @function getTxRecordByContractID
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.IQuery} request Query message or plain object
//          * @returns {Promise<proto.Response>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#deleteContract}.
//          * @memberof proto.SmartContractService
//          * @typedef deleteContractCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls deleteContract.
//          * @function deleteContract
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.SmartContractService.deleteContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.deleteContract = function deleteContract(request, callback) {
//             return this.rpcCall(deleteContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "deleteContract" });
// 
//         /**
//          * Calls deleteContract.
//          * @function deleteContract
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#systemDelete}.
//          * @memberof proto.SmartContractService
//          * @typedef systemDeleteCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls systemDelete.
//          * @function systemDelete
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.SmartContractService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.systemDelete = function systemDelete(request, callback) {
//             return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "systemDelete" });
// 
//         /**
//          * Calls systemDelete.
//          * @function systemDelete
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         /**
//          * Callback as used by {@link proto.SmartContractService#systemUndelete}.
//          * @memberof proto.SmartContractService
//          * @typedef systemUndeleteCallback
//          * @type {function}
//          * @param {Error|null} error Error, if any
//          * @param {proto.TransactionResponse} [response] TransactionResponse
//          */
// 
//         /**
//          * Calls systemUndelete.
//          * @function systemUndelete
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @param {proto.SmartContractService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
//          * @returns {undefined}
//          * @variation 1
//          */
//         Object.defineProperty(SmartContractService.prototype.systemUndelete = function systemUndelete(request, callback) {
//             return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
//         }, "name", { value: "systemUndelete" });
// 
//         /**
//          * Calls systemUndelete.
//          * @function systemUndelete
//          * @memberof proto.SmartContractService
//          * @instance
//          * @param {proto.ITransaction} request Transaction message or plain object
//          * @returns {Promise<proto.TransactionResponse>} Promise
//          * @variation 2
//          */
// 
//         return SmartContractService;
//     })();
// 
//     return proto;
// })();
// 
// export { $root as default };
